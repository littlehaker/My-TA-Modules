new Array.new(...)\nReturns a new array. In the first form, the new array is\nempty. In the second it is created with _size_ copies of _obj_\n(that is, _size_ references to the same\n_obj_). The third form creates a copy of the array\npassed as a parameter (the array is generated by calling\nto_ary  on the parameter). In the last form, an array\nof the given size is created. Each element in this array is\ncalculated by passing the element's index to the given block and\nstoring the return value.\n\n   Array.new\n   Array.new(2)\n   Array.new(5, "A")\n only one copy of the object is created\n   a = Array.new(2, Hash.new)\n   a[0]['cat'] = 'feline'\n   a\n   a[1]['cat'] = 'Felix'\n   a\n here multiple copies are created\n   a = Array.new(2) { Hash.new }\n   a[0]['cat'] = 'feline'\n   a\n\n   squares = Array.new(5) {|i| i*i}\n   squares\n\n   copy = Array.new(squares)\n
try_convert Array.try_convert(p1)\nTry to convert <i>obj</i> into an array, using +to_ary+ method.\nReturns converted array or +nil+ if <i>obj</i> cannot be converted\nfor any reason. This method can be used to check if an argument is an\narray.\n\n   Array.try_convert([1])   #=> [1]\n   Array.try_convert("1")   #=> nil\n\n   if tmp = Array.try_convert(arg)\n the argument is an array\n   elsif tmp = String.try_convert(arg)\n the argument is a string\n   end\n
assoc Array.assoc(p1)\nSearches through an array whose elements are also arrays\ncomparing _obj_ with the first element of each contained array\nusing obj.==.\nReturns the first contained array that matches (that\nis, the first associated array),\nor +nil+ if no match is found.\nSee also `Array#rassoc`.\n\n   s1 = [ "colors", "red", "blue", "green" ]\n   s2 = [ "letters", "a", "b", "c" ]\n   s3 = "foo"\n   a  = [ s1, s2, s3 ]\n   a.assoc("letters")  #=> [ "letters", "a", "b", "c" ]\n   a.assoc("foo")      #=> nil\n
at Array.at(p1)\nReturns the element at _index_. A\nnegative index counts from the end of +self+.  Returns +nil+\nif the index is out of range. See also `Array#[]`.\n\n   a = [ "a", "b", "c", "d", "e" ]\n   a.at(0)     #=> "a"\n   a.at(-1)    #=> "e"\n
clear Array.clear()\nRemoves all elements from +self+.\n\n   a = [ "a", "b", "c", "d", "e" ]\n   a.clear    #=> [ ]\n
collect Array.collect()\nInvokes <i>block</i> once for each element of +self+. Creates a\nnew array containing the values returned by the block.\nSee also `Enumerable#collect`.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c", "d" ]\n   a.collect {|x| x + "!" }   #=> ["a!", "b!", "c!", "d!"]\n   a                          #=> ["a", "b", "c", "d"]\n
collect! Array.collect!()\nInvokes the block once for each element of +self+, replacing the\nelement with the value returned by _block_.\nSee also `Enumerable#collect`.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c", "d" ]\n   a.collect! {|x| x + "!" }\n   a             #=>  [ "a!", "b!", "c!", "d!" ]\n
combination Array.combination(p1)\n\nWhen invoked with a block, yields all combinations of length <i>n</i>\nof elements from <i>ary</i> and then returns <i>ary</i> itself.\nThe implementation makes no guarantees about the order in which\nthe combinations are yielded.\n\nIf no block is given, an enumerator is returned instead.\n\nExamples:\n\n    a = [1, 2, 3, 4]\n    a.combination(1).to_a  #=> [[1],[2],[3],[4]]\n    a.combination(2).to_a  #=> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n    a.combination(3).to_a  #=> [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]\n    a.combination(4).to_a  #=> [[1,2,3,4]]\n    a.combination(0).to_a  #=> [[]] # one combination of length 0\n    a.combination(5).to_a  #=> []   # no combinations of length 5\n
compact Array.compact()\nReturns a copy of +self+ with all +nil+ elements removed.\n\n   [ "a", nil, "b", nil, "c", nil ].compact\n=> [ "a", "b", "c" ]\n
compact! Array.compact!()\nRemoves +nil+ elements from the array.\nReturns +nil+ if no changes were made, otherwise returns\n</i>ary</i>.\n\n   [ "a", nil, "b", nil, "c" ].compact! #=> [ "a", "b", "c" ]\n   [ "a", "b", "c" ].compact!           #=> nil\n
concat Array.concat(p1)\nAppends the elements of <i>other_ary</i> to +self+.\n\n   [ "a", "b" ].concat( ["c", "d"] ) #=> [ "a", "b", "c", "d" ]\n
count Array.count(...)\nReturns the number of elements.  If an argument is given, counts\nthe number of elements which equals to <i>obj</i>.  If a block is\ngiven, counts the number of elements yielding a true value.\n\n   ary = [1, 2, 4, 2]\n   ary.count             #=> 4\n   ary.count(2)          #=> 2\n   ary.count{|x|x%2==0}  #=> 3\n
cycle Array.cycle(...)\nCalls <i>block</i> for each element repeatedly _n_ times or\nforever if none or +nil+ is given.  If a non-positive number is\ngiven or the array is empty, does nothing.  Returns +nil+ if the\nloop has finished without getting interrupted.\n\nIf no block is given, an enumerator is returned instead.\n\n\n   a = ["a", "b", "c"]\n   a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.\n   a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.\n
delete Array.delete(p1)\nDeletes items from +self+ that are equal to <i>obj</i>.\nIf any items are found, returns <i>obj</i>.   If\nthe item is not found, returns `nil`. If the optional\ncode block is given, returns the result of <i>block</i> if the item\nis not found.  (To remove `nil` elements and\nget an informative return value, use #compact!)\n\n   a = [ "a", "b", "b", "b", "c" ]\n   a.delete("b")                   #=> "b"\n   a                               #=> ["a", "c"]\n   a.delete("z")                   #=> nil\n   a.delete("z") { "not found" }   #=> "not found"\n
delete_at Array.delete_at(p1)\nDeletes the element at the specified index, returning that element,\nor `nil` if the index is out of range. See also\n`Array#slice!`.\n\n   a = %w( ant bat cat dog )\n   a.delete_at(2)    #=> "cat"\n   a                 #=> ["ant", "bat", "dog"]\n   a.delete_at(99)   #=> nil\n
delete_if Array.delete_if()\nDeletes every element of +self+ for which <i>block</i> evaluates\nto true.\nSee also `Array#reject!`\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c" ]\n   a.delete_if {|x| x >= "b" }   #=> ["a"]\n
drop Array.drop(p1)\nDrops first n elements from <i>ary</i>, and returns rest elements\nin an array.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.drop(3)             #=> [4, 5, 0]\n
drop_while Array.drop_while()\nDrops elements up to, but not including, the first element for\nwhich the block returns +nil+ or +false+ and returns an array\ncontaining the remaining elements.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.drop_while {|i| i < 3 }   #=> [3, 4, 5, 0]\n
each Array.each()\nCalls <i>block</i> once for each element in +self+, passing that\nelement as a parameter.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c" ]\n   a.each {|x| print x, " -- " }\n\nproduces:\n\n   a -- b -- c --\n
each_index Array.each_index()\nSame as `Array#each`, but passes the index of the element\ninstead of the element itself.\n\nIf no block is given, an enumerator is returned instead.\n\n\n   a = [ "a", "b", "c" ]\n   a.each_index {|x| print x, " -- " }\n\nproduces:\n\n   0 -- 1 -- 2 --\n
empty? Array.empty?()\nReturns `true` if +self+ contains no elements.\n\n   [].empty?   #=> true\n
eql? Array.eql?(p1)\nReturns `true` if +self+ and _other_ are the same object,\nor are both arrays with the same content.\n
fetch Array.fetch(...)\nTries to return the element at position <i>index</i>. If the index\nlies outside the array, the first form throws an\n`IndexError` exception, the second form returns\n<i>default</i>, and the third form returns the value of invoking\nthe block, passing in the index. Negative values of <i>index</i>\ncount from the end of the array.\n\n   a = [ 11, 22, 33, 44 ]\n   a.fetch(1)               #=> 22\n   a.fetch(-1)              #=> 44\n   a.fetch(4, 'cat')        #=> "cat"\n   a.fetch(4) { |i| i*i }   #=> 16\n
fill Array.fill(...)\nThe first three forms set the selected elements of +self+ (which\nmay be the entire array) to <i>obj</i>. A <i>start</i> of\n`nil` is equivalent to zero. A <i>length</i> of\n`nil` is equivalent to <i>self.length</i>. The last three\nforms fill the array with the value of the block. The block is\npassed the absolute index of each element to be filled.\nNegative values of <i>start</i> count from the end of the array.\n\n   a = [ "a", "b", "c", "d" ]\n   a.fill("x")              #=> ["x", "x", "x", "x"]\n   a.fill("z", 2, 2)        #=> ["x", "x", "z", "z"]\n   a.fill("y", 0..1)        #=> ["y", "y", "z", "z"]\n   a.fill {|i| i*i}         #=> [0, 1, 4, 9]\n   a.fill(-2) {|i| i*i*i}   #=> [0, 1, 8, 27]\n
find_index Array.find_index(...)\nReturns the index of the first object in +self+ such that is\n`==` to <i>obj</i>. If a block is given instead of an\nargument, returns first object for which <em>block</em> is true.\nReturns `nil` if no match is found.\nSee also `Array#rindex`.\n\nIf neither block nor argument is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c" ]\n   a.index("b")        #=> 1\n   a.index("z")        #=> nil\n   a.index{|x|x=="b"}  #=> 1\n\nThis is an alias of `#find_index`.\n
first Array.first(...)\nReturns the first element, or the first +n+ elements, of the array.\nIf the array is empty, the first form returns `nil`, and the\nsecond form returns an empty array.\n\n   a = [ "q", "r", "s", "t" ]\n   a.first     #=> "q"\n   a.first(2)  #=> ["q", "r"]\n
flatten Array.flatten(...)\nReturns a new array that is a one-dimensional flattening of this\narray (recursively). That is, for every element that is an array,\nextract its elements into the new array.  If the optional\n<i>level</i> argument determines the level of recursion to flatten.\n\n   s = [ 1, 2, 3 ]           #=> [1, 2, 3]\n   t = [ 4, 5, 6, [7, 8] ]   #=> [4, 5, 6, [7, 8]]\n   a = [ s, t, 9, 10 ]       #=> [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]\n   a.flatten                 #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n   a = [ 1, 2, [3, [4, 5] ] ]\n   a.flatten(1)              #=> [1, 2, 3, [4, 5]]\n
flatten! Array.flatten!(...)\nFlattens +self+ in place.\nReturns `nil` if no modifications were made (i.e.,\n<i>ary</i> contains no subarrays.)  If the optional <i>level</i>\nargument determines the level of recursion to flatten.\n\n   a = [ 1, 2, [3, [4, 5] ] ]\n   a.flatten!   #=> [1, 2, 3, 4, 5]\n   a.flatten!   #=> nil\n   a            #=> [1, 2, 3, 4, 5]\n   a = [ 1, 2, [3, [4, 5] ] ]\n   a.flatten!(1) #=> [1, 2, 3, [4, 5]]\n
frozen? Array.frozen?()\nReturn `true` if this array is frozen (or temporarily frozen\nwhile being sorted).\n
hash Array.hash()\nCompute a hash-code for this array. Two arrays with the same content\nwill have the same hash code (and will compare using `eql?`).\n
include? Array.include?(p1)\nReturns `true` if the given object is present in\n+self+ (that is, if any object `==` <i>anObject</i>),\n`false` otherwise.\n\n   a = [ "a", "b", "c" ]\n   a.include?("b")   #=> true\n   a.include?("z")   #=> false\n
index Array.index(...)\nReturns the index of the first object in +self+ such that is\n`==` to <i>obj</i>. If a block is given instead of an\nargument, returns first object for which <em>block</em> is true.\nReturns `nil` if no match is found.\nSee also `Array#rindex`.\n\nIf neither block nor argument is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c" ]\n   a.index("b")        #=> 1\n   a.index("z")        #=> nil\n   a.index{|x|x=="b"}  #=> 1\n\nThis is an alias of `#find_index`.\n
initialize_copy Array.initialize_copy(p1)\nReplaces the contents of +self+ with the contents of\n<i>other_ary</i>, truncating or expanding if necessary.\n\n   a = [ "a", "b", "c", "d", "e" ]\n   a.replace([ "x", "y", "z" ])   #=> ["x", "y", "z"]\n   a                              #=> ["x", "y", "z"]\n
insert Array.insert(...)\nInserts the given values before the element with the given index\n(which may be negative).\n\n   a = %w{ a b c d }\n   a.insert(2, 99)         #=> ["a", "b", 99, "c", "d"]\n   a.insert(-2, 1, 2, 3)   #=> ["a", "b", 99, "c", 1, 2, 3, "d"]\n
inspect Array.inspect()\nCreates a string representation of +self+.\n
join Array.join(...)\nReturns a string created by converting each element of the array to\na string, separated by <i>sep</i>.\n\n   [ "a", "b", "c" ].join        #=> "abc"\n   [ "a", "b", "c" ].join("-")   #=> "a-b-c"\n
keep_if Array.keep_if()\nDeletes every element of +self+ for which <i>block</i> evaluates\nto false.\nSee also `Array#select!`\n\nIf no block is given, an enumerator is returned instead.\n\n   a = %w{ a b c d e f }\n   a.keep_if {|v| v =~ /[aeiou]/}   #=> ["a", "e"]\n
last Array.last(...)\nReturns the last element(s) of +self+. If the array is empty,\nthe first form returns `nil`.\n\n   a = [ "w", "x", "y", "z" ]\n   a.last     #=> "z"\n   a.last(2)  #=> ["y", "z"]\n
length Array.length()\nReturns the number of elements in +self+. May be zero.\n\n   [ 1, 2, 3, 4, 5 ].length   #=> 5\n
map Array.map()\nInvokes <i>block</i> once for each element of +self+. Creates a\nnew array containing the values returned by the block.\nSee also `Enumerable#collect`.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c", "d" ]\n   a.collect {|x| x + "!" }   #=> ["a!", "b!", "c!", "d!"]\n   a                          #=> ["a", "b", "c", "d"]\n
map! Array.map!()\nInvokes the block once for each element of +self+, replacing the\nelement with the value returned by _block_.\nSee also `Enumerable#collect`.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c", "d" ]\n   a.collect! {|x| x + "!" }\n   a             #=>  [ "a!", "b!", "c!", "d!" ]\n
pack Array.pack(p1)\nPacks the contents of <i>arr</i> into a binary sequence according to\nthe directives in <i>aTemplateString</i> (see the table below)\nDirectives ``A,'' ``a,'' and ``Z'' may be followed by a count,\nwhich gives the width of the resulting field. The remaining\ndirectives also may take a count, indicating the number of array\nelements to convert. If the count is an asterisk\n(```*`''), all remaining array elements will be\nconverted. Any of the directives ```sSiIlL`'' may be\nfollowed by an underscore (```_`'') or\nexclamation mark (```!`'') to use the underlying\nplatform's native size for the specified type; otherwise, they use a\nplatform-independent size. Spaces are ignored in the template\nstring. See also `String#unpack`.\n\n   a = [ "a", "b", "c" ]\n   n = [ 65, 66, 67 ]\n   a.pack("A3A3A3")   #=> "a  b  c  "\n   a.pack("a3a3a3")   #=> "a\000\000b\000\000c\000\000"\n   n.pack("ccc")      #=> "ABC"\n\nDirectives for +pack+.\n\n Integer      | Array   |\n Directive    | Element | Meaning\n ---------------------------------------------------------------------------\n    C         | Integer | 8-bit unsigned integer (unsigned char)\n    S         | Integer | 16-bit unsigned integer, native endian (uint16_t)\n    L         | Integer | 32-bit unsigned integer, native endian (uint32_t)\n    Q         | Integer | 64-bit unsigned integer, native endian (uint64_t)\n              |         |\n    c         | Integer | 8-bit signed integer (char)\n    s         | Integer | 16-bit signed integer, native endian (int16_t)\n    l         | Integer | 32-bit signed integer, native endian (int32_t)\n    q         | Integer | 64-bit signed integer, native endian (int64_t)\n              |         |\n    S_, S!    | Integer | unsigned short, native endian\n    I, I_, I! | Integer | unsigned int, native endian\n    L_, L!    | Integer | unsigned long, native endian\n              |         |\n    s_, s!    | Integer | signed short, native endian\n    i, i_, i! | Integer | signed int, native endian\n    l_, l!    | Integer | signed long, native endian\n              |         |\n    n         | Integer | 16-bit unsigned integer, network (big-endian)\n    byte order\n    N         | Integer | 32-bit unsigned integer, network (big-endian)\n    byte order\n    v         | Integer | 16-bit unsigned integer, VAX (little-endian)\n    byte order\n    V         | Integer | 32-bit unsigned integer, VAX (little-endian)\n    byte order\n              |         |\n    U         | Integer | UTF-8 character\n    w         | Integer | BER-compressed integer\n\n Float        |         |\n Directive    |         | Meaning\n ---------------------------------------------------------------------------\n    D, d      | Float   | double-precision float, native format\n    F, f      | Float   | single-precision float, native format\n    E         | Float   | double-precision float, little-endian byte order\n    e         | Float   | single-precision float, little-endian byte order\n    G         | Float   | double-precision float, network (big-endian)\n    byte order\n    g         | Float   | single-precision float, network (big-endian)\n    byte order\n\n String       |         |\n Directive    |         | Meaning\n ---------------------------------------------------------------------------\n    A         | String  | arbitrary binary string (space padded, count\n    is width)\n    a         | String  | arbitrary binary string (null padded, count is width)\n    Z         | String  | same as ``a'', except that null is added with *\n    B         | String  | bit string (MSB first)\n    b         | String  | bit string (LSB first)\n    H         | String  | hex string (high nibble first)\n    h         | String  | hex string (low nibble first)\n    u         | String  | UU-encoded string\n    M         | String  | quoted printable, MIME encoding (see RFC2045)\n    m         | String  | base64 encoded string (see RFC 2045, count is width)\n              |         | (if count is 0, no line feed are added, see RFC 4648)\n    P         | String  | pointer to a structure (fixed-length string)\n    p         | String  | pointer to a null-terminated string\n\n Misc.        |         |\n Directive    |         | Meaning\n ---------------------------------------------------------------------------\n    @         | ---     | moves to absolute position\n    X         | ---     | back up a byte\n    x         | ---     | null byte\n
permutation Array.permutation(...)\n\nWhen invoked with a block, yield all permutations of length <i>n</i>\nof the elements of <i>ary</i>, then return the array itself.\nIf <i>n</i> is not specified, yield all permutations of all elements.\nThe implementation makes no guarantees about the order in which\nthe permutations are yielded.\n\nIf no block is given, an enumerator is returned instead.\n\nExamples:\n\n    a = [1, 2, 3]\n    a.permutation.to_a     #=>\n    [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n    a.permutation(1).to_a  #=> [[1],[2],[3]]\n    a.permutation(2).to_a  #=> [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]\n    a.permutation(3).to_a  #=>\n    [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n    a.permutation(0).to_a  #=> [[]] # one permutation of length 0\n    a.permutation(4).to_a  #=> []   # no permutations of length 4\n
pop Array.pop(...)\nRemoves the last element from +self+ and returns it, or\n`nil` if the array is empty.\n\nIf a number _n_ is given, returns an array of the last n elements\n(or less) just like `array.slice!(-n, n)` does.\n\n   a = [ "a", "b", "c", "d" ]\n   a.pop     #=> "d"\n   a.pop(2)  #=> ["b", "c"]\n   a         #=> ["a"]\n
product Array.product(...)\nReturns an array of all combinations of elements from all arrays,\nThe length of the returned array is the product of the length\nof +self+ and the argument arrays.\nIf given a block, <i>product</i> will yield all combinations\nand return +self+ instead.\n\n\n   [1,2,3].product([4,5])     #=> [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]\n   [1,2].product([1,2])       #=> [[1,1],[1,2],[2,1],[2,2]]\n   [1,2].product([3,4],[5,6]) #=> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],\n     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]\n   [1,2].product()            #=> [[1],[2]]\n   [1,2].product([])          #=> []\n
push Array.push(...)\nAppend---Pushes the given object(s) on to the end of this array. This\nexpression returns the array itself, so several appends\nmay be chained together.\n\n   a = [ "a", "b", "c" ]\n   a.push("d", "e", "f")\n=> ["a", "b", "c", "d", "e", "f"]\n
rassoc Array.rassoc(p1)\nSearches through the array whose elements are also arrays. Compares\n_obj_ with the second element of each contained array using\n`==`. Returns the first contained array that matches. See\nalso `Array#assoc`.\n\n   a = [ [ 1, "one"], [2, "two"], [3, "three"], ["ii", "two"] ]\n   a.rassoc("two")    #=> [2, "two"]\n   a.rassoc("four")   #=> nil\n
reject Array.reject()\nReturns a new array containing the items in +self+\nfor which the block is not true.\nSee also `Array#delete_if`\n\nIf no block is given, an enumerator is returned instead.\n
reject! Array.reject!()\nEquivalent to `Array#delete_if`, deleting elements from\n+self+ for which the block evaluates to true, but returns\n`nil` if no changes were made.\nSee also `Enumerable#reject` and `Array#delete_if`.\n\nIf no block is given, an enumerator is returned instead.\n
repeated_combination Array.repeated_combination(p1)\n\nWhen invoked with a block, yields all repeated combinations of\nlength <i>n</i> of elements from <i>ary</i> and then returns\n<i>ary</i> itself.\nThe implementation makes no guarantees about the order in which\nthe repeated combinations are yielded.\n\nIf no block is given, an enumerator is returned instead.\n\nExamples:\n\n    a = [1, 2, 3]\n    a.repeated_combination(1).to_a  #=> [[1], [2], [3]]\n    a.repeated_combination(2).to_a  #=> [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]\n    a.repeated_combination(3).to_a  #=>\n    [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],\n    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]\n    a.repeated_combination(4).to_a  #=>\n    [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],\n    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],\n    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]\n    a.repeated_combination(0).to_a  #=> [[]] # one combination of length 0\n
repeated_permutation Array.repeated_permutation(p1)\n\nWhen invoked with a block, yield all repeated permutations of length\n<i>n</i> of the elements of <i>ary</i>, then return the array itself.\nThe implementation makes no guarantees about the order in which\nthe repeated permutations are yielded.\n\nIf no block is given, an enumerator is returned instead.\n\nExamples:\n\n    a = [1, 2]\n    a.repeated_permutation(1).to_a  #=> [[1], [2]]\n    a.repeated_permutation(2).to_a  #=> [[1,1],[1,2],[2,1],[2,2]]\n    a.repeated_permutation(3).to_a  #=> [[1,1,1],[1,1,2],[1,2,1],[1,2,2],\n    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]\n    a.repeated_permutation(0).to_a  #=> [[]] # one permutation of length 0\n
replace Array.replace(p1)\nReplaces the contents of +self+ with the contents of\n<i>other_ary</i>, truncating or expanding if necessary.\n\n   a = [ "a", "b", "c", "d", "e" ]\n   a.replace([ "x", "y", "z" ])   #=> ["x", "y", "z"]\n   a                              #=> ["x", "y", "z"]\n
reverse Array.reverse()\nReturns a new array containing +self+'s elements in reverse order.\n\n   [ "a", "b", "c" ].reverse   #=> ["c", "b", "a"]\n   [ 1 ].reverse               #=> [1]\n
reverse! Array.reverse!()\nReverses +self+ in place.\n\n   a = [ "a", "b", "c" ]\n   a.reverse!       #=> ["c", "b", "a"]\n   a                #=> ["c", "b", "a"]\n
reverse_each Array.reverse_each()\nSame as `Array#each`, but traverses +self+ in reverse\norder.\n\n   a = [ "a", "b", "c" ]\n   a.reverse_each {|x| print x, " " }\n\nproduces:\n\n   c b a\n
rindex Array.rindex(...)\nReturns the index of the last object in +self+\n`==` to <i>obj</i>. If a block is given instead of an\nargument, returns first object for which <em>block</em> is\ntrue, starting from the last object.\nReturns `nil` if no match is found.\nSee also `Array#index`.\n\nIf neither block nor argument is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "b", "b", "c" ]\n   a.rindex("b")        #=> 3\n   a.rindex("z")        #=> nil\n   a.rindex{|x|x=="b"}  #=> 3\n
rotate Array.rotate(...)\nReturns new array by rotating +self+, whose first element is the\nelement at +cnt+ in +self+.  If +cnt+ is negative then it rotates\nin counter direction.\n\n   a = [ "a", "b", "c", "d" ]\n   a.rotate         #=> ["b", "c", "d", "a"]\n   a                #=> ["a", "b", "c", "d"]\n   a.rotate(2)      #=> ["c", "d", "a", "b"]\n   a.rotate(-3)     #=> ["b", "c", "d", "a"]\n
rotate! Array.rotate!(...)\nRotates +self+ in place so that the element at +cnt+ comes first,\nand returns +self+.  If +cnt+ is negative then it rotates in\ncounter direction.\n\n   a = [ "a", "b", "c", "d" ]\n   a.rotate!        #=> ["b", "c", "d", "a"]\n   a                #=> ["b", "c", "d", "a"]\n   a.rotate!(2)     #=> ["d", "a", "b", "c"]\n   a.rotate!(-3)    #=> ["a", "b", "c", "d"]\n
sample Array.sample(...)\nChoose a random element or +n+ random elements from the array. The elements\nare chosen by using random and unique indices into the array in order to\nensure that an element doesn't repeat itself unless the array already\ncontained duplicate elements. If the array is empty the first form returns\n`nil` and the second form returns an empty array.\n
select Array.select()\nInvokes the block passing in successive elements from +self+,\nreturning an array containing those elements for which the block\nreturns a true value (equivalent to `Enumerable#select`).\n\nIf no block is given, an enumerator is returned instead.\n\n   a = %w{ a b c d e f }\n   a.select {|v| v =~ /[aeiou]/}   #=> ["a", "e"]\n
select! Array.select!()\nInvokes the block passing in successive elements from\n+self+, deleting elements for which the block returns a\nfalse value. It returns +self+ if changes were made,\notherwise it returns `nil`.\nSee also `Array#keep_if`\n\nIf no block is given, an enumerator is returned instead.\n
shift Array.shift(...)\nReturns the first element of +self+ and removes it (shifting all\nother elements down by one). Returns `nil` if the array\nis empty.\n\nIf a number _n_ is given, returns an array of the first n elements\n(or less) just like `array.slice!(0, n)` does.\n\n   args = [ "-m", "-q", "filename" ]\n   args.shift     #=> "-m"\n   args           #=> ["-q", "filename"]\n\n   args = [ "-m", "-q", "filename" ]\n   args.shift(2)  #=> ["-m", "-q"]\n   args           #=> ["filename"]\n
shuffle Array.shuffle()\nReturns a new array with elements of this array shuffled.\n\n   a = [ 1, 2, 3 ]           #=> [1, 2, 3]\n   a.shuffle                 #=> [2, 3, 1]\n
shuffle! Array.shuffle!()\nShuffles elements in +self+ in place.\n
size Array.size()\n\n
slice Array.slice(...)\nElement Reference---Returns the element at _index_,\nor returns a subarray starting at _start_ and\ncontinuing for _length_ elements, or returns a subarray\nspecified by _range_.\nNegative indices count backward from the end of the\narray (-1 is the last element). Returns +nil+ if the index\n(or starting index) are out of range.\n\n   a = [ "a", "b", "c", "d", "e" ]\n   a[2] +  a[0] + a[1]    #=> "cab"\n   a[6]                   #=> nil\n   a[1, 2]                #=> [ "b", "c" ]\n   a[1..3]                #=> [ "b", "c", "d" ]\n   a[4..7]                #=> [ "e" ]\n   a[6..10]               #=> nil\n   a[-3, 3]               #=> [ "c", "d", "e" ]\n special cases\n   a[5]                   #=> nil\n   a[5, 1]                #=> []\n   a[5..10]               #=> []\n
slice! Array.slice!(...)\nDeletes the element(s) given by an index (optionally with a length)\nor by a range. Returns the deleted object (or objects), or\n`nil` if the index is out of range.\n\n   a = [ "a", "b", "c" ]\n   a.slice!(1)     #=> "b"\n   a               #=> ["a", "c"]\n   a.slice!(-1)    #=> "c"\n   a               #=> ["a"]\n   a.slice!(100)   #=> nil\n   a               #=> ["a"]\n
sort Array.sort()\nReturns a new array created by sorting +self+. Comparisons for\nthe sort will be done using the `<=>` operator or using\nan optional code block. The block implements a comparison between\n<i>a</i> and <i>b</i>, returning -1, 0, or +1. See also\n`Enumerable#sort_by`.\n\n   a = [ "d", "a", "e", "c", "b" ]\n   a.sort                    #=> ["a", "b", "c", "d", "e"]\n   a.sort {|x,y| y <=> x }   #=> ["e", "d", "c", "b", "a"]\n
sort! Array.sort!()\nSorts +self+. Comparisons for\nthe sort will be done using the `<=>` operator or using\nan optional code block. The block implements a comparison between\n<i>a</i> and <i>b</i>, returning -1, 0, or +1. See also\n`Enumerable#sort_by`.\n\n   a = [ "d", "a", "e", "c", "b" ]\n   a.sort                    #=> ["a", "b", "c", "d", "e"]\n   a.sort {|x,y| y <=> x }   #=> ["e", "d", "c", "b", "a"]\n
sort_by! Array.sort_by!()\nSorts +self+ in place using a set of keys generated by mapping the\nvalues in +self+ through the given block.\n\nIf no block is given, an enumerator is returned instead.\n
take Array.take(p1)\nReturns first n elements from <i>ary</i>.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.take(3)             #=> [1, 2, 3]\n
take_while Array.take_while()\nPasses elements to the block until the block returns +nil+ or +false+,\nthen stops iterating and returns an array of all prior elements.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.take_while {|i| i < 3 }   #=> [1, 2]\n
to_a Array.to_a()\nReturns +self+. If called on a subclass of Array, converts\nthe receiver to an Array object.\n
to_ary Array.to_ary()\nReturns +self+.\n
to_s Array.to_s()\n\n
transpose Array.transpose()\nAssumes that +self+ is an array of arrays and transposes the\nrows and columns.\n\n   a = [[1,2], [3,4], [5,6]]\n   a.transpose   #=> [[1, 3, 5], [2, 4, 6]]\n
uniq Array.uniq()\nReturns a new array by removing duplicate values in +self+.\n\n   a = [ "a", "a", "b", "b", "c" ]\n   a.uniq   #=> ["a", "b", "c"]\n   c = [ "a:def", "a:xyz", "b:abc", "b:xyz", "c:jkl" ]\n   c.uniq {|s| s[/^\w+/]}  #=> [ "a:def", "b:abc", "c:jkl" ]\n
uniq! Array.uniq!()\nRemoves duplicate elements from +self+.\nReturns `nil` if no changes are made (that is, no\nduplicates are found).\n\n   a = [ "a", "a", "b", "b", "c" ]\n   a.uniq!   #=> ["a", "b", "c"]\n   b = [ "a", "b", "c" ]\n   b.uniq!   #=> nil\n   c = [ "a:def", "a:xyz", "b:abc", "b:xyz", "c:jkl" ]\n   c.uniq! {|s| s[/^\w+/]}  #=> [ "a:def", "b:abc", "c:jkl" ]\n
unshift Array.unshift(...)\nPrepends objects to the front of +self+,\nmoving other elements upwards.\n\n   a = [ "b", "c", "d" ]\n   a.unshift("a")   #=> ["a", "b", "c", "d"]\n   a.unshift(1, 2)  #=> [ 1, 2, "a", "b", "c", "d"]\n
values_at Array.values_at(...)\nReturns an array containing the elements in\n+self+ corresponding to the given selector(s). The selectors\nmay be either integer indices or ranges.\nSee also `Array#select`.\n\n   a = %w{ a b c d e f }\n   a.values_at(1, 3, 5)\n   a.values_at(1, 3, 5, 7)\n   a.values_at(-1, -3, -5, -7)\n   a.values_at(1..3, 2...5)\n
zip Array.zip(...)\nConverts any arguments to arrays, then merges elements of\n+self+ with corresponding elements from each argument. This\ngenerates a sequence of `self.size` <em>n</em>-element\narrays, where <em>n</em> is one more that the count of arguments. If\nthe size of any argument is less than `enumObj.size`,\n`nil` values are supplied. If a block is given, it is\ninvoked for each output array, otherwise an array of arrays is\nreturned.\n\n   a = [ 4, 5, 6 ]\n   b = [ 7, 8, 9 ]\n   [1,2,3].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n   [1,2].zip(a,b)         #=> [[1, 4, 7], [2, 5, 8]]\n   a.zip([1,2],[8])       #=> [[4,1,8], [5,2,nil], [6,nil,nil]]\n
abs Bignum.abs()\nReturns the absolute value of <i>big</i>.\n\n   -1234567890987654321.abs   #=> 1234567890987654321\n
coerce Bignum.coerce(p1)\nMISSING: documentation\n
div Bignum.div(p1)\n\nPerforms integer division: returns integer value.\n
divmod Bignum.divmod(p1)\nSee `Numeric#divmod`.\n
eql? Bignum.eql?(p1)\nReturns `true` only if <i>obj</i> is a\n`Bignum` with the same value as <i>big</i>. Contrast this\nwith `Bignum#==`, which performs type conversions.\n\n   68719476736.eql?(68719476736.0)   #=> false\n
even? Bignum.even?()\nReturns `true` if <i>big</i> is an even number.\n
fdiv Bignum.fdiv(p1)\nReturns the floating point result of dividing <i>big</i> by\n<i>numeric</i>.\n\n   -1234567890987654321.fdiv(13731)      #=> -89910996357705.5\n   -1234567890987654321.fdiv(13731.24)   #=> -89909424858035.7\n
hash Bignum.hash()\nCompute a hash based on the value of _big_.\n
magnitude Bignum.magnitude()\nReturns the absolute value of <i>big</i>.\n\n   -1234567890987654321.abs   #=> 1234567890987654321\n
modulo Bignum.modulo(p1)\nReturns big modulo other. See Numeric.divmod for more\ninformation.\n
odd? Bignum.odd?()\nReturns `true` if <i>big</i> is an odd number.\n
remainder Bignum.remainder(p1)\nReturns the remainder after dividing <i>big</i> by <i>numeric</i>.\n\n   -1234567890987654321.remainder(13731)      #=> -6966\n   -1234567890987654321.remainder(13731.24)   #=> -9906.22531493148\n
size Bignum.size()\nReturns the number of bytes in the machine representation of\n<i>big</i>.\n\n   (256**10 - 1).size   #=> 12\n   (256**20 - 1).size   #=> 20\n   (256**40 - 1).size   #=> 40\n
to_f Bignum.to_f()\nConverts <i>big</i> to a `Float`. If <i>big</i> doesn't\nfit in a `Float`, the result is infinity.\n
to_s Bignum.to_s(...)\nReturns a string containing the representation of <i>big</i> radix\n<i>base</i> (2 through 36).\n\n   12345654321.to_s         #=> "12345654321"\n   12345654321.to_s(2)      #=> "1011011111110110111011110000110001"\n   12345654321.to_s(8)      #=> "133766736061"\n   12345654321.to_s(16)     #=> "2dfdbbc31"\n   78546939656932.to_s(36)  #=> "rubyrules"\n
new BasicObject.new(...)\nNot documented\n
__send__ BasicObject.__send__(...)\nInvokes the method identified by _symbol_, passing it any\narguments specified. You can use `__send__` if the name\n+send+ clashes with an existing method in _obj_.\n\n   class Klass\n     def hello(*args)\n       "Hello " + args.join(' ')\n     end\n   end\n   k = Klass.new\n   k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"\n
equal? BasicObject.equal?(p1)\nEquality---At the `Object` level, `==` returns\n`true` only if <i>obj</i> and <i>other</i> are the\nsame object. Typically, this method is overridden in descendant\nclasses to provide class-specific meaning.\n\nUnlike `==`, the `equal?` method should never be\noverridden by subclasses: it is used to determine object identity\n(that is, `a.equal?(b)` iff `a` is the same\nobject as `b`).\n\nThe `eql?` method returns `true` if\n<i>obj</i> and <i>anObject</i> have the same value. Used by\n`Hash` to test members for equality.  For objects of\nclass `Object`, `eql?` is synonymous with\n`==`. Subclasses normally continue this tradition, but\nthere are exceptions. `Numeric` types, for example,\nperform type conversion across `==`, but not across\n`eql?`, so:\n\n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false\n
instance_eval BasicObject.instance_eval(...)\nEvaluates a string containing Ruby source code, or the given block,\nwithin the context of the receiver (_obj_). In order to set the\ncontext, the variable +self+ is set to _obj_ while\nthe code is executing, giving the code access to _obj_'s\ninstance variables. In the version of `instance_eval`\nthat takes a +String+, the optional second and third\nparameters supply a filename and starting line number that are used\nwhen reporting compilation errors.\n\n   class KlassWithSecret\n     def initialize\n       @secret = 99\n     end\n   end\n   k = KlassWithSecret.new\n   k.instance_eval { @secret }   #=> 99\n
instance_exec BasicObject.instance_exec(...)\nExecutes the given block within the context of the receiver\n(_obj_). In order to set the context, the variable +self+ is set\nto _obj_ while the code is executing, giving the code access to\n_obj_'s instance variables.  Arguments are passed as block parameters.\n\n   class KlassWithSecret\n     def initialize\n       @secret = 99\n     end\n   end\n   k = KlassWithSecret.new\n   k.instance_exec(5) {|x| @secret+x }   #=> 104\n
method_missing BasicObject.method_missing(...)\nInvoked by Ruby when <i>obj</i> is sent a message it cannot handle.\n<i>symbol</i> is the symbol for the method called, and <i>args</i>\nare any arguments that were passed to it. By default, the interpreter\nraises an error when this method is called. However, it is possible\nto override the method to provide more dynamic behavior.\nIf it is decided that a particular method should not be handled, then\n<i>super</i> should be called, so that ancestors can pick up the\nmissing method.\nThe example below creates\na class `Roman`, which responds to methods with names\nconsisting of roman numerals, returning the corresponding integer\nvalues.\n\n   class Roman\n     def romanToInt(str)\n ...\n     end\n     def method_missing(methId)\n       str = methId.id2name\n       romanToInt(str)\n     end\n   end\n\n   r = Roman.new\n   r.iv      #=> 4\n   r.xxiii   #=> 23\n   r.mm      #=> 2000\n
singleton_method_added BasicObject.singleton_method_added(p1)\nInvoked as a callback whenever a singleton method is added to the\nreceiver.\n\n   module Chatty\n     def Chatty.singleton_method_added(id)\n       puts "Adding #{id.id2name}"\n     end\n     def self.one()     end\n     def two()          end\n     def Chatty.three() end\n   end\n\n<em>produces:</em>\n\n   Adding singleton_method_added\n   Adding one\n   Adding three\n
singleton_method_removed BasicObject.singleton_method_removed(p1)\nInvoked as a callback whenever a singleton method is removed from\nthe receiver.\n\n   module Chatty\n     def Chatty.singleton_method_removed(id)\n       puts "Removing #{id.id2name}"\n     end\n     def self.one()     end\n     def two()          end\n     def Chatty.three() end\n     class << self\n       remove_method :three\n       remove_method :one\n     end\n   end\n\n<em>produces:</em>\n\n   Removing three\n   Removing one\n
singleton_method_undefined BasicObject.singleton_method_undefined(p1)\nInvoked as a callback whenever a singleton method is undefined in\nthe receiver.\n\n   module Chatty\n     def Chatty.singleton_method_undefined(id)\n       puts "Undefining #{id.id2name}"\n     end\n     def Chatty.one()   end\n     class << self\n        undef_method(:one)\n     end\n   end\n\n<em>produces:</em>\n\n   Undefining one\n
__id__ Object.__id__()\nReturns an integer identifier for <i>obj</i>. The same number will\nbe returned on all calls to `id` for a given object, and\nno two active objects will share an id.\n`Object#object_id` is a different concept from the\n`:name` notation, which returns the symbol id of\n`name`. Replaces the deprecated `Object#id`.\n
class Object.class()\nReturns the class of <i>obj</i>. This method must always be\ncalled with an explicit receiver, as `class` is also a\nreserved word in Ruby.\n\n   1.class      #=> Fixnum\n   self.class   #=> Object\n
clone Object.clone()\nProduces a shallow copy of <i>obj</i>---the instance variables of\n<i>obj</i> are copied, but not the objects they reference. Copies\nthe frozen and tainted state of <i>obj</i>. See also the discussion\nunder `Object#dup`.\n\n   class Klass\n      attr_accessor :str\n   end\n   s1 = Klass.new      #=> #<Klass:0x401b3a38>\n   s1.str = "Hello"    #=> "Hello"\n   s2 = s1.clone       #=> #<Klass:0x401b3998 @str="Hello">\n   s2.str[1,4] = "i"   #=> "i"\n   s1.inspect          #=> "#<Klass:0x401b3a38 @str=\"Hi\">"\n   s2.inspect          #=> "#<Klass:0x401b3998 @str=\"Hi\">"\n\nThis method may have class-specific behavior.  If so, that\nbehavior will be documented under the #+initialize_copy+ method of\nthe class.\n
define_singleton_method Object.define_singleton_method(...)\nDefines a singleton method in the receiver. The _method_\nparameter can be a +Proc+, a +Method+ or an +UnboundMethod+ object.\nIf a block is specified, it is used as the method body.\n\n   class A\n     class << self\n       def class_name\n         to_s\n       end\n     end\n   end\n   A.define_singleton_method(:who_am_i) do\n     "I am: #{class_name}"\n   end\n   A.who_am_i   # ==> "I am: A"\n\n   guy = "Bob"\n   guy.define_singleton_method(:hello) { "#{self}: Hello there!" }\n   guy.hello    #=>  "Bob: Hello there!"\n
display Object.display(...)\nPrints <i>obj</i> on the given port (default `$>`).\nEquivalent to:\n\n   def display(port=$>)\n     port.write self\n   end\n\nFor example:\n\n   1.display\n   "cat".display\n   [ 4, 5, 6 ].display\n   puts\n\n<em>produces:</em>\n\n   1cat456\n
dup Object.dup()\nProduces a shallow copy of <i>obj</i>---the instance variables of\n<i>obj</i> are copied, but not the objects they reference.\n`dup` copies the tainted state of <i>obj</i>. See also\nthe discussion under `Object#clone`. In general,\n`clone` and `dup` may have different semantics\nin descendant classes. While `clone` is used to duplicate\nan object, including its internal state, `dup` typically\nuses the class of the descendant object to create the new instance.\n\nThis method may have class-specific behavior.  If so, that\nbehavior will be documented under the #+initialize_copy+ method of\nthe class.\n
enum_for Object.enum_for(...)\nReturns Enumerator.new(self, method, *args).\n\ne.g.:\n\n   str = "xyz"\n\n   enum = str.enum_for(:each_byte)\n   a = enum.map {|b| '%02x' % b } #=> ["78", "79", "7a"]\n protects an array from being modified\n   a = [1, 2, 3]\n   some_method(a.to_enum)\n
eql? Object.eql?(p1)\nEquality---At the `Object` level, `==` returns\n`true` only if <i>obj</i> and <i>other</i> are the\nsame object. Typically, this method is overridden in descendant\nclasses to provide class-specific meaning.\n\nUnlike `==`, the `equal?` method should never be\noverridden by subclasses: it is used to determine object identity\n(that is, `a.equal?(b)` iff `a` is the same\nobject as `b`).\n\nThe `eql?` method returns `true` if\n<i>obj</i> and <i>anObject</i> have the same value. Used by\n`Hash` to test members for equality.  For objects of\nclass `Object`, `eql?` is synonymous with\n`==`. Subclasses normally continue this tradition, but\nthere are exceptions. `Numeric` types, for example,\nperform type conversion across `==`, but not across\n`eql?`, so:\n\n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false\n
extend Object.extend(...)\nAdds to _obj_ the instance methods from each module given as a\nparameter.\n\n   module Mod\n     def hello\n       "Hello from Mod.\\n"\n     end\n   end\n\n   class Klass\n     def hello\n       "Hello from Klass.\\n"\n     end\n   end\n\n   k = Klass.new\n   k.hello         #=> "Hello from Klass.\\n"\n   k.extend(Mod)   #=> #<Klass:0x401b3bc8>\n   k.hello         #=> "Hello from Mod.\\n"\n
freeze Object.freeze()\nPrevents further modifications to <i>obj</i>. A\n`RuntimeError` will be raised if modification is attempted.\nThere is no way to unfreeze a frozen object. See also\n`Object#frozen?`.\n\nThis method returns self.\n\n   a = [ "a", "b", "c" ]\n   a.freeze\n   a << "z"\n\n<em>produces:</em>\n\n   prog.rb:3:in `<<': can't modify frozen array (RuntimeError)\n    from prog.rb:3\n
frozen? Object.frozen?()\nReturns the freeze status of <i>obj</i>.\n\n   a = [ "a", "b", "c" ]\n   a.freeze    #=> ["a", "b", "c"]\n   a.frozen?   #=> true\n
inspect Object.inspect()\nReturns a string containing a human-readable representation of\n<i>obj</i>. If not overridden and no instance variables, uses the\n`to_s` method to generate the string.\n<i>obj</i>.  If not overridden, uses the `to_s` method to\ngenerate the string.\n\n   [ 1, 2, 3..4, 'five' ].inspect   #=> "[1, 2, 3..4, \"five\"]"\n   Time.new.inspect                 #=> "2008-03-08 19:43:39 +0900"\n
instance_of? Object.instance_of?(p1)\nReturns `true` if <i>obj</i> is an instance of the given\nclass. See also `Object#kind_of?`.\n
instance_variable_defined? Object.instance_variable_defined?(p1)\nReturns `true` if the given instance variable is\ndefined in <i>obj</i>.\n\n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_defined?(:@a)    #=> true\n   fred.instance_variable_defined?("@b")   #=> true\n   fred.instance_variable_defined?("@c")   #=> false\n
instance_variable_get Object.instance_variable_get(p1)\nReturns the value of the given instance variable, or nil if the\ninstance variable is not set. The `@` part of the\nvariable name should be included for regular instance\nvariables. Throws a `NameError` exception if the\nsupplied symbol is not valid as an instance variable name.\n\n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_get(:@a)    #=> "cat"\n   fred.instance_variable_get("@b")   #=> 99\n
instance_variable_set Object.instance_variable_set(p1, p2)\nSets the instance variable names by <i>symbol</i> to\n<i>object</i>, thereby frustrating the efforts of the class's\nauthor to attempt to provide proper encapsulation. The variable\ndid not have to exist prior to this call.\n\n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_set(:@a, 'dog')   #=> "dog"\n   fred.instance_variable_set(:@c, 'cat')   #=> "cat"\n   fred.inspect                             #=> "#<Fred:0x401b3da8 @a=\"dog\",\n   @b=99, @c=\"cat\">"\n
instance_variables Object.instance_variables()\nReturns an array of instance variable names for the receiver. Note\nthat simply defining an accessor does not create the corresponding\ninstance variable.\n\n   class Fred\n     attr_accessor :a1\n     def initialize\n       @iv = 3\n     end\n   end\n   Fred.new.instance_variables   #=> [:@iv]\n
is_a? Object.is_a?(p1)\nReturns `true` if <i>class</i> is the class of\n<i>obj</i>, or if <i>class</i> is one of the superclasses of\n<i>obj</i> or modules included in <i>obj</i>.\n\n   module M;    end\n   class A\n     include M\n   end\n   class B < A; end\n   class C < B; end\n   b = B.new\n   b.instance_of? A   #=> false\n   b.instance_of? B   #=> true\n   b.instance_of? C   #=> false\n   b.instance_of? M   #=> false\n   b.kind_of? A       #=> true\n   b.kind_of? B       #=> true\n   b.kind_of? C       #=> false\n   b.kind_of? M       #=> true\n
kind_of? Object.kind_of?(p1)\nReturns `true` if <i>class</i> is the class of\n<i>obj</i>, or if <i>class</i> is one of the superclasses of\n<i>obj</i> or modules included in <i>obj</i>.\n\n   module M;    end\n   class A\n     include M\n   end\n   class B < A; end\n   class C < B; end\n   b = B.new\n   b.instance_of? A   #=> false\n   b.instance_of? B   #=> true\n   b.instance_of? C   #=> false\n   b.instance_of? M   #=> false\n   b.kind_of? A       #=> true\n   b.kind_of? B       #=> true\n   b.kind_of? C       #=> false\n   b.kind_of? M       #=> true\n
method Object.method(p1)\nLooks up the named method as a receiver in <i>obj</i>, returning a\n`Method` object (or raising `NameError`). The\n`Method` object acts as a closure in <i>obj</i>'s object\ninstance, so instance variables and the value of `self`\nremain available.\n\n   class Demo\n     def initialize(n)\n       @iv = n\n     end\n     def hello()\n       "Hello, @iv = #{@iv}"\n     end\n   end\n\n   k = Demo.new(99)\n   m = k.method(:hello)\n   m.call   #=> "Hello, @iv = 99"\n\n   l = Demo.new('Fred')\n   m = l.method("hello")\n   m.call   #=> "Hello, @iv = Fred"\n
nil? Object.nil?()\ncall_seq:\n  nil.nil?               -> true\n  <anything_else>.nil?   -> false\n\nOnly the object <i>nil</i> responds `true` to `nil?`.\n
object_id Object.object_id()\nReturns an integer identifier for <i>obj</i>. The same number will\nbe returned on all calls to `id` for a given object, and\nno two active objects will share an id.\n`Object#object_id` is a different concept from the\n`:name` notation, which returns the symbol id of\n`name`. Replaces the deprecated `Object#id`.\n
public_method Object.public_method(p1)\nSimilar to _method_, searches public method only.\n
public_send Object.public_send(...)\nInvokes the method identified by _symbol_, passing it any\narguments specified. Unlike send, public_send calls public\nmethods only.\n\n   1.public_send(:puts, "hello")  # causes NoMethodError\n
remove_instance_variable Object.remove_instance_variable(p1)\nRemoves the named instance variable from <i>obj</i>, returning that\nvariable's value.\n\n   class Dummy\n     attr_reader :var\n     def initialize\n       @var = 99\n     end\n     def remove\n       remove_instance_variable(:@var)\n     end\n   end\n   d = Dummy.new\n   d.var      #=> 99\n   d.remove   #=> 99\n   d.var      #=> nil\n
respond_to? Object.respond_to?(...)\nReturns +true+ if _obj_ responds to the given\nmethod. Private methods are included in the search only if the\noptional second parameter evaluates to +true+.\n\nIf the method is not implemented,\nas Process.fork on Windows, File.lchmod on GNU/Linux, etc.,\nfalse is returned.\n\nIf the method is not defined, `respond_to_missing?`\nmethod is called and the result is returned.\n
respond_to_missing? Object.respond_to_missing?(p1, p2)\nHook method to return whether the _obj_ can respond to _id_ method\nor not.\n\nSee #respond_to?.\n
send Object.send(...)\nInvokes the method identified by _symbol_, passing it any\narguments specified. You can use `__send__` if the name\n+send+ clashes with an existing method in _obj_.\n\n   class Klass\n     def hello(*args)\n       "Hello " + args.join(' ')\n     end\n   end\n   k = Klass.new\n   k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"\n
singleton_class Object.singleton_class()\nReturns the singleton class of <i>obj</i>.  This method creates\na new singleton class if <i>obj</i> does not have it.\n\nIf <i>obj</i> is `nil`, `true`, or\n`false`, it returns NilClass, TrueClass, or FalseClass,\nrespectively.\nIf <i>obj</i> is a Fixnum or a Symbol, it raises a TypeError.\n\n   Object.new.singleton_class  #=> #<Class:#<Object:0xb7ce1e24>>\n   String.singleton_class      #=> #<Class:String>\n   nil.singleton_class         #=> NilClass\n
singleton_methods Object.singleton_methods(...)\nReturns an array of the names of singleton methods for <i>obj</i>.\nIf the optional <i>all</i> parameter is true, the list will include\nmethods in modules included in <i>obj</i>.\nOnly public and protected singleton methods are returned.\n\n   module Other\n     def three() end\n   end\n\n   class Single\n     def Single.four() end\n   end\n\n   a = Single.new\n\n   def a.one()\n   end\n\n   class << a\n     include Other\n     def two()\n     end\n   end\n\n   Single.singleton_methods    #=> [:four]\n   a.singleton_methods(false)  #=> [:two, :one]\n   a.singleton_methods         #=> [:two, :one, :three]\n
taint Object.taint()\nMarks <i>obj</i> as tainted---if the `$SAFE` level is\nset appropriately, many method calls which might alter the running\nprograms environment will refuse to accept tainted strings.\n
tainted? Object.tainted?()\nReturns `true` if the object is tainted.\n
tap Object.tap()\nYields `x` to the block, and then returns `x`.\nThe primary purpose of this method is to "tap into" a method chain,\nin order to perform operations on intermediate results within the chain.\n\n    (1..10)                .tap {|x| puts "original: #{x.inspect}"}\n      .to_a                .tap {|x| puts "array: #{x.inspect}"}\n      .select {|x| x%2==0} .tap {|x| puts "evens: #{x.inspect}"}\n      .map { |x| x*x }     .tap {|x| puts "squares: #{x.inspect}"}\n
to_enum Object.to_enum(...)\nReturns Enumerator.new(self, method, *args).\n\ne.g.:\n\n   str = "xyz"\n\n   enum = str.enum_for(:each_byte)\n   a = enum.map {|b| '%02x' % b } #=> ["78", "79", "7a"]\n protects an array from being modified\n   a = [1, 2, 3]\n   some_method(a.to_enum)\n
to_s Object.to_s()\nReturns a string representing <i>obj</i>. The default\n`to_s` prints the object's class and an encoding of the\nobject id. As a special case, the top-level object that is the\ninitial execution context of Ruby programs returns ``main.''\n
trust Object.trust()\nRemoves the untrusted mark from <i>obj</i>.\n
untaint Object.untaint()\nRemoves the taint from <i>obj</i>.\n
untrust Object.untrust()\nMarks <i>obj</i> as untrusted.\n
untrusted? Object.untrusted?()\nReturns `true` if the object is untrusted.\n
constants Module.constants(...)\nReturns an array of the names of all constants defined in the\nsystem. This list includes the names of all modules and classes.\n\n   p Module.constants.sort[1..5]\n\n<em>produces:</em>\n\n   ["ARGV", "ArgumentError", "Array", "Bignum", "Binding"]\n
nesting Module.nesting()\nReturns the list of +Modules+ nested at the point of call.\n\n   module M1\n     module M2\n       $a = Module.nesting\n     end\n   end\n   $a           #=> [M1::M2, M1]\n   $a[0].name   #=> "M1::M2"\n
new Module.new()\nCreates a new anonymous module. If a block is given, it is passed\nthe module object, and the block is evaluated in the context of this\nmodule using `module_eval`.\n\n   Fred = Module.new do\n     def meth1\n       "hello"\n     end\n     def meth2\n       "bye"\n     end\n   end\n   a = "my string"\n   a.extend(Fred)   #=> "my string"\n   a.meth1          #=> "hello"\n   a.meth2          #=> "bye"\n
alias_method Module.alias_method(p1, p2)\nMakes <i>new_name</i> a new copy of the method <i>old_name</i>. This can\nbe used to retain access to methods that are overridden.\n\n   module Mod\n     alias_method :orig_exit, :exit\n     def exit(code=0)\n       puts "Exiting with code #{code}"\n       orig_exit(code)\n     end\n   end\n   include Mod\n   exit(99)\n\n<em>produces:</em>\n\n   Exiting with code 99\n
ancestors Module.ancestors()\nReturns a list of modules included in <i>mod</i> (including\n<i>mod</i> itself).\n\n   module Mod\n     include Math\n     include Comparable\n   end\n\n   Mod.ancestors    #=> [Mod, Comparable, Math]\n   Math.ancestors   #=> [Math]\n
append_features Module.append_features(p1)\nWhen this module is included in another, Ruby calls\n`append_features` in this module, passing it the\nreceiving module in _mod_. Ruby's default implementation is\nto add the constants, methods, and module variables of this module\nto _mod_ if this module has not already been added to\n_mod_ or one of its ancestors. See also `Module#include`.\n
attr_accessor Module.attr_accessor(...)\nDefines a named attribute for this module, where the name is\n<i>symbol.</i>`id2name`, creating an instance variable\n(`@name`) and a corresponding access method to read it.\nAlso creates a method called `name=` to set the attribute.\n\n   module Mod\n     attr_accessor(:one, :two)\n   end\n   Mod.instance_methods.sort   #=> [:one, :one=, :two, :two=]\n
attr_reader Module.attr_reader(...)\nCreates instance variables and corresponding methods that return the\nvalue of each instance variable. Equivalent to calling\n```attr`<i>:name</i>'' on each name in turn.\n
attr_writer Module.attr_writer(...)\nCreates an accessor method to allow assignment to the attribute\n<i>aSymbol</i>`.id2name`.\n
autoload Module.autoload(p1, p2)\nRegisters _filename_ to be loaded (using `Kernel::require`)\nthe first time that _module_ (which may be a `String` or\na symbol) is accessed in the namespace of _mod_.\n\n   module A\n   end\n   A.autoload(:B, "b")\n   A::B.doit            # autoloads "b"\n
autoload? Module.autoload?(p1)\nReturns _filename_ to be loaded if _name_ is registered as\n+autoload+ in the namespace of _mod_.\n\n   module A\n   end\n   A.autoload(:B, "b")\n   A.autoload?(:B)            #=> "b"\n
class_eval Module.class_eval(...)\nEvaluates the string or block in the context of _mod_. This can\nbe used to add methods to a class. `module_eval` returns\nthe result of evaluating its argument. The optional _filename_\nand _lineno_ parameters set the text for error messages.\n\n   class Thing\n   end\n   a = %q{def hello() "Hello there!" end}\n   Thing.module_eval(a)\n   puts Thing.new.hello()\n   Thing.module_eval("invalid code", "dummy", 123)\n\n<em>produces:</em>\n\n   Hello there!\n   dummy:123:in `module_eval': undefined local variable\n       or method `code' for Thing:Class\n
class_exec Module.class_exec(...)\nEvaluates the given block in the context of the class/module.\nThe method defined in the block will belong to the receiver.\n\n   class Thing\n   end\n   Thing.class_exec{\n     def hello() "Hello there!" end\n   }\n   puts Thing.new.hello()\n\n<em>produces:</em>\n\n   Hello there!\n
class_variable_defined? Module.class_variable_defined?(p1)\nReturns `true` if the given class variable is defined\nin <i>obj</i>.\n\n   class Fred\n     @@foo = 99\n   end\n   Fred.class_variable_defined?(:@@foo)    #=> true\n   Fred.class_variable_defined?(:@@bar)    #=> false\n
class_variable_get Module.class_variable_get(p1)\nReturns the value of the given class variable (or throws a\n`NameError` exception). The `@@` part of the\nvariable name should be included for regular class variables\n\n   class Fred\n     @@foo = 99\n   end\n   Fred.class_variable_get(:@@foo)     #=> 99\n
class_variable_set Module.class_variable_set(p1, p2)\nSets the class variable names by <i>symbol</i> to\n<i>object</i>.\n\n   class Fred\n     @@foo = 99\n     def foo\n       @@foo\n     end\n   end\n   Fred.class_variable_set(:@@foo, 101)     #=> 101\n   Fred.new.foo                             #=> 101\n
class_variables Module.class_variables()\nReturns an array of the names of class variables in <i>mod</i>.\n\n   class One\n     @@var1 = 1\n   end\n   class Two < One\n     @@var2 = 2\n   end\n   One.class_variables   #=> [:@@var1]\n   Two.class_variables   #=> [:@@var2]\n
const_defined? Module.const_defined?(...)\nReturns `true` if a constant with the given name is\ndefined by <i>mod</i>, or its ancestors if +inherit+ is not false.\n\n   Math.const_defined? "PI"   #=> true\n   IO.const_defined? "SYNC"   #=> true\n   IO.const_defined? "SYNC", false   #=> false\n
const_get Module.const_get(...)\nReturns the value of the named constant in <i>mod</i>.\n\n   Math.const_get(:PI)   #=> 3.14159265358979\n\nIf the constant is not defined or is defined by the ancestors and\n+inherit+ is false, +NameError+ will be raised.\n
const_missing Module.const_missing(p1)\nInvoked when a reference is made to an undefined constant in\n<i>mod</i>. It is passed a symbol for the undefined constant, and\nreturns a value to be used for that constant. The\nfollowing code is a (very bad) example: if reference is made to\nan undefined constant, it attempts to load a file whose name is\nthe lowercase version of the constant (thus class `Fred` is\nassumed to be in file `fred.rb`). If found, it returns the\nvalue of the loaded class. It therefore implements a perverse\nkind of autoload facility.\n\n  def Object.const_missing(name)\n    @looked_for ||= {}\n    str_name = name.to_s\n    raise "Class not found: #{name}" if @looked_for[str_name]\n    @looked_for[str_name] = 1\n    file = str_name.downcase\n    require file\n    klass = const_get(name)\n    return klass if klass\n    raise "Class not found: #{name}"\n  end\n
const_set Module.const_set(p1, p2)\nSets the named constant to the given object, returning that object.\nCreates a new constant if no constant with the given name previously\nexisted.\n\n   Math.const_set("HIGH_SCHOOL_PI", 22.0/7.0)   #=> 3.14285714285714\n   Math::HIGH_SCHOOL_PI - Math::PI              #=> 0.00126448926734968\n
constants Module.constants(...)\nReturns an array of the names of the constants accessible in\n<i>mod</i>. This includes the names of constants in any included\nmodules (example at start of section), unless the <i>all</i>\nparameter is set to `false`.\n\n  IO.constants.include?(:SYNC)        #=> true\n  IO.constants(false).include?(:SYNC) #=> false\n\nAlso see `Module::const_defined?`.\n
define_method Module.define_method(...)\nDefines an instance method in the receiver. The _method_\nparameter can be a +Proc+, a +Method+ or an +UnboundMethod+ object.\nIf a block is specified, it is used as the method body. This block\nis evaluated using `instance_eval`, a point that is\ntricky to demonstrate because `define_method` is private.\n(This is why we resort to the +send+ hack in this example.)\n\n   class A\n     def fred\n       puts "In Fred"\n     end\n     def create_method(name, &block)\n       self.class.send(:define_method, name, &block)\n     end\n     define_method(:wilma) { puts "Charge it!" }\n   end\n   class B < A\n     define_method(:barney, instance_method(:fred))\n   end\n   a = B.new\n   a.barney\n   a.wilma\n   a.create_method(:betty) { p self }\n   a.betty\n\n<em>produces:</em>\n\n   In Fred\n   Charge it!\n<B:0x401b39e8>\n
extend_object Module.extend_object(p1)\nExtends the specified object by adding this module's constants and\nmethods (which are added as singleton methods). This is the callback\nmethod used by `Object#extend`.\n\n   module Picky\n     def Picky.extend_object(o)\n       if String === o\n         puts "Can't add Picky to a String"\n       else\n         puts "Picky added to #{o.class}"\n         super\n       end\n     end\n   end\n   (s = Array.new).extend Picky  # Call Object.extend\n   (s = "quick brown fox").extend Picky\n\n<em>produces:</em>\n\n   Picky added to Array\n   Can't add Picky to a String\n
extended Module.extended(p1)\nNot documented\n
freeze Module.freeze()\nPrevents further modifications to <i>mod</i>.\n\nThis method returns self.\n
include Module.include(...)\nInvokes `Module.append_features` on each parameter in reverse order.\n
include? Module.include?(p1)\nReturns `true` if <i>module</i> is included in\n<i>mod</i> or one of <i>mod</i>'s ancestors.\n\n   module A\n   end\n   class B\n     include A\n   end\n   class C < B\n   end\n   B.include?(A)   #=> true\n   C.include?(A)   #=> true\n   A.include?(A)   #=> false\n
included Module.included(p1)\nCallback invoked whenever the receiver is included in another\nmodule or class. This should be used in preference to\n<tt>Module.append_features</tt> if your code wants to perform some\naction when a module is included in another.\n\n       module A\n         def A.included(mod)\n           puts "#{self} included in #{mod}"\n         end\n       end\n       module Enumerable\n         include A\n       end\n
included_modules Module.included_modules()\nReturns the list of modules included in <i>mod</i>.\n\n   module Mixin\n   end\n\n   module Outer\n     include Mixin\n   end\n\n   Mixin.included_modules   #=> []\n   Outer.included_modules   #=> [Mixin]\n
instance_method Module.instance_method(p1)\nReturns an +UnboundMethod+ representing the given\ninstance method in _mod_.\n\n   class Interpreter\n     def do_a() print "there, "; end\n     def do_d() print "Hello ";  end\n     def do_e() print "!\\n";     end\n     def do_v() print "Dave";    end\n     Dispatcher = {\n       "a" => instance_method(:do_a),\n       "d" => instance_method(:do_d),\n       "e" => instance_method(:do_e),\n       "v" => instance_method(:do_v)\n     }\n     def interpret(string)\n       string.each_char {|b| Dispatcher[b].bind(self).call }\n     end\n   end\n\n   interpreter = Interpreter.new\n   interpreter.interpret('dave')\n\n<em>produces:</em>\n\n   Hello there, Dave!\n
instance_methods Module.instance_methods(...)\nReturns an array containing the names of the public and protected instance\nmethods in the receiver. For a module, these are the public and protected\nmethods;\nfor a class, they are the instance (not singleton) methods. With no\nargument, or with an argument that is `false`, the\ninstance methods in <i>mod</i> are returned, otherwise the methods\nin <i>mod</i> and <i>mod</i>'s superclasses are returned.\n\n   module A\n     def method1()  end\n   end\n   class B\n     def method2()  end\n   end\n   class C < B\n     def method3()  end\n   end\n\n   A.instance_methods                #=> [:method1]\n   B.instance_methods(false)         #=> [:method2]\n   C.instance_methods(false)         #=> [:method3]\n   C.instance_methods(true).length   #=> 43\n
method_added Module.method_added(p1)\nNot documented\n
method_defined? Module.method_defined?(p1)\nReturns +true+ if the named method is defined by\n_mod_ (or its included modules and, if _mod_ is a class,\nits ancestors). Public and protected methods are matched.\n\n   module A\n     def method1()  end\n   end\n   class B\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1    #=> true\n   C.method_defined? "method1"   #=> true\n   C.method_defined? "method2"   #=> true\n   C.method_defined? "method3"   #=> true\n   C.method_defined? "method4"   #=> false\n
method_removed Module.method_removed(p1)\nNot documented\n
method_undefined Module.method_undefined(p1)\nNot documented\n
module_eval Module.module_eval(...)\nEvaluates the string or block in the context of _mod_. This can\nbe used to add methods to a class. `module_eval` returns\nthe result of evaluating its argument. The optional _filename_\nand _lineno_ parameters set the text for error messages.\n\n   class Thing\n   end\n   a = %q{def hello() "Hello there!" end}\n   Thing.module_eval(a)\n   puts Thing.new.hello()\n   Thing.module_eval("invalid code", "dummy", 123)\n\n<em>produces:</em>\n\n   Hello there!\n   dummy:123:in `module_eval': undefined local variable\n       or method `code' for Thing:Class\n
module_exec Module.module_exec(...)\nEvaluates the given block in the context of the class/module.\nThe method defined in the block will belong to the receiver.\n\n   class Thing\n   end\n   Thing.class_exec{\n     def hello() "Hello there!" end\n   }\n   puts Thing.new.hello()\n\n<em>produces:</em>\n\n   Hello there!\n
module_function Module.module_function(...)\nCreates module functions for the named methods. These functions may\nbe called with the module as a receiver, and also become available\nas instance methods to classes that mix in the module. Module\nfunctions are copies of the original, and so may be changed\nindependently. The instance-method versions are made private. If\nused with no arguments, subsequently defined methods become module\nfunctions.\n\n   module Mod\n     def one\n       "This is one"\n     end\n     module_function :one\n   end\n   class Cls\n     include Mod\n     def callOne\n       one\n     end\n   end\n   Mod.one     #=> "This is one"\n   c = Cls.new\n   c.callOne   #=> "This is one"\n   module Mod\n     def one\n       "This is the new one"\n     end\n   end\n   Mod.one     #=> "This is one"\n   c.callOne   #=> "This is the new one"\n
name Module.name()\nReturns the name of the module <i>mod</i>.  Returns nil for anonymous modules.\n
private Module.private(...)\nWith no arguments, sets the default visibility for subsequently\ndefined methods to private. With arguments, sets the named methods\nto have private visibility.\n\n   module Mod\n     def a()  end\n     def b()  end\n     private\n     def c()  end\n     private :a\n   end\n   Mod.private_instance_methods   #=> [:a, :c]\n
private_class_method Module.private_class_method(...)\nMakes existing class methods private. Often used to hide the default\nconstructor `new`.\n\n   class SimpleSingleton  # Not thread safe\n     private_class_method :new\n     def SimpleSingleton.create(*args, &block)\n       @me = new(*args, &block) if ! @me\n       @me\n     end\n   end\n
private_instance_methods Module.private_instance_methods(...)\nReturns a list of the private instance methods defined in\n<i>mod</i>. If the optional parameter is not `false`, the\nmethods of any ancestors are included.\n\n   module Mod\n     def method1()  end\n     private :method1\n     def method2()  end\n   end\n   Mod.instance_methods           #=> [:method2]\n   Mod.private_instance_methods   #=> [:method1]\n
private_method_defined? Module.private_method_defined?(p1)\nReturns +true+ if the named private method is defined by\n_ mod_ (or its included modules and, if _mod_ is a class,\nits ancestors).\n\n   module A\n     def method1()  end\n   end\n   class B\n     private\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1            #=> true\n   C.private_method_defined? "method1"   #=> false\n   C.private_method_defined? "method2"   #=> true\n   C.method_defined? "method2"           #=> false\n
protected Module.protected(...)\nWith no arguments, sets the default visibility for subsequently\ndefined methods to protected. With arguments, sets the named methods\nto have protected visibility.\n
protected_instance_methods Module.protected_instance_methods(...)\nReturns a list of the protected instance methods defined in\n<i>mod</i>. If the optional parameter is not `false`, the\nmethods of any ancestors are included.\n
protected_method_defined? Module.protected_method_defined?(p1)\nReturns +true+ if the named protected method is defined\nby _mod_ (or its included modules and, if _mod_ is a\nclass, its ancestors).\n\n   module A\n     def method1()  end\n   end\n   class B\n     protected\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1              #=> true\n   C.protected_method_defined? "method1"   #=> false\n   C.protected_method_defined? "method2"   #=> true\n   C.method_defined? "method2"             #=> true\n
public Module.public(...)\nWith no arguments, sets the default visibility for subsequently\ndefined methods to public. With arguments, sets the named methods to\nhave public visibility.\n
public_class_method Module.public_class_method(...)\nMakes a list of existing class methods public.\n
public_instance_method Module.public_instance_method(p1)\nSimilar to _instance_method_, searches public method only.\n
public_instance_methods Module.public_instance_methods(...)\nReturns a list of the public instance methods defined in <i>mod</i>.\nIf the optional parameter is not `false`, the methods of\nany ancestors are included.\n
public_method_defined? Module.public_method_defined?(p1)\nReturns +true+ if the named public method is defined by\n_mod_ (or its included modules and, if _mod_ is a class,\nits ancestors).\n\n   module A\n     def method1()  end\n   end\n   class B\n     protected\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1           #=> true\n   C.public_method_defined? "method1"   #=> true\n   C.public_method_defined? "method2"   #=> false\n   C.method_defined? "method2"          #=> true\n
remove_class_variable Module.remove_class_variable(p1)\nRemoves the definition of the <i>sym</i>, returning that\nconstant's value.\n\n   class Dummy\n     @@var = 99\n     puts @@var\n     remove_class_variable(:@@var)\n     p(defined? @@var)\n   end\n\n<em>produces:</em>\n\n   99\n   nil\n
remove_const Module.remove_const(p1)\nRemoves the definition of the given constant, returning that\nconstant's value. Predefined classes and singleton objects (such as\n<i>true</i>) cannot be removed.\n
remove_method Module.remove_method(...)\nRemoves the method identified by _symbol_ from the current\nclass. For an example, see `Module.undef_method`.\n
to_s Module.to_s()\nReturn a string representing this module or class. For basic\nclasses and modules, this is the name. For singletons, we\nshow information on the thing we're attached to as well.\n
undef_method Module.undef_method(...)\nPrevents the current class from responding to calls to the named\nmethod. Contrast this with `remove_method`, which deletes\nthe method from the particular class; Ruby will still search\nsuperclasses and mixed-in modules for a possible receiver.\n\n   class Parent\n     def hello\n       puts "In parent"\n     end\n   end\n   class Child < Parent\n     def hello\n       puts "In child"\n     end\n   end\n\n\n   c = Child.new\n   c.hello\n\n\n   class Child\n     remove_method :hello  # remove from child, still in parent\n   end\n   c.hello\n\n\n   class Child\n     undef_method :hello   # prevent any calls to 'hello'\n   end\n   c.hello\n\n<em>produces:</em>\n\n   In child\n   In parent\n   prog.rb:23: undefined method `hello' for #<Child:0x401b3bb4> (NoMethodError)\n
new Class.new(...)\nCreates a new anonymous (unnamed) class with the given superclass\n(or `Object` if no parameter is given). You can give a\nclass a name by assigning the class object to a constant.\n
allocate Class.allocate()\nAllocates space for a new object of <i>class</i>'s class and does not\ncall initialize on the new instance. The returned object must be an\ninstance of <i>class</i>.\n\n    klass = Class.new do\n      def initialize(*args)\n        @initialized = true\n      end\n\n      def initialized?\n        @initialized || false\n      end\n    end\n\n    klass.allocate.initialized? #=> false\n
inherited Class.inherited(p1)\nCallback invoked whenever a subclass of the current class is created.\n\nExample:\n\n   class Foo\n      def self.inherited(subclass)\n         puts "New subclass: #{subclass}"\n      end\n   end\n\n   class Bar < Foo\n   end\n\n   class Baz < Bar\n   end\n\nproduces:\n\n   New subclass: Bar\n   New subclass: Baz\n
new Class.new(...)\nCalls `allocate` to create a new object of\n<i>class</i>'s class, then invokes that object's\n`initialize` method, passing it <i>args</i>.\nThis is the method that ends up getting called whenever\nan object is constructed using .new.\n
superclass Class.superclass()\nReturns the superclass of <i>class</i>, or `nil`.\n\n   File.superclass          #=> IO\n   IO.superclass            #=> Object\n   Object.superclass        #=> BasicObject\n   class Foo; end\n   class Bar < Foo; end\n   Bar.superclass           #=> Foo\n\nreturns nil when the given class hasn't a parent class:\n\n   BasicObject.superclass   #=> nil\n
polar Complex.polar(...)\nReturns a complex object which denotes the given polar form.\n
rect Complex.rect(...)\nReturns a complex object which denotes the given rectangular form.\n
rectangular Complex.rectangular(...)\nReturns a complex object which denotes the given rectangular form.\n
abs Complex.abs()\nReturns the absolute part of its polar form.\n
abs2 Complex.abs2()\nReturns square of the absolute value.\n
angle Complex.angle()\nReturns the angle part of its polar form.\n
arg Complex.arg()\nReturns the angle part of its polar form.\n
conj Complex.conj()\nReturns the complex conjugate.\n
conjugate Complex.conjugate()\nReturns the complex conjugate.\n
denominator Complex.denominator()\nReturns the denominator (lcm of both denominator, real and imag).\n\nSee numerator.\n
fdiv Complex.fdiv(p1)\nPerforms division as each part is a float, never returns a float.\n\nFor example:\n\n    Complex(11,22).fdiv(3)  #=> (3.6666666666666665+7.333333333333333i)\n
imag Complex.imag()\nReturns the imaginary part.\n
imaginary Complex.imaginary()\nReturns the imaginary part.\n
inspect Complex.inspect()\nReturns the value as a string for inspection.\n
magnitude Complex.magnitude()\nReturns the absolute part of its polar form.\n
numerator Complex.numerator()\nReturns the numerator.\n\nFor example:\n\n       1   2       3+4i  <-  numerator\n       - + -i  ->  ----\n       2   3        6    <-  denominator\n\n   c = Complex('1/2+2/3i')  #=> ((1/2)+(2/3)*i)\n   n = c.numerator          #=> (3+4i)\n   d = c.denominator        #=> 6\n   n / d                    #=> ((1/2)+(2/3)*i)\n   Complex(Rational(n.real, d), Rational(n.imag, d))\n=> ((1/2)+(2/3)*i)\nSee denominator.\n
phase Complex.phase()\nReturns the angle part of its polar form.\n
polar Complex.polar()\nReturns an array; [cmp.abs, cmp.arg].\n
quo Complex.quo(p1)\nPerforms division.\n\nFor example:\n\n    Complex(10.0) / 3  #=> (3.3333333333333335+(0/1)*i)\n    Complex(10)   / 3  #=> ((10/3)+(0/1)*i)  # not (3+0i)\n
rationalize Complex.rationalize(...)\nReturns the value as a rational if possible.  An optional argument\neps is always ignored.\n
real Complex.real()\nReturns the real part.\n
real? Complex.real?()\nReturns false.\n
rect Complex.rect()\nReturns an array; [cmp.real, cmp.imag].\n
rectangular Complex.rectangular()\nReturns an array; [cmp.real, cmp.imag].\n
to_f Complex.to_f()\nReturns the value as a float if possible.\n
to_i Complex.to_i()\nReturns the value as an integer if possible.\n
to_r Complex.to_r()\nReturns the value as a rational if possible.\n
to_s Complex.to_s()\nReturns the value as a string.\n
inspect NilClass.inspect()\nAlways returns the string "nil".\n
nil? NilClass.nil?()\ncall_seq:\n  nil.nil?               -> true\n\nOnly the object <i>nil</i> responds `true` to `nil?`.\n
rationalize NilClass.rationalize(...)\nReturns zero as a rational.  An optional argument eps is always\nignored.\n
to_a NilClass.to_a()\nAlways returns an empty array.\n\n   nil.to_a   #=> []\n
to_c NilClass.to_c()\nReturns zero as a complex.\n
to_f NilClass.to_f()\nAlways returns zero.\n\n   nil.to_f   #=> 0.0\n
to_i NilClass.to_i()\nAlways returns zero.\n\n   nil.to_i   #=> 0\n
to_r NilClass.to_r()\nReturns zero as a rational.\n
to_s NilClass.to_s()\nAlways returns the empty string.\n
abs Numeric.abs()\nReturns the absolute value of <i>num</i>.\n\n   12.abs         #=> 12\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n
abs2 Numeric.abs2()\nReturns square of self.\n
angle Numeric.angle()\nReturns 0 if the value is positive, pi otherwise.\n
arg Numeric.arg()\nReturns 0 if the value is positive, pi otherwise.\n
ceil Numeric.ceil()\nReturns the smallest `Integer` greater than or equal to\n<i>num</i>. Class `Numeric` achieves this by converting\nitself to a `Float` then invoking\n`Float#ceil`.\n\n   1.ceil        #=> 1\n   1.2.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-1.0).ceil   #=> -1\n
coerce Numeric.coerce(p1)\nIf <i>aNumeric</i> is the same type as <i>num</i>, returns an array\ncontaining <i>aNumeric</i> and <i>num</i>. Otherwise, returns an\narray with both <i>aNumeric</i> and <i>num</i> represented as\n`Float` objects. This coercion mechanism is used by\nRuby to handle mixed-type numeric operations: it is intended to\nfind a compatible common type between the two operands of the operator.\n\n   1.coerce(2.5)   #=> [2.5, 1.0]\n   1.2.coerce(3)   #=> [3.0, 1.2]\n   1.coerce(2)     #=> [2, 1]\n
conj Numeric.conj()\nReturns self.\n
conjugate Numeric.conjugate()\nReturns self.\n
denominator Numeric.denominator()\nReturns the denominator (always positive).\n
div Numeric.div(p1)\nUses `/` to perform division, then converts the result to\nan integer. `numeric` does not define the `/`\noperator; this is left to subclasses.\n\nEquivalent to\n<i>num</i>.`divmod(`<i>aNumeric</i>`)[0]`.\n\nSee `Numeric#divmod`.\n
divmod Numeric.divmod(p1)\nReturns an array containing the quotient and modulus obtained by\ndividing <i>num</i> by <i>numeric</i>. If `q, r =\nx.divmod(y)`, then\n\n    q = floor(x/y)\n    x = q*y+r\n\nThe quotient is rounded toward -infinity, as shown in the following table:\n\n   a    |  b  |  a.divmod(b)  |   a/b   | a.modulo(b) | a.remainder(b)\n  ------+-----+---------------+---------+-------------+---------------\n   13   |  4  |   3,    1     |   3     |    1        |     1\n  ------+-----+---------------+---------+-------------+---------------\n   13   | -4  |  -4,   -3     |  -4     |   -3        |     1\n  ------+-----+---------------+---------+-------------+---------------\n  -13   |  4  |  -4,    3     |  -4     |    3        |    -1\n  ------+-----+---------------+---------+-------------+---------------\n  -13   | -4  |   3,   -1     |   3     |   -1        |    -1\n  ------+-----+---------------+---------+-------------+---------------\n   11.5 |  4  |   2,    3.5   |   2.875 |    3.5      |     3.5\n  ------+-----+---------------+---------+-------------+---------------\n   11.5 | -4  |  -3,   -0.5   |  -2.875 |   -0.5      |     3.5\n  ------+-----+---------------+---------+-------------+---------------\n  -11.5 |  4  |  -3,    0.5   |  -2.875 |    0.5      |    -3.5\n  ------+-----+---------------+---------+-------------+---------------\n  -11.5 | -4  |   2,   -3.5   |   2.875 |   -3.5      |    -3.5\n\n\nExamples\n\n   11.divmod(3)         #=> [3, 2]\n   11.divmod(-3)        #=> [-4, -1]\n   11.divmod(3.5)       #=> [3, 0.5]\n   (-11).divmod(3.5)    #=> [-4, 3.0]\n   (11.5).divmod(3.5)   #=> [3, 1.0]\n
eql? Numeric.eql?(p1)\nReturns `true` if <i>num</i> and <i>numeric</i> are the\nsame type and have equal values.\n\n   1 == 1.0          #=> true\n   1.eql?(1.0)       #=> false\n   (1.0).eql?(1.0)   #=> true\n
fdiv Numeric.fdiv(p1)\nReturns float division.\n
floor Numeric.floor()\nReturns the largest integer less than or equal to <i>num</i>.\n`Numeric` implements this by converting <i>anInteger</i>\nto a `Float` and invoking `Float#floor`.\n\n   1.floor      #=> 1\n   (-1).floor   #=> -1\n
i Numeric.i()\nReturns the corresponding imaginary number.\nNot available for complex numbers.\n
imag Numeric.imag()\nReturns zero.\n
imaginary Numeric.imaginary()\nReturns zero.\n
integer? Numeric.integer?()\nReturns `true` if <i>num</i> is an `Integer`\n(including `Fixnum` and `Bignum`).\n
magnitude Numeric.magnitude()\nReturns the absolute value of <i>num</i>.\n\n   12.abs         #=> 12\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n
modulo Numeric.modulo(p1)\n   x.modulo(y) means x-y*(x/y).floor\n\nEquivalent to\n<i>num</i>.`divmod(`<i>aNumeric</i>`)[1]`.\n\nSee `Numeric#divmod`.\n
nonzero? Numeric.nonzero?()\nReturns +self+ if <i>num</i> is not zero, `nil`\notherwise. This behavior is useful when chaining comparisons:\n\n   a = %w( z Bb bB bb BB a aA Aa AA A )\n   b = a.sort {|a,b| (a.downcase <=> b.downcase).nonzero? || a <=> b }\n   b   #=> ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]\n
numerator Numeric.numerator()\nReturns the numerator.\n
phase Numeric.phase()\nReturns 0 if the value is positive, pi otherwise.\n
polar Numeric.polar()\nReturns an array; [num.abs, num.arg].\n
quo Numeric.quo(p1)\nReturns most exact division (rational for integers, float for floats).\n
real Numeric.real()\nReturns self.\n
real? Numeric.real?()\nReturns `true` if <i>num</i> is a `Real`\n(i.e. non `Complex`).\n
rect Numeric.rect()\nReturns an array; [num, 0].\n
rectangular Numeric.rectangular()\nReturns an array; [num, 0].\n
remainder Numeric.remainder(p1)\n   x.remainder(y) means x-y*(x/y).truncate\n\nSee `Numeric#divmod`.\n
round Numeric.round(...)\nRounds <i>num</i> to a given precision in decimal digits (default 0 digits).\nPrecision may be negative.  Returns a floating point number when ndigits\nis more than zero.  `Numeric` implements this by converting itself\nto a `Float` and invoking `Float#round`.\n
singleton_method_added Numeric.singleton_method_added(p1)\nTrap attempts to add methods to `Numeric` objects. Always\nraises a `TypeError`\n
step Numeric.step(...)\nInvokes <em>block</em> with the sequence of numbers starting at\n<i>num</i>, incremented by <i>step</i> (default 1) on each\ncall. The loop finishes when the value to be passed to the block\nis greater than <i>limit</i> (if <i>step</i> is positive) or less\nthan <i>limit</i> (if <i>step</i> is negative). If all the\narguments are integers, the loop operates using an integer\ncounter. If any of the arguments are floating point numbers, all\nare converted to floats, and the loop is executed <i>floor(n +\nn*epsilon)+ 1</i> times, where <i>n = (limit -\nnum)/step</i>. Otherwise, the loop starts at <i>num</i>, uses\neither the `<` or `>` operator to compare\nthe counter against <i>limit</i>, and increments itself using the\n`+` operator.\n\nIf no block is given, an enumerator is returned instead.\n\n   1.step(10, 2) { |i| print i, " " }\n   Math::E.step(Math::PI, 0.2) { |f| print f, " " }\n\n<em>produces:</em>\n\n   1 3 5 7 9\n   2.71828182845905 2.91828182845905 3.11828182845905\n
to_c Numeric.to_c()\nReturns the value as a complex.\n
to_int Numeric.to_int()\nInvokes the child class's `to_i` method to convert\n<i>num</i> to an integer.\n
truncate Numeric.truncate()\nReturns <i>num</i> truncated to an integer. `Numeric`\nimplements this by converting its value to a float and invoking\n`Float#truncate`.\n
zero? Numeric.zero?()\nReturns `true` if <i>num</i> has a zero value.\n
new String.new(...)\nReturns a new string object containing a copy of <i>str</i>.\n
try_convert String.try_convert(p1)\nTry to convert <i>obj</i> into a String, using to_str method.\nReturns converted string or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   String.try_convert("str")     #=> "str"\n   String.try_convert(/re/)      #=> nil\n
ascii_only? String.ascii_only?()\nReturns true for a string which has only ASCII characters.\n\n  "abc".force_encoding("UTF-8").ascii_only?          #=> true\n  "abc\u{6666}".force_encoding("UTF-8").ascii_only?  #=> false\n
bytes String.bytes()\n   str.each_byte {|fixnum| block }    -> str\n   str.each_byte                      -> an_enumerator\n\nPasses each byte in <i>str</i> to the given block, or returns\nan enumerator if no block is given.\n\n   "hello".each_byte {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   104 101 108 108 111\n
bytesize String.bytesize()\nReturns the length of <i>str</i> in bytes.\n
capitalize String.capitalize()\nReturns a copy of <i>str</i> with the first character converted to uppercase\nand the remainder to lowercase.\nNote: case conversion is effective only in ASCII region.\n\n   "hello".capitalize    #=> "Hello"\n   "HELLO".capitalize    #=> "Hello"\n   "123ABC".capitalize   #=> "123abc"\n
capitalize! String.capitalize!()\nModifies <i>str</i> by converting the first character to uppercase and the\nremainder to lowercase. Returns `nil` if no changes are made.\nNote: case conversion is effective only in ASCII region.\n\n   a = "hello"\n   a.capitalize!   #=> "Hello"\n   a               #=> "Hello"\n   a.capitalize!   #=> nil\n
casecmp String.casecmp(p1)\nCase-insensitive version of `String#<=>`.\n\n   "abcdef".casecmp("abcde")     #=> 1\n   "aBcDeF".casecmp("abcdef")    #=> 0\n   "abcdef".casecmp("abcdefg")   #=> -1\n   "abcdef".casecmp("ABCDEF")    #=> 0\n
center String.center(...)\nIf <i>integer</i> is greater than the length of <i>str</i>, returns a new\n`String` of length <i>integer</i> with <i>str</i> centered and\npadded with <i>padstr</i>; otherwise, returns <i>str</i>.\n\n   "hello".center(4)         #=> "hello"\n   "hello".center(20)        #=> "       hello        "\n   "hello".center(20, '123') #=> "1231231hello12312312"\n
chars String.chars()\n   str.each_char {|cstr| block }    -> str\n   str.each_char                    -> an_enumerator\n\nPasses each character in <i>str</i> to the given block, or returns\nan enumerator if no block is given.\n\n   "hello".each_char {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   h e l l o\n
chomp String.chomp(...)\nReturns a new `String` with the given record separator removed\nfrom the end of <i>str</i> (if present). If `$/` has not been\nchanged from the default Ruby record separator, then `chomp` also\nremoves carriage return characters (that is it will remove `\\n`,\n`\r`, and `\r\\n`).\n\n   "hello".chomp            #=> "hello"\n   "hello\\n".chomp          #=> "hello"\n   "hello\r\\n".chomp        #=> "hello"\n   "hello\\n\r".chomp        #=> "hello\\n"\n   "hello\r".chomp          #=> "hello"\n   "hello \\n there".chomp   #=> "hello \\n there"\n   "hello".chomp("llo")     #=> "he"\n
chomp! String.chomp!(...)\nModifies <i>str</i> in place as described for `String#chomp`,\nreturning <i>str</i>, or `nil` if no modifications were made.\n
chop String.chop()\nReturns a new `String` with the last character removed.  If the\nstring ends with `\r\\n`, both characters are removed. Applying\n`chop` to an empty string returns an empty\nstring. `String#chomp` is often a safer alternative, as it leaves\nthe string unchanged if it doesn't end in a record separator.\n\n   "string\r\\n".chop   #=> "string"\n   "string\\n\r".chop   #=> "string\\n"\n   "string\\n".chop     #=> "string"\n   "string".chop       #=> "strin"\n   "x".chop.chop       #=> ""\n
chop! String.chop!()\nProcesses <i>str</i> as for `String#chop`, returning <i>str</i>,\nor `nil` if <i>str</i> is the empty string.  See also\n`String#chomp!`.\n
chr String.chr()\nReturns a one-character string at the beginning of the string.\n\n   a = "abcde"\n   a.chr    #=> "a"\n
clear String.clear()\nMakes string empty.\n\n   a = "abcde"\n   a.clear    #=> ""\n
codepoints String.codepoints()\n   str.each_codepoint {|integer| block }    -> str\n   str.each_codepoint                       -> an_enumerator\n\nPasses the `Integer` ordinal of each character in <i>str</i>,\nalso known as a <i>codepoint</i> when applied to Unicode strings to the\ngiven block.\n\nIf no block is given, an enumerator is returned instead.\n\n   "hello\u0639".each_codepoint {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   104 101 108 108 111 1593\n
concat String.concat(p1)\nAppend---Concatenates the given object to <i>str</i>. If the object is a\n`Integer`, it is considered as a codepoint, and is converted\nto a character before concatenation.\n\n   a = "hello "\n   a << "world"   #=> "hello world"\n   a.concat(33)   #=> "hello world!"\n
count String.count(...)\nEach <i>other_str</i> parameter defines a set of characters to count.  The\nintersection of these sets defines the characters to count in\n<i>str</i>. Any <i>other_str</i> that starts with a caret (^) is\nnegated. The sequence c1--c2 means all characters between c1 and c2.\n\n   a = "hello world"\n   a.count "lo"            #=> 5\n   a.count "lo", "o"       #=> 2\n   a.count "hello", "^l"   #=> 4\n   a.count "ej-m"          #=> 4\n
crypt String.crypt(p1)\nApplies a one-way cryptographic hash to <i>str</i> by invoking the standard\nlibrary function `crypt`. The argument is the salt string, which\nshould be two characters long, each character drawn from\n`[a-zA-Z0-9./]`.\n
delete String.delete(...)\nReturns a copy of <i>str</i> with all characters in the intersection of its\narguments deleted. Uses the same rules for building the set of characters as\n`String#count`.\n\n   "hello".delete "l","lo"        #=> "heo"\n   "hello".delete "lo"            #=> "he"\n   "hello".delete "aeiou", "^e"   #=> "hell"\n   "hello".delete "ej-m"          #=> "ho"\n
delete! String.delete!(...)\nPerforms a `delete` operation in place, returning <i>str</i>, or\n`nil` if <i>str</i> was not modified.\n
downcase String.downcase()\nReturns a copy of <i>str</i> with all uppercase letters replaced with their\nlowercase counterparts. The operation is locale insensitive---only\ncharacters ``A'' to ``Z'' are affected.\nNote: case replacement is effective only in ASCII region.\n\n   "hEllO".downcase   #=> "hello"\n
downcase! String.downcase!()\nDowncases the contents of <i>str</i>, returning `nil` if no\nchanges were made.\nNote: case replacement is effective only in ASCII region.\n
dump String.dump()\nProduces a version of <i>str</i> with all nonprinting characters replaced by\n`\\nnn` notation and all special characters escaped.\n
each_byte String.each_byte()\n   str.each_byte {|fixnum| block }    -> str\n   str.each_byte                      -> an_enumerator\n\nPasses each byte in <i>str</i> to the given block, or returns\nan enumerator if no block is given.\n\n   "hello".each_byte {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   104 101 108 108 111\n
each_char String.each_char()\n   str.each_char {|cstr| block }    -> str\n   str.each_char                    -> an_enumerator\n\nPasses each character in <i>str</i> to the given block, or returns\nan enumerator if no block is given.\n\n   "hello".each_char {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   h e l l o\n
each_codepoint String.each_codepoint()\n   str.each_codepoint {|integer| block }    -> str\n   str.each_codepoint                       -> an_enumerator\n\nPasses the `Integer` ordinal of each character in <i>str</i>,\nalso known as a <i>codepoint</i> when applied to Unicode strings to the\ngiven block.\n\nIf no block is given, an enumerator is returned instead.\n\n   "hello\u0639".each_codepoint {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   104 101 108 108 111 1593\n
each_line String.each_line(...)\n   str.lines(separator=$/) {|substr| block }       -> str\n   str.lines(separator=$/)                         -> an_enumerator\n\nSplits <i>str</i> using the supplied parameter as the record separator\n(`$/` by default), passing each substring in turn to the supplied\nblock. If a zero-length record separator is supplied, the string is split\ninto paragraphs delimited by multiple successive newlines.\n\nIf no block is given, an enumerator is returned instead.\n\n   print "Example one\\n"\n   "hello\\nworld".each_line {|s| p s}\n   print "Example two\\n"\n   "hello\\nworld".each_line('l') {|s| p s}\n   print "Example three\\n"\n   "hello\\n\\n\\nworld".each_line('') {|s| p s}\n\n<em>produces:</em>\n\n   Example one\n   "hello\\n"\n   "world"\n   Example two\n   "hel"\n   "l"\n   "o\\nworl"\n   "d"\n   Example three\n   "hello\\n\\n\\n"\n   "world"\n
empty? String.empty?()\nReturns `true` if <i>str</i> has a length of zero.\n\n   "hello".empty?   #=> false\n   "".empty?        #=> true\n
encode String.encode(...)\nThe first form returns a copy of <i>str</i> transcoded\nto encoding +encoding+.\nThe second form returns a copy of <i>str</i> transcoded\nfrom src_encoding to dst_encoding.\nThe last form returns a copy of <i>str</i> transcoded to\n`Encoding.default_internal`.\nBy default, the first and second form raise\nEncoding::UndefinedConversionError for characters that are\nundefined in the destination encoding, and\nEncoding::InvalidByteSequenceError for invalid byte sequences\nin the source encoding. The last form by default does not raise\nexceptions but uses replacement strings.\nThe `options` Hash gives details for conversion.\n\n=== options\nThe hash `options` can have the following keys:\n:invalid ::\n  If the value is `:replace`, `#encode` replaces\n  invalid byte sequences in `str` with the replacement character.\n  The default is to raise the exception\n:undef ::\n  If the value is `:replace`, `#encode` replaces\n  characters which are undefined in the destination encoding with\n  the replacement character.\n:replace ::\n  Sets the replacement string to the value. The default replacement\n  string is "\uFFFD" for Unicode encoding forms, and "?" otherwise.\n:fallback ::\n  Sets the replacement string by the hash for undefined character.\n  Its key is a such undefined character encoded in source encoding\n  of current transcoder. Its value can be any encoding until it\n  can be converted into the destination encoding of the transcoder.\n:xml ::\n  The value must be `:text` or `:attr`.\n  If the value is `:text` `#encode` replaces\n  undefined characters with their (upper-case hexadecimal) numeric\n  character references. '&', '<', and '>' are converted to "&amp;",\n  "&lt;", and "&gt;", respectively.\n  If the value is `:attr`, `#encode` also quotes\n  the replacement result (using '"'), and replaces '"' with "&quot;".\n:cr_newline ::\n  Replaces LF ("\\n") with CR ("\r") if value is true.\n:crlf_newline ::\n  Replaces LF ("\\n") with CRLF ("\r\\n") if value is true.\n:universal_newline ::\n  Replaces CRLF ("\r\\n") and CR ("\r") with LF ("\\n") if value is true.\n
encode! String.encode!(...)\nThe first form transcodes the contents of <i>str</i> from\nstr.encoding to +encoding+.\nThe second form transcodes the contents of <i>str</i> from\nsrc_encoding to dst_encoding.\nThe options Hash gives details for conversion. See String#encode\nfor details.\nReturns the string even if no changes were made.\n
encoding String.encoding()\nReturns the Encoding object that represents the encoding of obj.\n
end_with? String.end_with?(...)\nReturns true if <i>str</i> ends with a suffix given.\n
eql? String.eql?(p1)\nTwo strings are equal if they have the same length and content.\n
force_encoding String.force_encoding(p1)\nChanges the encoding to +encoding+ and returns self.\n
getbyte String.getbyte(p1)\nreturns the <i>index</i>th byte as an integer.\n
gsub String.gsub(...)\nReturns a copy of <i>str</i> with the <em>all</em> occurrences of\n<i>pattern</i> substituted for the second argument. The <i>pattern</i> is\ntypically a `Regexp`; if given as a `String`, any\nregular expression metacharacters it contains will be interpreted\nliterally, e.g. `'\\\d'` will match a backlash followed by 'd',\ninstead of a digit.\n\nIf <i>replacement</i> is a `String` it will be substituted for\nthe matched text. It may contain back-references to the pattern's capture\ngroups of the form `\\\d`, where <i>d</i> is a group number, or\n`\\\k<n>`, where <i>n</i> is a group name. If it is a\ndouble-quoted string, both back-references must be preceded by an\nadditional backslash. However, within <i>replacement</i> the special match\nvariables, such as `&$`, will not refer to the current match.\n\nIf the second argument is a `Hash`, and the matched text is one\nof its keys, the corresponding value is the replacement string.\n\nIn the block form, the current match string is passed in as a parameter,\nand variables such as `$1`, `$2`, `$``,\n`$&`, and `$'` will be set appropriately. The value\nreturned by the block will be substituted for the match on each call.\n\nThe result inherits any tainting in the original string or any supplied\nreplacement string.\n\nWhen neither a block nor a second argument is supplied, an\n`Enumerator` is returned.\n\n   "hello".gsub(/[aeiou]/, '*')                  #=> "h*ll*"\n   "hello".gsub(/([aeiou])/, '<\1>')             #=> "h<e>ll<o>"\n   "hello".gsub(/./) {|s| s.ord.to_s + ' '}      #=> "104 101 108 108 111 "\n   "hello".gsub(/(?<foo>[aeiou])/, '{\k<foo>}')  #=> "h{e}ll{o}"\n   'hello'.gsub(/[eo]/, 'e' => 3, 'o' => '*')    #=> "h3ll*"\n
gsub! String.gsub!(...)\nPerforms the substitutions of `String#gsub` in place, returning\n<i>str</i>, or `nil` if no substitutions were performed.\nIf no block and no <i>replacement</i> is given, an enumerator is returned\ninstead.\n
hash String.hash()\nReturn a hash based on the string's length and content.\n
hex String.hex()\nTreats leading characters from <i>str</i> as a string of hexadecimal digits\n(with an optional sign and an optional `0x`) and returns the\ncorresponding number. Zero is returned on error.\n\n   "0x0a".hex     #=> 10\n   "-1234".hex    #=> -4660\n   "0".hex        #=> 0\n   "wombat".hex   #=> 0\n
include? String.include?(p1)\nReturns `true` if <i>str</i> contains the given string or\ncharacter.\n\n   "hello".include? "lo"   #=> true\n   "hello".include? "ol"   #=> false\n   "hello".include? ?h     #=> true\n
index String.index(...)\nReturns the index of the first occurrence of the given <i>substring</i> or\npattern (<i>regexp</i>) in <i>str</i>. Returns `nil` if not\nfound. If the second parameter is present, it specifies the position in the\nstring to begin the search.\n\n   "hello".index('e')             #=> 1\n   "hello".index('lo')            #=> 3\n   "hello".index('a')             #=> nil\n   "hello".index(?e)              #=> 1\n   "hello".index(/[aeiou]/, -3)   #=> 4\n
initialize_copy String.initialize_copy(p1)\nReplaces the contents and taintedness of <i>str</i> with the corresponding\nvalues in <i>other_str</i>.\n\n   s = "hello"         #=> "hello"\n   s.replace "world"   #=> "world"\n
insert String.insert(p1, p2)\nInserts <i>other_str</i> before the character at the given\n<i>index</i>, modifying <i>str</i>. Negative indices count from the\nend of the string, and insert <em>after</em> the given character.\nThe intent is insert <i>aString</i> so that it starts at the given\n<i>index</i>.\n\n   "abcd".insert(0, 'X')    #=> "Xabcd"\n   "abcd".insert(3, 'X')    #=> "abcXd"\n   "abcd".insert(4, 'X')    #=> "abcdX"\n   "abcd".insert(-3, 'X')   #=> "abXcd"\n   "abcd".insert(-1, 'X')   #=> "abcdX"\n
inspect String.inspect()\nReturns a printable version of _str_, surrounded by quote marks,\nwith special characters escaped.\n\n   str = "hello"\n   str[3] = "\b"\n   str.inspect       #=> "\"hel\\bo\""\n
intern String.intern()\nReturns the `Symbol` corresponding to <i>str</i>, creating the\nsymbol if it did not previously exist. See `Symbol#id2name`.\n\n   "Koala".intern         #=> :Koala\n   s = 'cat'.to_sym       #=> :cat\n   s == :cat              #=> true\n   s = '@cat'.to_sym      #=> :@cat\n   s == :@cat             #=> true\n\nThis can also be used to create symbols that cannot be represented using the\n`:xxx` notation.\n\n   'cat and dog'.to_sym   #=> :"cat and dog"\n
length String.length()\nReturns the character length of <i>str</i>.\n
lines String.lines(...)\n   str.lines(separator=$/) {|substr| block }       -> str\n   str.lines(separator=$/)                         -> an_enumerator\n\nSplits <i>str</i> using the supplied parameter as the record separator\n(`$/` by default), passing each substring in turn to the supplied\nblock. If a zero-length record separator is supplied, the string is split\ninto paragraphs delimited by multiple successive newlines.\n\nIf no block is given, an enumerator is returned instead.\n\n   print "Example one\\n"\n   "hello\\nworld".each_line {|s| p s}\n   print "Example two\\n"\n   "hello\\nworld".each_line('l') {|s| p s}\n   print "Example three\\n"\n   "hello\\n\\n\\nworld".each_line('') {|s| p s}\n\n<em>produces:</em>\n\n   Example one\n   "hello\\n"\n   "world"\n   Example two\n   "hel"\n   "l"\n   "o\\nworl"\n   "d"\n   Example three\n   "hello\\n\\n\\n"\n   "world"\n
ljust String.ljust(...)\nIf <i>integer</i> is greater than the length of <i>str</i>, returns a new\n`String` of length <i>integer</i> with <i>str</i> left justified\nand padded with <i>padstr</i>; otherwise, returns <i>str</i>.\n\n   "hello".ljust(4)            #=> "hello"\n   "hello".ljust(20)           #=> "hello               "\n   "hello".ljust(20, '1234')   #=> "hello123412341234123"\n
lstrip String.lstrip()\nReturns a copy of <i>str</i> with leading whitespace removed. See also\n`String#rstrip` and `String#strip`.\n\n   "  hello  ".lstrip   #=> "hello  "\n   "hello".lstrip       #=> "hello"\n
lstrip! String.lstrip!()\nRemoves leading whitespace from <i>str</i>, returning `nil` if no\nchange was made. See also `String#rstrip!` and\n`String#strip!`.\n\n   "  hello  ".lstrip   #=> "hello  "\n   "hello".lstrip!      #=> nil\n
match String.match(...)\nConverts <i>pattern</i> to a `Regexp` (if it isn't already one),\nthen invokes its `match` method on <i>str</i>.  If the second\nparameter is present, it specifies the position in the string to begin the\nsearch.\nIf the second parameter is present, it specifies the position in the string\nto begin the search.\n\n   'hello'.match('(.)\1')      #=> #<MatchData "ll" 1:"l">\n   'hello'.match('(.)\1')[0]   #=> "ll"\n   'hello'.match(/(.)\1/)[0]   #=> "ll"\n   'hello'.match('xx')         #=> nil\n\nIf a block is given, invoke the block with MatchData if match succeed, so\nthat you can write\n\n   str.match(pat) {|m| ...}\n\ninstead of\n\n   if m = str.match(pat)\n     ...\n   end\n\nThe return value is a value from block execution in this case.\n
next String.next()\nReturns the successor to <i>str</i>. The successor is calculated by\nincrementing characters starting from the rightmost alphanumeric (or\nthe rightmost character if there are no alphanumerics) in the\nstring. Incrementing a digit always results in another digit, and\nincrementing a letter results in another letter of the same case.\nIncrementing nonalphanumerics uses the underlying character set's\ncollating sequence.\n\nIf the increment generates a ``carry,'' the character to the left of\nit is incremented. This process repeats until there is no carry,\nadding an additional character if necessary.\n\n   "abcd".succ        #=> "abce"\n   "THX1138".succ     #=> "THX1139"\n   "<<koala>>".succ   #=> "<<koalb>>"\n   "1999zzz".succ     #=> "2000aaa"\n   "ZZZ9999".succ     #=> "AAAA0000"\n   "***".succ         #=> "**+"\n
next! String.next!()\nEquivalent to `String#succ`, but modifies the receiver in\nplace.\n
oct String.oct()\nTreats leading characters of <i>str</i> as a string of octal digits (with an\noptional sign) and returns the corresponding number.  Returns 0 if the\nconversion fails.\n\n   "123".oct       #=> 83\n   "-377".oct      #=> -255\n   "bad".oct       #=> 0\n   "0377bad".oct   #=> 255\n
ord String.ord()\nReturn the `Integer` ordinal of a one-character string.\n\n   "a".ord         #=> 97\n
partition String.partition(p1)\nSearches <i>sep</i> or pattern (<i>regexp</i>) in the string\nand returns the part before it, the match, and the part\nafter it.\nIf it is not found, returns two empty strings and <i>str</i>.\n\n   "hello".partition("l")         #=> ["he", "l", "lo"]\n   "hello".partition("x")         #=> ["hello", "", ""]\n   "hello".partition(/.l/)        #=> ["h", "el", "lo"]\n
replace String.replace(p1)\nReplaces the contents and taintedness of <i>str</i> with the corresponding\nvalues in <i>other_str</i>.\n\n   s = "hello"         #=> "hello"\n   s.replace "world"   #=> "world"\n
reverse String.reverse()\nReturns a new string with the characters from <i>str</i> in reverse order.\n\n   "stressed".reverse   #=> "desserts"\n
reverse! String.reverse!()\nReverses <i>str</i> in place.\n
rindex String.rindex(...)\nReturns the index of the last occurrence of the given <i>substring</i> or\npattern (<i>regexp</i>) in <i>str</i>. Returns `nil` if not\nfound. If the second parameter is present, it specifies the position in the\nstring to end the search---characters beyond this point will not be\nconsidered.\n\n   "hello".rindex('e')             #=> 1\n   "hello".rindex('l')             #=> 3\n   "hello".rindex('a')             #=> nil\n   "hello".rindex(?e)              #=> 1\n   "hello".rindex(/[aeiou]/, -2)   #=> 1\n
rjust String.rjust(...)\nIf <i>integer</i> is greater than the length of <i>str</i>, returns a new\n`String` of length <i>integer</i> with <i>str</i> right justified\nand padded with <i>padstr</i>; otherwise, returns <i>str</i>.\n\n   "hello".rjust(4)            #=> "hello"\n   "hello".rjust(20)           #=> "               hello"\n   "hello".rjust(20, '1234')   #=> "123412341234123hello"\n
rpartition String.rpartition(p1)\nSearches <i>sep</i> or pattern (<i>regexp</i>) in the string from the end\nof the string, and returns the part before it, the match, and the part\nafter it.\nIf it is not found, returns two empty strings and <i>str</i>.\n\n   "hello".rpartition("l")         #=> ["hel", "l", "o"]\n   "hello".rpartition("x")         #=> ["", "", "hello"]\n   "hello".rpartition(/.l/)        #=> ["he", "ll", "o"]\n
rstrip String.rstrip()\nReturns a copy of <i>str</i> with trailing whitespace removed. See also\n`String#lstrip` and `String#strip`.\n\n   "  hello  ".rstrip   #=> "  hello"\n   "hello".rstrip       #=> "hello"\n
rstrip! String.rstrip!()\nRemoves trailing whitespace from <i>str</i>, returning `nil` if\nno change was made. See also `String#lstrip!` and\n`String#strip!`.\n\n   "  hello  ".rstrip   #=> "  hello"\n   "hello".rstrip!      #=> nil\n
scan String.scan(p1)\nBoth forms iterate through <i>str</i>, matching the pattern (which may be a\n`Regexp` or a `String`). For each match, a result is\ngenerated and either added to the result array or passed to the block. If\nthe pattern contains no groups, each individual result consists of the\nmatched string, `$&`.  If the pattern contains groups, each\nindividual result is itself an array containing one entry per group.\n\n   a = "cruel world"\n   a.scan(/\w+/)        #=> ["cruel", "world"]\n   a.scan(/.../)        #=> ["cru", "el ", "wor"]\n   a.scan(/(...)/)      #=> [["cru"], ["el "], ["wor"]]\n   a.scan(/(..)(..)/)   #=> [["cr", "ue"], ["l ", "wo"]]\n\nAnd the block form:\n\n   a.scan(/\w+/) {|w| print "<<#{w}>> " }\n   print "\\n"\n   a.scan(/(.)(.)/) {|x,y| print y, x }\n   print "\\n"\n\n<em>produces:</em>\n\n   <<cruel>> <<world>>\n   rceu lowlr\n
setbyte String.setbyte(p1, p2)\nmodifies the <i>index</i>th byte as <i>int</i>.\n
size String.size()\nReturns the character length of <i>str</i>.\n
slice String.slice(...)\nElement Reference---If passed a single `Fixnum`, returns a\nsubstring of one character at that position. If passed two `Fixnum`\nobjects, returns a substring starting at the offset given by the first, and\na length given by the second. If given a range, a substring containing\ncharacters at offsets given by the range is returned. In all three cases, if\nan offset is negative, it is counted from the end of <i>str</i>. Returns\n`nil` if the initial offset falls outside the string, the length\nis negative, or the beginning of the range is greater than the end.\n\nIf a `Regexp` is supplied, the matching portion of <i>str</i> is\nreturned. If a numeric or name parameter follows the regular expression, that\ncomponent of the `MatchData` is returned instead. If a\n`String` is given, that string is returned if it occurs in\n<i>str</i>. In both cases, `nil` is returned if there is no\nmatch.\n\n   a = "hello there"\n   a[1]                   #=> "e"\n   a[1,3]                 #=> "ell"\n   a[1..3]                #=> "ell"\n   a[-3,2]                #=> "er"\n   a[-4..-2]              #=> "her"\n   a[12..-1]              #=> nil\n   a[-2..-4]              #=> ""\n   a[/[aeiou](.)\1/]      #=> "ell"\n   a[/[aeiou](.)\1/, 0]   #=> "ell"\n   a[/[aeiou](.)\1/, 1]   #=> "l"\n   a[/[aeiou](.)\1/, 2]   #=> nil\n   a["lo"]                #=> "lo"\n   a["bye"]               #=> nil\n
slice! String.slice!(...)\nDeletes the specified portion from <i>str</i>, and returns the portion\ndeleted.\n\n   string = "this is a string"\n   string.slice!(2)        #=> "i"\n   string.slice!(3..6)     #=> " is "\n   string.slice!(/s.*t/)   #=> "sa st"\n   string.slice!("r")      #=> "r"\n   string                  #=> "thing"\n
split String.split(...)\nDivides <i>str</i> into substrings based on a delimiter, returning an array\nof these substrings.\n\nIf <i>pattern</i> is a `String`, then its contents are used as\nthe delimiter when splitting <i>str</i>. If <i>pattern</i> is a single\nspace, <i>str</i> is split on whitespace, with leading whitespace and runs\nof contiguous whitespace characters ignored.\n\nIf <i>pattern</i> is a `Regexp`, <i>str</i> is divided where the\npattern matches. Whenever the pattern matches a zero-length string,\n<i>str</i> is split into individual characters. If <i>pattern</i> contains\ngroups, the respective matches will be returned in the array as well.\n\nIf <i>pattern</i> is omitted, the value of `$;` is used.  If\n`$;` is `nil` (which is the default), <i>str</i> is\nsplit on whitespace as if ` ' were specified.\n\nIf the <i>limit</i> parameter is omitted, trailing null fields are\nsuppressed. If <i>limit</i> is a positive number, at most that number of\nfields will be returned (if <i>limit</i> is `1`, the entire\nstring is returned as the only entry in an array). If negative, there is no\nlimit to the number of fields returned, and trailing null fields are not\nsuppressed.\n\n   " now's  the time".split        #=> ["now's", "the", "time"]\n   " now's  the time".split(' ')   #=> ["now's", "the", "time"]\n   " now's  the time".split(/ /)   #=> ["", "now's", "", "the", "time"]\n   "1, 2.34,56, 7".split(%r{,\s*}) #=> ["1", "2.34", "56", "7"]\n   "hello".split(//)               #=> ["h", "e", "l", "l", "o"]\n   "hello".split(//, 3)            #=> ["h", "e", "llo"]\n   "hi mom".split(%r{\s*})         #=> ["h", "i", "m", "o", "m"]\n\n   "mellow yellow".split("ello")   #=> ["m", "w y", "w"]\n   "1,2,,3,4,,".split(',')         #=> ["1", "2", "", "3", "4"]\n   "1,2,,3,4,,".split(',', 4)      #=> ["1", "2", "", "3,4,,"]\n   "1,2,,3,4,,".split(',', -4)     #=> ["1", "2", "", "3", "4", "", ""]\n
squeeze String.squeeze(...)\nBuilds a set of characters from the <i>other_str</i> parameter(s) using the\nprocedure described for `String#count`. Returns a new string\nwhere runs of the same character that occur in this set are replaced by a\nsingle character. If no arguments are given, all runs of identical\ncharacters are replaced by a single character.\n\n   "yellow moon".squeeze                  #=> "yelow mon"\n   "  now   is  the".squeeze(" ")         #=> " now is the"\n   "putters shoot balls".squeeze("m-z")   #=> "puters shot balls"\n
squeeze! String.squeeze!(...)\nSqueezes <i>str</i> in place, returning either <i>str</i>, or\n`nil` if no changes were made.\n
start_with? String.start_with?(...)\nReturns true if <i>str</i> starts with a prefix given.\n\n  p "hello".start_with?("hell")               #=> true\n returns true if one of prefix matches.\n  p "hello".start_with?("heaven", "hell")     #=> true\n  p "hello".start_with?("heaven", "paradice") #=> false\n
strip String.strip()\nReturns a copy of <i>str</i> with leading and trailing whitespace removed.\n\n   "    hello    ".strip   #=> "hello"\n   "\tgoodbye\r\\n".strip   #=> "goodbye"\n
strip! String.strip!()\nRemoves leading and trailing whitespace from <i>str</i>. Returns\n`nil` if <i>str</i> was not altered.\n
sub String.sub(...)\nReturns a copy of <i>str</i> with the <em>first</em> occurrence of\n<i>pattern</i> substituted for the second argument. The <i>pattern</i> is\ntypically a `Regexp`; if given as a `String`, any\nregular expression metacharacters it contains will be interpreted\nliterally, e.g. `'\\\d'` will match a backlash followed by 'd',\ninstead of a digit.\n\nIf <i>replacement</i> is a `String` it will be substituted for\nthe matched text. It may contain back-references to the pattern's capture\ngroups of the form `\\\d`, where <i>d</i> is a group number, or\n`\\\k<n>`, where <i>n</i> is a group name. If it is a\ndouble-quoted string, both back-references must be preceded by an\nadditional backslash. However, within <i>replacement</i> the special match\nvariables, such as `&$`, will not refer to the current match.\n\nIf the second argument is a `Hash`, and the matched text is one\nof its keys, the corresponding value is the replacement string.\n\nIn the block form, the current match string is passed in as a parameter,\nand variables such as `$1`, `$2`, `$``,\n`$&`, and `$'` will be set appropriately. The value\nreturned by the block will be substituted for the match on each call.\n\nThe result inherits any tainting in the original string or any supplied\nreplacement string.\n\n   "hello".sub(/[aeiou]/, '*')                  #=> "h*llo"\n   "hello".sub(/([aeiou])/, '<\1>')             #=> "h<e>llo"\n   "hello".sub(/./) {|s| s.ord.to_s + ' ' }     #=> "104 ello"\n   "hello".sub(/(?<foo>[aeiou])/, '*\k<foo>*')  #=> "h*e*llo"\n   'Is SHELL your preferred shell?'.sub(/[[:upper:]]{2,}/, ENV)\n=> "Is /bin/bash your preferred shell?"\n
sub! String.sub!(...)\nPerforms the substitutions of `String#sub` in place,\nreturning <i>str</i>, or `nil` if no substitutions were\nperformed.\n
succ String.succ()\nReturns the successor to <i>str</i>. The successor is calculated by\nincrementing characters starting from the rightmost alphanumeric (or\nthe rightmost character if there are no alphanumerics) in the\nstring. Incrementing a digit always results in another digit, and\nincrementing a letter results in another letter of the same case.\nIncrementing nonalphanumerics uses the underlying character set's\ncollating sequence.\n\nIf the increment generates a ``carry,'' the character to the left of\nit is incremented. This process repeats until there is no carry,\nadding an additional character if necessary.\n\n   "abcd".succ        #=> "abce"\n   "THX1138".succ     #=> "THX1139"\n   "<<koala>>".succ   #=> "<<koalb>>"\n   "1999zzz".succ     #=> "2000aaa"\n   "ZZZ9999".succ     #=> "AAAA0000"\n   "***".succ         #=> "**+"\n
succ! String.succ!()\nEquivalent to `String#succ`, but modifies the receiver in\nplace.\n
sum String.sum(...)\nReturns a basic <em>n</em>-bit checksum of the characters in <i>str</i>,\nwhere <em>n</em> is the optional `Fixnum` parameter, defaulting\nto 16. The result is simply the sum of the binary value of each character in\n<i>str</i> modulo `2**n - 1`. This is not a particularly good\nchecksum.\n
swapcase String.swapcase()\nReturns a copy of <i>str</i> with uppercase alphabetic characters converted\nto lowercase and lowercase characters converted to uppercase.\nNote: case conversion is effective only in ASCII region.\n\n   "Hello".swapcase          #=> "hELLO"\n   "cYbEr_PuNk11".swapcase   #=> "CyBeR_pUnK11"\n
swapcase! String.swapcase!()\nEquivalent to `String#swapcase`, but modifies the receiver in\nplace, returning <i>str</i>, or `nil` if no changes were made.\nNote: case conversion is effective only in ASCII region.\n
to_c String.to_c()\nReturns a complex which denotes the string form.  The parser\nignores leading whitespaces and trailing garbage.  Any digit\nsequences can be separated by an underscore.  Returns zero for null\nor garbage string.\n\nFor example:\n\n   '9'.to_c           #=> (9+0i)\n   '2.5'.to_c         #=> (2.5+0i)\n   '2.5/1'.to_c       #=> ((5/2)+0i)\n   '-3/2'.to_c        #=> ((-3/2)+0i)\n   '-i'.to_c          #=> (0-1i)\n   '45i'.to_c         #=> (0+45i)\n   '3-4i'.to_c        #=> (3-4i)\n   '-4e2-4e-2i'.to_c  #=> (-400.0-0.04i)\n   '-0.0-0.0i'.to_c   #=> (-0.0-0.0i)\n   '1/2+3/4i'.to_c    #=> ((1/2)+(3/4)*i)\n   'ruby'.to_c        #=> (0+0i)\n
to_f String.to_f()\nReturns the result of interpreting leading characters in <i>str</i> as a\nfloating point number. Extraneous characters past the end of a valid number\nare ignored. If there is not a valid number at the start of <i>str</i>,\n`0.0` is returned. This method never raises an exception.\n\n   "123.45e1".to_f        #=> 1234.5\n   "45.67 degrees".to_f   #=> 45.67\n   "thx1138".to_f         #=> 0.0\n
to_i String.to_i(...)\nReturns the result of interpreting leading characters in <i>str</i> as an\ninteger base <i>base</i> (between 2 and 36). Extraneous characters past the\nend of a valid number are ignored. If there is not a valid number at the\nstart of <i>str</i>, `0` is returned. This method never raises an\nexception when <i>base</i> is valid.\n\n   "12345".to_i             #=> 12345\n   "99 red balloons".to_i   #=> 99\n   "0a".to_i                #=> 0\n   "0a".to_i(16)            #=> 10\n   "hello".to_i             #=> 0\n   "1100101".to_i(2)        #=> 101\n   "1100101".to_i(8)        #=> 294977\n   "1100101".to_i(10)       #=> 1100101\n   "1100101".to_i(16)       #=> 17826049\n
to_r String.to_r()\nReturns a rational which denotes the string form.  The parser\nignores leading whitespaces and trailing garbage.  Any digit\nsequences can be separated by an underscore.  Returns zero for null\nor garbage string.\n\nNOTE: '0.3'.to_r isn't the same as 0.3.to_r.  The former is\nequivalent to '3/10'.to_r, but the latter isn't so.\n\nFor example:\n\n   '  2  '.to_r       #=> (2/1)\n   '300/2'.to_r       #=> (150/1)\n   '-9.2'.to_r        #=> (-46/5)\n   '-9.2e2'.to_r      #=> (-920/1)\n   '1_234_567'.to_r   #=> (1234567/1)\n   '21 june 09'.to_r  #=> (21/1)\n   '21/06/09'.to_r    #=> (7/2)\n   'bwv 1079'.to_r    #=> (0/1)\n
to_s String.to_s()\nReturns the receiver.\n
to_str String.to_str()\nReturns the receiver.\n
to_sym String.to_sym()\nReturns the `Symbol` corresponding to <i>str</i>, creating the\nsymbol if it did not previously exist. See `Symbol#id2name`.\n\n   "Koala".intern         #=> :Koala\n   s = 'cat'.to_sym       #=> :cat\n   s == :cat              #=> true\n   s = '@cat'.to_sym      #=> :@cat\n   s == :@cat             #=> true\n\nThis can also be used to create symbols that cannot be represented using the\n`:xxx` notation.\n\n   'cat and dog'.to_sym   #=> :"cat and dog"\n
tr String.tr(p1, p2)\nReturns a copy of <i>str</i> with the characters in <i>from_str</i> replaced\nby the corresponding characters in <i>to_str</i>. If <i>to_str</i> is\nshorter than <i>from_str</i>, it is padded with its last character. Both\nstrings may use the c1--c2 notation to denote ranges of characters, and\n<i>from_str</i> may start with a `^`, which denotes all\ncharacters except those listed.\n\n   "hello".tr('aeiou', '*')    #=> "h*ll*"\n   "hello".tr('^aeiou', '*')   #=> "*e**o"\n   "hello".tr('el', 'ip')      #=> "hippo"\n   "hello".tr('a-y', 'b-z')    #=> "ifmmp"\n
tr! String.tr!(p1, p2)\nTranslates <i>str</i> in place, using the same rules as\n`String#tr`. Returns <i>str</i>, or `nil` if no\nchanges were made.\n
tr_s String.tr_s(p1, p2)\nProcesses a copy of <i>str</i> as described under `String#tr`,\nthen removes duplicate characters in regions that were affected by the\ntranslation.\n\n   "hello".tr_s('l', 'r')     #=> "hero"\n   "hello".tr_s('el', '*')    #=> "h*o"\n   "hello".tr_s('el', 'hx')   #=> "hhxo"\n
tr_s! String.tr_s!(p1, p2)\nPerforms `String#tr_s` processing on <i>str</i> in place,\nreturning <i>str</i>, or `nil` if no changes were made.\n
unpack String.unpack(p1)\nDecodes <i>str</i> (which may contain binary data) according to the\nformat string, returning an array of each value extracted. The\nformat string consists of a sequence of single-character directives,\nsummarized in the table at the end of this entry.\nEach directive may be followed\nby a number, indicating the number of times to repeat with this\ndirective. An asterisk (```*`'') will use up all\nremaining elements. The directives `sSiIlL` may each be\nfollowed by an underscore (```_`'') or\nexclamation mark (```!`'') to use the underlying\nplatform's native size for the specified type; otherwise, it uses a\nplatform-independent consistent size. Spaces are ignored in the\nformat string. See also `Array#pack`.\n\n   "abc \0\0abc \0\0".unpack('A6Z6')   #=> ["abc", "abc "]\n   "abc \0\0".unpack('a3a3')           #=> ["abc", " \000\000"]\n   "abc \0abc \0".unpack('Z*Z*')       #=> ["abc ", "abc "]\n   "aa".unpack('b8B8')                 #=> ["10000110", "01100001"]\n   "aaa".unpack('h2H2c')               #=> ["16", "61", 97]\n   "\xfe\xff\xfe\xff".unpack('sS')     #=> [-2, 65534]\n   "now=20is".unpack('M*')             #=> ["now is"]\n   "whole".unpack('xax2aX2aX1aX2a')    #=> ["h", "e", "l", "l", "o"]\n\nThis table summarizes the various formats and the Ruby classes\nreturned by each.\n\n Integer      |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    C         | Integer | 8-bit unsigned integer (unsigned char)\n    S         | Integer | 16-bit unsigned integer, native endian (uint16_t)\n    L         | Integer | 32-bit unsigned integer, native endian (uint32_t)\n    Q         | Integer | 64-bit unsigned integer, native endian (uint64_t)\n              |         |\n    c         | Integer | 8-bit signed integer (signed char)\n    s         | Integer | 16-bit signed integer, native endian (int16_t)\n    l         | Integer | 32-bit signed integer, native endian (int32_t)\n    q         | Integer | 64-bit signed integer, native endian (int64_t)\n              |         |\n    S_, S!    | Integer | unsigned short, native endian\n    I, I_, I! | Integer | unsigned int, native endian\n    L_, L!    | Integer | unsigned long, native endian\n              |         |\n    s_, s!    | Integer | signed short, native endian\n    i, i_, i! | Integer | signed int, native endian\n    l_, l!    | Integer | signed long, native endian\n              |         |\n    n         | Integer | 16-bit unsigned integer, network (big-endian)\n    byte order\n    N         | Integer | 32-bit unsigned integer, network (big-endian)\n    byte order\n    v         | Integer | 16-bit unsigned integer, VAX (little-endian)\n    byte order\n    V         | Integer | 32-bit unsigned integer, VAX (little-endian)\n    byte order\n              |         |\n    U         | Integer | UTF-8 character\n    w         | Integer | BER-compressed integer (see Array.pack)\n\n Float        |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    D, d      | Float   | double-precision float, native format\n    F, f      | Float   | single-precision float, native format\n    E         | Float   | double-precision float, little-endian byte order\n    e         | Float   | single-precision float, little-endian byte order\n    G         | Float   | double-precision float, network (big-endian)\n    byte order\n    g         | Float   | single-precision float, network (big-endian)\n    byte order\n\n String       |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    A         | String  | arbitrary binary string (remove trailing nulls\n    and ASCII spaces)\n    a         | String  | arbitrary binary string\n    Z         | String  | null-terminated string\n    B         | String  | bit string (MSB first)\n    b         | String  | bit string (LSB first)\n    H         | String  | hex string (high nibble first)\n    h         | String  | hex string (low nibble first)\n    u         | String  | UU-encoded string\n    M         | String  | quoted-printable, MIME encoding (see RFC2045)\n    m         | String  | base64 encoded string (RFC 2045) (default)\n              |         | base64 encoded string (RFC 4648) if followed by 0\n    P         | String  | pointer to a structure (fixed-length string)\n    p         | String  | pointer to a null-terminated string\n\n Misc.        |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    @         | ---     | skip to the offset given by the length argument\n    X         | ---     | skip backward one byte\n    x         | ---     | skip forward one byte\n
upcase String.upcase()\nReturns a copy of <i>str</i> with all lowercase letters replaced with their\nuppercase counterparts. The operation is locale insensitive---only\ncharacters ``a'' to ``z'' are affected.\nNote: case replacement is effective only in ASCII region.\n\n   "hEllO".upcase   #=> "HELLO"\n
upcase! String.upcase!()\nUpcases the contents of <i>str</i>, returning `nil` if no changes\nwere made.\nNote: case replacement is effective only in ASCII region.\n
upto String.upto(...)\nIterates through successive values, starting at <i>str</i> and\nending at <i>other_str</i> inclusive, passing each value in turn to\nthe block. The `String#succ` method is used to generate\neach value.  If optional second argument exclusive is omitted or is false,\nthe last value will be included; otherwise it will be excluded.\n\nIf no block is given, an enumerator is returned instead.\n\n   "a8".upto("b6") {|s| print s, ' ' }\n   for s in "a8".."b6"\n     print s, ' '\n   end\n\n<em>produces:</em>\n\n   a8 a9 b0 b1 b2 b3 b4 b5 b6\n   a8 a9 b0 b1 b2 b3 b4 b5 b6\n\nIf <i>str</i> and <i>other_str</i> contains only ascii numeric characters,\nboth are recognized as decimal numbers. In addition, the width of\nstring (e.g. leading zeros) is handled appropriately.\n\n   "9".upto("11").to_a   #=> ["9", "10", "11"]\n   "25".upto("5").to_a   #=> []\n   "07".upto("11").to_a  #=> ["07", "08", "09", "10", "11"]\n
valid_encoding? String.valid_encoding?()\nReturns true for a string which encoded correctly.\n\n  "\xc2\xa1".force_encoding("UTF-8").valid_encoding?  #=> true\n  "\xc2".force_encoding("UTF-8").valid_encoding?      #=> false\n  "\x80".force_encoding("UTF-8").valid_encoding?      #=> false\n
abs Float.abs()\nReturns the absolute value of <i>flt</i>.\n\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n
angle Float.angle()\nReturns 0 if the value is positive, pi otherwise.\n
arg Float.arg()\nReturns 0 if the value is positive, pi otherwise.\n
ceil Float.ceil()\nReturns the smallest `Integer` greater than or equal to\n<i>flt</i>.\n\n   1.2.ceil      #=> 2\n   2.0.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-2.0).ceil   #=> -2\n
coerce Float.coerce(p1)\nMISSING: documentation\n
denominator Float.denominator()\nReturns the denominator (always positive).  The result is machine\ndependent.\n\nSee numerator.\n
divmod Float.divmod(p1)\nSee `Numeric#divmod`.\n
eql? Float.eql?(p1)\nReturns `true` only if <i>obj</i> is a\n`Float` with the same value as <i>flt</i>. Contrast this\nwith `Float#==`, which performs type conversions.\n\n   1.0.eql?(1)   #=> false\n
fdiv Float.fdiv(p1)\nReturns float / numeric.\n
finite? Float.finite?()\nReturns `true` if <i>flt</i> is a valid IEEE floating\npoint number (it is not infinite, and `nan?` is\n`false`).\n
floor Float.floor()\nReturns the largest integer less than or equal to <i>flt</i>.\n\n   1.2.floor      #=> 1\n   2.0.floor      #=> 2\n   (-1.2).floor   #=> -2\n   (-2.0).floor   #=> -2\n
hash Float.hash()\nReturns a hash code for this float.\n
infinite? Float.infinite?()\nReturns `nil`, -1, or +1 depending on whether <i>flt</i>\nis finite, -infinity, or +infinity.\n\n   (0.0).infinite?        #=> nil\n   (-1.0/0.0).infinite?   #=> -1\n   (+1.0/0.0).infinite?   #=> 1\n
magnitude Float.magnitude()\nReturns the absolute value of <i>flt</i>.\n\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n
modulo Float.modulo(p1)\nReturn the modulo after division of `flt` by `other`.\n\n   6543.21.modulo(137)      #=> 104.21\n   6543.21.modulo(137.24)   #=> 92.9299999999996\n
nan? Float.nan?()\nReturns `true` if <i>flt</i> is an invalid IEEE floating\npoint number.\n\n   a = -1.0      #=> -1.0\n   a.nan?        #=> false\n   a = 0.0/0.0   #=> NaN\n   a.nan?        #=> true\n
numerator Float.numerator()\nReturns the numerator.  The result is machine dependent.\n\nFor example:\n\n   n = 0.3.numerator    #=> 5404319552844595\n   d = 0.3.denominator  #=> 18014398509481984\n   n.fdiv(d)            #=> 0.3\n
phase Float.phase()\nReturns 0 if the value is positive, pi otherwise.\n
quo Float.quo(p1)\nReturns float / numeric.\n
rationalize Float.rationalize(...)\nReturns a simpler approximation of the value (flt-|eps| <= result\n<= flt+|eps|).  if eps is not given, it will be chosen\nautomatically.\n\nFor example:\n\n   0.3.rationalize          #=> (3/10)\n   1.333.rationalize        #=> (1333/1000)\n   1.333.rationalize(0.01)  #=> (4/3)\n
round Float.round(...)\nRounds <i>flt</i> to a given precision in decimal digits (default 0 digits).\nPrecision may be negative.  Returns a floating point number when ndigits\nis more than zero.\n\n   1.4.round      #=> 1\n   1.5.round      #=> 2\n   1.6.round      #=> 2\n   (-1.5).round   #=> -2\n\n   1.234567.round(2)  #=> 1.23\n   1.234567.round(3)  #=> 1.235\n   1.234567.round(4)  #=> 1.2346\n   1.234567.round(5)  #=> 1.23457\n\n   34567.89.round(-5) #=> 0\n   34567.89.round(-4) #=> 30000\n   34567.89.round(-3) #=> 35000\n   34567.89.round(-2) #=> 34600\n   34567.89.round(-1) #=> 34570\n   34567.89.round(0)  #=> 34568\n   34567.89.round(1)  #=> 34567.9\n   34567.89.round(2)  #=> 34567.89\n   34567.89.round(3)  #=> 34567.89\n
to_f Float.to_f()\nAs `flt` is already a float, returns +self+.\n
to_i Float.to_i()\nReturns <i>flt</i> truncated to an `Integer`.\n
to_int Float.to_int()\nReturns <i>flt</i> truncated to an `Integer`.\n
to_r Float.to_r()\nReturns the value as a rational.\n\nNOTE: 0.3.to_r isn't the same as '0.3'.to_r.  The latter is\nequivalent to '3/10'.to_r, but the former isn't so.\n\nFor example:\n\n   2.0.to_r    #=> (2/1)\n   2.5.to_r    #=> (5/2)\n   -0.75.to_r  #=> (-3/4)\n   0.0.to_r    #=> (0/1)\n
to_s Float.to_s()\nReturns a string containing a representation of self. As well as a\nfixed or exponential form of the number, the call may return\n```NaN`'', ```Infinity`'', and\n```-Infinity`''.\n
truncate Float.truncate()\nReturns <i>flt</i> truncated to an `Integer`.\n
zero? Float.zero?()\nReturns `true` if <i>flt</i> is 0.0.\n
current Fiber.current()\nReturns the current fiber. You need to `require 'fiber'`\nbefore using this method. If you are not running in the context of\na fiber this method will return the root fiber.\n
yield Fiber.yield(...)\nYields control back to the context that resumed the fiber, passing\nalong any arguments that were passed to it. The fiber will resume\nprocessing at this point when `resume` is called next.\nAny arguments passed to the next `resume` will be the\nvalue that this `Fiber.yield` expression evaluates to.\n
alive? Fiber.alive?()\nReturns true if the fiber can still be resumed (or transferred to).\nAfter finishing execution of the fiber block this method will always\nreturn false.\n
resume Fiber.resume(...)\nResumes the fiber from the point at which the last `Fiber.yield`\nwas called, or starts running it if it is the first call to\n`resume`. Arguments passed to resume will be the value of\nthe `Fiber.yield` expression or will be passed as block\nparameters to the fiber's block if this is the first `resume`.\n\nAlternatively, when resume is called it evaluates to the arguments passed\nto the next `Fiber.yield` statement inside the fiber's block\nor to the block value if it runs to completion without any\n`Fiber.yield`\n
transfer Fiber.transfer(...)\nTransfer control to another fiber, resuming it from where it last\nstopped or starting it if it was not resumed before. The calling\nfiber will be suspended much like in a call to `Fiber.yield`.\n\nThe fiber which receives the transfer call is treats it much like\na resume call. Arguments passed to transfer are treated like those\npassed to resume.\n\nYou cannot resume a fiber that transferred control to another one.\nThis will cause a double resume error. You need to transfer control\nback to this fiber before it can yield and resume.\n
call Continuation.call(...)\nInvokes the continuation. The program continues from the end of the\n`callcc` block. If no arguments are given, the original\n`callcc` returns `nil`. If one argument is\ngiven, `callcc` returns it. Otherwise, an array\ncontaining <i>args</i> is returned.\n\n   callcc {|cont|  cont.call }           #=> nil\n   callcc {|cont|  cont.call 1 }         #=> 1\n   callcc {|cont|  cont.call 1, 2, 3 }   #=> [1, 2, 3]\n
chdir Dir.chdir(...)\nChanges the current working directory of the process to the given\nstring. When called without an argument, changes the directory to\nthe value of the environment variable `HOME`, or\n`LOGDIR`. `SystemCallError` (probably\n`Errno::ENOENT`) if the target directory does not exist.\n\nIf a block is given, it is passed the name of the new current\ndirectory, and the block is executed with that as the current\ndirectory. The original working directory is restored when the block\nexits. The return value of `chdir` is the value of the\nblock. `chdir` blocks can be nested, but in a\nmulti-threaded program an error will be raised if a thread attempts\nto open a `chdir` block while another thread has one\nopen.\n\n   Dir.chdir("/var/spool/mail")\n   puts Dir.pwd\n   Dir.chdir("/tmp") do\n     puts Dir.pwd\n     Dir.chdir("/usr") do\n       puts Dir.pwd\n     end\n     puts Dir.pwd\n   end\n   puts Dir.pwd\n\n<em>produces:</em>\n\n   /var/spool/mail\n   /tmp\n   /usr\n   /tmp\n   /var/spool/mail\n
chroot Dir.chroot(p1)\nChanges this process's idea of the file system root. Only a\nprivileged process may make this call. Not available on all\nplatforms. On Unix systems, see `chroot(2)` for more\ninformation.\n
delete Dir.delete(p1)\nDeletes the named directory. Raises a subclass of\n`SystemCallError` if the directory isn't empty.\n
entries Dir.entries(...)\nReturns an array containing all of the filenames in the given\ndirectory. Will raise a `SystemCallError` if the named\ndirectory doesn't exist.\n\n   Dir.entries("testdir")   #=> [".", "..", "config.h", "main.rb"]\n
exist? Dir.exist?(p1)\n?\n\n\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
exists? Dir.exists?(p1)\n?\n\n\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
foreach Dir.foreach(...)\nCalls the block once for each entry in the named directory, passing\nthe filename of each entry as a parameter to the block.\n\nIf no block is given, an enumerator is returned instead.\n\n   Dir.foreach("testdir") {|x| puts "Got #{x}" }\n\n<em>produces:</em>\n\n   Got .\n   Got ..\n   Got config.h\n   Got main.rb\n
getwd Dir.getwd()\nReturns the path to the current working directory of this process as\na string.\n\n   Dir.chdir("/tmp")   #=> 0\n   Dir.getwd           #=> "/tmp"\n
glob Dir.glob(...)\nReturns the filenames found by expanding <i>pattern</i> which is\nan +Array+ of the patterns or the pattern +String+, either as an\n<i>array</i> or as parameters to the block. Note that this pattern\nis not a regexp (it's closer to a shell glob). See\n`File::fnmatch` for the meaning of the <i>flags</i>\nparameter. Note that case sensitivity depends on your system (so\n`File::FNM_CASEFOLD` is ignored)\n\n`*`::        Matches any file. Can be restricted by\n                        other values in the glob. `*`\n                        will match all files; `c*` will\n                        match all files beginning with\n                        `c`; `*c` will match\n                        all files ending with `c`; and\n                        `\*c\*` will match all files that\n                        have `c` in them (including at\n                        the beginning or end). Equivalent to\n                        `/ .* /x` in regexp. Note, this\n                        will not match Unix-like hidden files (dotfiles).\n                        In order to include those in the match results,\n                        you must use something like "{*,.*}".\n`**`::       Matches directories recursively.\n`?`::        Matches any one character. Equivalent to\n                        `/.{1}/` in regexp.\n`[set]`::    Matches any one character in +set+.\n                        Behaves exactly like character sets in\n                        Regexp, including set negation\n                        (`[^a-z]`).\n`{p,q}`::    Matches either literal `p` or\n                        literal `q`. Matching literals\n                        may be more than one character in length.\n                        More than two literals may be specified.\n                        Equivalent to pattern alternation in\n                        regexp.\n`\`::        Escapes the next metacharacter.\n                        Note that this means you cannot use backslash\n                        in windows\n                        as part of a glob, i.e. Dir["c:\\foo*"] will not work\n                        use Dir["c:/foo*"] instead\n\n   Dir["config.?"]                     #=> ["config.h"]\n   Dir.glob("config.?")                #=> ["config.h"]\n   Dir.glob("*.[a-z][a-z]")            #=> ["main.rb"]\n   Dir.glob("*.[^r]*")                 #=> ["config.h"]\n   Dir.glob("*.{rb,h}")                #=> ["main.rb", "config.h"]\n   Dir.glob("*")                       #=> ["config.h", "main.rb"]\n   Dir.glob("*", File::FNM_DOTMATCH)   #=> [".", "..", "config.h", "main.rb"]\n\n   rbfiles = File.join("**", "*.rb")\n   Dir.glob(rbfiles)                   #=> ["main.rb",\n    "lib/song.rb",\n    "lib/song/karaoke.rb"]\n   libdirs = File.join("**", "lib")\n   Dir.glob(libdirs)                   #=> ["lib"]\n\n   librbfiles = File.join("**", "lib", "**", "*.rb")\n   Dir.glob(librbfiles)                #=> ["lib/song.rb",\n    "lib/song/karaoke.rb"]\n\n   librbfiles = File.join("**", "lib", "*.rb")\n   Dir.glob(librbfiles)                #=> ["lib/song.rb"]\n
home Dir.home(...)\nReturns the home directory of the current user or the named user\nif given.\n
mkdir Dir.mkdir(...)\nMakes a new directory named by <i>string</i>, with permissions\nspecified by the optional parameter <i>anInteger</i>. The\npermissions may be modified by the value of\n`File::umask`, and are ignored on NT. Raises a\n`SystemCallError` if the directory cannot be created. See\nalso the discussion of permissions in the class documentation for\n`File`.\n
new Dir.new(...)\nReturns a new directory object for the named directory.\n
open Dir.open(...)\nWith no block, `open` is a synonym for\n`Dir::new`. If a block is present, it is passed\n<i>aDir</i> as a parameter. The directory is closed at the end of\nthe block, and `Dir::open` returns the value of the\nblock.\n
pwd Dir.pwd()\nReturns the path to the current working directory of this process as\na string.\n\n   Dir.chdir("/tmp")   #=> 0\n   Dir.getwd           #=> "/tmp"\n
rmdir Dir.rmdir(p1)\nDeletes the named directory. Raises a subclass of\n`SystemCallError` if the directory isn't empty.\n
unlink Dir.unlink(p1)\nDeletes the named directory. Raises a subclass of\n`SystemCallError` if the directory isn't empty.\n
close Dir.close()\nCloses the directory stream. Any further attempts to access\n<em>dir</em> will raise an `IOError`.\n\n   d = Dir.new("testdir")\n   d.close   #=> nil\n
each Dir.each()\nCalls the block once for each entry in this directory, passing the\nfilename of each entry as a parameter to the block.\n\nIf no block is given, an enumerator is returned instead.\n\n   d = Dir.new("testdir")\n   d.each  {|x| puts "Got #{x}" }\n\n<em>produces:</em>\n\n   Got .\n   Got ..\n   Got config.h\n   Got main.rb\n
inspect Dir.inspect()\nReturn a string describing this Dir object.\n
path Dir.path()\nReturns the path parameter passed to <em>dir</em>'s constructor.\n\n   d = Dir.new("..")\n   d.path   #=> ".."\n
pos Dir.pos()\nReturns the current position in <em>dir</em>. See also\n`Dir#seek`.\n\n   d = Dir.new("testdir")\n   d.tell   #=> 0\n   d.read   #=> "."\n   d.tell   #=> 12\n
pos= Dir.pos=(p1)\nSynonym for `Dir#seek`, but returns the position\nparameter.\n\n   d = Dir.new("testdir")   #=> #<Dir:0x401b3c40>\n   d.read                   #=> "."\n   i = d.pos                #=> 12\n   d.read                   #=> ".."\n   d.pos = i                #=> 12\n   d.read                   #=> ".."\n
read Dir.read()\nReads the next entry from <em>dir</em> and returns it as a string.\nReturns `nil` at the end of the stream.\n\n   d = Dir.new("testdir")\n   d.read   #=> "."\n   d.read   #=> ".."\n   d.read   #=> "config.h"\n
rewind Dir.rewind()\nRepositions <em>dir</em> to the first entry.\n\n   d = Dir.new("testdir")\n   d.read     #=> "."\n   d.rewind   #=> #<Dir:0x401b3fb0>\n   d.read     #=> "."\n
seek Dir.seek(p1)\nSeeks to a particular location in <em>dir</em>. <i>integer</i>\nmust be a value returned by `Dir#tell`.\n\n   d = Dir.new("testdir")   #=> #<Dir:0x401b3c40>\n   d.read                   #=> "."\n   i = d.tell               #=> 12\n   d.read                   #=> ".."\n   d.seek(i)                #=> #<Dir:0x401b3c40>\n   d.read                   #=> ".."\n
tell Dir.tell()\nReturns the current position in <em>dir</em>. See also\n`Dir#seek`.\n\n   d = Dir.new("testdir")\n   d.tell   #=> 0\n   d.read   #=> "."\n   d.tell   #=> 12\n
to_path Dir.to_path()\nReturns the path parameter passed to <em>dir</em>'s constructor.\n\n   d = Dir.new("..")\n   d.path   #=> ".."\n
absolute_path File.absolute_path(...)\nConverts a pathname to an absolute pathname. Relative paths are\nreferenced from the current working directory of the process unless\n<i>dir_string</i> is given, in which case it will be used as the\nstarting point. If the given pathname starts with a ```~`''\nit is NOT expanded, it is treated as a normal directory name.\n\n   File.absolute_path("~oracle/bin")       #=> "<relative_path>/~oracle/bin"\n
atime File.atime(p1)\nReturns the last access time for the named file as a Time object).\n\n   File.atime("testfile")   #=> Wed Apr 09 08:51:48 CDT 2003\n
basename File.basename(...)\nReturns the last component of the filename given in <i>file_name</i>,\nwhich must be formed using forward slashes (```/`'')\nregardless of the separator used on the local file system. If\n<i>suffix</i> is given and present at the end of <i>file_name</i>,\nit is removed.\n\n   File.basename("/home/gumby/work/ruby.rb")          #=> "ruby.rb"\n   File.basename("/home/gumby/work/ruby.rb", ".rb")   #=> "ruby"\n
blockdev? File.blockdev?(p1)\nReturns `true` if the named file is a block device.\n
chardev? File.chardev?(p1)\nReturns `true` if the named file is a character device.\n
chmod File.chmod(...)\nChanges permission bits on the named file(s) to the bit pattern\nrepresented by <i>mode_int</i>. Actual effects are operating system\ndependent (see the beginning of this section). On Unix systems, see\n`chmod(2)` for details. Returns the number of files\nprocessed.\n\n   File.chmod(0644, "testfile", "out")   #=> 2\n
chown File.chown(...)\nChanges the owner and group of the named file(s) to the given\nnumeric owner and group id's. Only a process with superuser\nprivileges may change the owner of a file. The current owner of a\nfile may change the file's group to any group to which the owner\nbelongs. A `nil` or -1 owner or group id is ignored.\nReturns the number of files processed.\n\n   File.chown(nil, 100, "testfile")\n
ctime File.ctime(p1)\nReturns the change time for the named file (the time at which\ndirectory information about the file was changed, not the file\nitself).\n\n   File.ctime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003\n
delete File.delete(...)\nDeletes the named files, returning the number of names\npassed as arguments. Raises an exception on any error.\nSee also `Dir::rmdir`.\n
directory? File.directory?(p1)\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
dirname File.dirname(p1)\nReturns all components of the filename given in <i>file_name</i>\nexcept the last one. The filename must be formed using forward\nslashes (```/`'') regardless of the separator used on the\nlocal file system.\n\n   File.dirname("/home/gumby/work/ruby.rb")   #=> "/home/gumby/work"\n
executable? File.executable?(p1)\nReturns `true` if the named file is executable by the effective\nuser id of this process.\n
executable_real? File.executable_real?(p1)\nReturns `true` if the named file is executable by the real\nuser id of this process.\n
exist? File.exist?(p1)\nReturns `true` if the named file is a directory,\n`false` otherwise.\n
exists? File.exists?(p1)\nReturn `true` if the named file exists.\n
expand_path File.expand_path(...)\nConverts a pathname to an absolute pathname. Relative paths are\nreferenced from the current working directory of the process unless\n<i>dir_string</i> is given, in which case it will be used as the\nstarting point. The given pathname may start with a\n```~`'', which expands to the process owner's home\ndirectory (the environment variable `HOME` must be set\ncorrectly). ```~`<i>user</i>'' expands to the named\nuser's home directory.\n\n   File.expand_path("~oracle/bin")           #=> "/home/oracle/bin"\n   File.expand_path("../../bin", "/tmp/x")   #=> "/bin"\n
extname File.extname(p1)\nReturns the extension (the portion of file name in <i>path</i>\nafter the period).\n\n   File.extname("test.rb")         #=> ".rb"\n   File.extname("a/b/d/test.rb")   #=> ".rb"\n   File.extname("test")            #=> ""\n   File.extname(".profile")        #=> ""\n
file? File.file?(p1)\nReturns `true` if the named file exists and is a\nregular file.\n
fnmatch File.fnmatch(...)\nReturns true if <i>path</i> matches against <i>pattern</i> The\npattern is not a regular expression; instead it follows rules\nsimilar to shell filename globbing. It may contain the following\nmetacharacters:\n\n`*`::        Matches any file. Can be restricted by\n                        other values in the glob. `*`\n                        will match all files; `c*` will\n                        match all files beginning with\n                        `c`; `*c` will match\n                        all files ending with `c`; and\n                        `*c*` will match all files that\n                        have `c` in them (including at\n                        the beginning or end). Equivalent to\n                        `/ .* /x` in regexp.\n`**`::       Matches directories recursively or files\n                        expansively.\n`?`::        Matches any one character. Equivalent to\n                        `/.{1}/` in regexp.\n`[set]`::    Matches any one character in +set+.\n                        Behaves exactly like character sets in\n                        Regexp, including set negation\n                        (`[^a-z]`).\n`\`::        Escapes the next metacharacter.\n\n<i>flags</i> is a bitwise OR of the `FNM_xxx`\nparameters. The same glob pattern and flags are used by\n`Dir::glob`.\n\n   File.fnmatch('cat',       'cat')        #=> true  # match entire string\n   File.fnmatch('cat',       'category')   #=> false # only match partial\n   string\n   File.fnmatch('c{at,ub}s', 'cats')       #=> false # { } isn't supported\n\n   File.fnmatch('c?t',     'cat')          #=> true  # '?' match only\n   1 character\n   File.fnmatch('c??t',    'cat')          #=> false # ditto\n   File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more\n   characters\n   File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto\n   File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket\n   expression\n   File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket\n   expression ('^' or '!')\n\n   File.fnmatch('cat', 'CAT')                     #=> false # case sensitive\n   File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive\n\n   File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't\n   match '/' on FNM_PATHNAME\n   File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto\n   File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto\n\n   File.fnmatch('\?',   '?')                       #=> true  # escaped\n   wildcard becomes ordinary\n   File.fnmatch('\a',   'a')                       #=> true  # escaped\n   ordinary remains ordinary\n   File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESACPE\n   makes '\' ordinary\n   File.fnmatch('[\?]', '?')                       #=> true  # can escape\n   inside bracket expression\n\n   File.fnmatch('*',   '.profile')                      #=> false # wildcard\n   doesn't match leading\n   File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period\n   by default.\n   File.fnmatch('.*',  '.profile')                      #=> true\n\n   rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write\n   in single string.\n   File.fnmatch(rbfiles, 'main.rb')                    #=> false\n   File.fnmatch(rbfiles, './main.rb')                  #=> false\n   File.fnmatch(rbfiles, 'lib/song.rb')                #=> true\n   File.fnmatch('**.rb', 'main.rb')                    #=> true\n   File.fnmatch('**.rb', './main.rb')                  #=> false\n   File.fnmatch('**.rb', 'lib/song.rb')                #=> true\n   File.fnmatch('*',           'dave/.profile')                      #=> true\n\n   pattern = '*' '/' '*'\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME |\n   File::FNM_DOTMATCH) #=> true\n\n   pattern = '**' '/' 'foo'\n   File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true\n   File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true\n   File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH)\n   #=> true\n
fnmatch? File.fnmatch?(...)\nReturns true if <i>path</i> matches against <i>pattern</i> The\npattern is not a regular expression; instead it follows rules\nsimilar to shell filename globbing. It may contain the following\nmetacharacters:\n\n`*`::        Matches any file. Can be restricted by\n                        other values in the glob. `*`\n                        will match all files; `c*` will\n                        match all files beginning with\n                        `c`; `*c` will match\n                        all files ending with `c`; and\n                        `*c*` will match all files that\n                        have `c` in them (including at\n                        the beginning or end). Equivalent to\n                        `/ .* /x` in regexp.\n`**`::       Matches directories recursively or files\n                        expansively.\n`?`::        Matches any one character. Equivalent to\n                        `/.{1}/` in regexp.\n`[set]`::    Matches any one character in +set+.\n                        Behaves exactly like character sets in\n                        Regexp, including set negation\n                        (`[^a-z]`).\n`\`::        Escapes the next metacharacter.\n\n<i>flags</i> is a bitwise OR of the `FNM_xxx`\nparameters. The same glob pattern and flags are used by\n`Dir::glob`.\n\n   File.fnmatch('cat',       'cat')        #=> true  # match entire string\n   File.fnmatch('cat',       'category')   #=> false # only match partial\n   string\n   File.fnmatch('c{at,ub}s', 'cats')       #=> false # { } isn't supported\n\n   File.fnmatch('c?t',     'cat')          #=> true  # '?' match only\n   1 character\n   File.fnmatch('c??t',    'cat')          #=> false # ditto\n   File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more\n   characters\n   File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto\n   File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket\n   expression\n   File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket\n   expression ('^' or '!')\n\n   File.fnmatch('cat', 'CAT')                     #=> false # case sensitive\n   File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive\n\n   File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't\n   match '/' on FNM_PATHNAME\n   File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto\n   File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto\n\n   File.fnmatch('\?',   '?')                       #=> true  # escaped\n   wildcard becomes ordinary\n   File.fnmatch('\a',   'a')                       #=> true  # escaped\n   ordinary remains ordinary\n   File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESACPE\n   makes '\' ordinary\n   File.fnmatch('[\?]', '?')                       #=> true  # can escape\n   inside bracket expression\n\n   File.fnmatch('*',   '.profile')                      #=> false # wildcard\n   doesn't match leading\n   File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period\n   by default.\n   File.fnmatch('.*',  '.profile')                      #=> true\n\n   rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write\n   in single string.\n   File.fnmatch(rbfiles, 'main.rb')                    #=> false\n   File.fnmatch(rbfiles, './main.rb')                  #=> false\n   File.fnmatch(rbfiles, 'lib/song.rb')                #=> true\n   File.fnmatch('**.rb', 'main.rb')                    #=> true\n   File.fnmatch('**.rb', './main.rb')                  #=> false\n   File.fnmatch('**.rb', 'lib/song.rb')                #=> true\n   File.fnmatch('*',           'dave/.profile')                      #=> true\n\n   pattern = '*' '/' '*'\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME |\n   File::FNM_DOTMATCH) #=> true\n\n   pattern = '**' '/' 'foo'\n   File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true\n   File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true\n   File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH)\n   #=> true\n
ftype File.ftype(p1)\nIdentifies the type of the named file; the return string is one of\n```file`'', ```directory`'',\n```characterSpecial`'', ```blockSpecial`'',\n```fifo`'', ```link`'',\n```socket`'', or ```unknown`''.\n\n   File.ftype("testfile")            #=> "file"\n   File.ftype("/dev/tty")            #=> "characterSpecial"\n   File.ftype("/tmp/.X11-unix/X0")   #=> "socket"\n
grpowned? File.grpowned?(p1)\nReturns `true` if the named file exists and the\neffective group id of the calling process is the owner of\nthe file. Returns `false` on Windows.\n
identical? File.identical?(p1, p2)\nReturns `true` if the named files are identical.\n\n    open("a", "w") {}\n    p File.identical?("a", "a")      #=> true\n    p File.identical?("a", "./a")    #=> true\n    File.link("a", "b")\n    p File.identical?("a", "b")      #=> true\n    File.symlink("a", "c")\n    p File.identical?("a", "c")      #=> true\n    open("d", "w") {}\n    p File.identical?("a", "d")      #=> false\n
join File.join(...)\nReturns a new string formed by joining the strings using\n`File::SEPARATOR`.\n\n   File.join("usr", "mail", "gumby")   #=> "usr/mail/gumby"\n
lchmod File.lchmod(...)\nEquivalent to `File::chmod`, but does not follow symbolic\nlinks (so it will change the permissions associated with the link,\nnot the file referenced by the link). Often not available.\n
lchown File.lchown(...)\nEquivalent to `File::chown`, but does not follow symbolic\nlinks (so it will change the owner associated with the link, not the\nfile referenced by the link). Often not available. Returns number\nof files in the argument list.\n
link File.link(p1, p2)\nCreates a new name for an existing file using a hard link. Will not\noverwrite <i>new_name</i> if it already exists (raising a subclass\nof `SystemCallError`). Not available on all platforms.\n\n   File.link("testfile", ".testfile")   #=> 0\n   IO.readlines(".testfile")[0]         #=> "This is line one\\n"\n
lstat File.lstat(p1)\nSame as `File::stat`, but does not follow the last symbolic\nlink. Instead, reports on the link itself.\n\n   File.symlink("testfile", "link2test")   #=> 0\n   File.stat("testfile").size              #=> 66\n   File.lstat("link2test").size            #=> 8\n   File.stat("link2test").size             #=> 66\n
mtime File.mtime(p1)\nReturns the modification time for the named file as a Time object.\n\n   File.mtime("testfile")   #=> Tue Apr 08 12:58:04 CDT 2003\n
new File.new(...)\nOpens the file named by _filename_ according to\n_mode_ (default is ``r'') and returns a new\n`File` object.\n\n=== Parameters\nSee the description of class +IO+ for a description of _mode_.\nThe file mode may optionally be specified as a +Fixnum+\nby _or_-ing together the flags (O_RDONLY etc,\nagain described under +IO+).\n\nOptional permission bits may be given in _perm_.\nThese mode and permission bits are platform dependent;\non Unix systems, see `open(2)` for details.\n\nOptional _opt_ parameter is same as in <code.IO.open`.\n\n=== Examples\n\n   f = File.new("testfile", "r")\n   f = File.new("newfile",  "w+")\n   f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)\n
open File.open(...)\nWith no associated block, `open` is a synonym for\n`File.new`. If the optional code block is given, it will\nbe passed <i>file</i> as an argument, and the File object will\nautomatically be closed when the block terminates. In this instance,\n`File.open` returns the value of the block.\n
owned? File.owned?(p1)\nReturns `true` if the named file exists and the\neffective used id of the calling process is the owner of\nthe file.\n
path File.path(p1)\nReturns the string representation of the path\n\n   File.path("/dev/null")          #=> "/dev/null"\n   File.path(Pathname.new("/tmp")) #=> "/tmp"\n
pipe? File.pipe?(p1)\nReturns `true` if the named file is a pipe.\n
readable? File.readable?(p1)\nReturns `true` if the named file is readable by the effective\nuser id of this process.\n
readable_real? File.readable_real?(p1)\nReturns `true` if the named file is readable by the real\nuser id of this process.\n
readlink File.readlink(p1)\nReturns the name of the file referenced by the given link.\nNot available on all platforms.\n\n   File.symlink("testfile", "link2test")   #=> 0\n   File.readlink("link2test")              #=> "testfile"\n
realdirpath File.realdirpath(...)\nReturns the real (absolute) pathname of _pathname_ in the actual filesystem.\nThe real pathname doesn't contain symlinks or useless dots.\n\nIf _dir_string_ is given, it is used as a base directory\nfor interpreting relative pathname instead of the current directory.\n\nThe last component of the real pathname can be nonexistent.\n
realpath File.realpath(...)\nReturns the real (absolute) pathname of _pathname_ in the actual\nfilesystem not containing symlinks or useless dots.\n\nIf _dir_string_ is given, it is used as a base directory\nfor interpreting relative pathname instead of the current directory.\n\nAll components of the pathname must exist when this method is\ncalled.\n
rename File.rename(p1, p2)\nRenames the given file to the new name. Raises a\n`SystemCallError` if the file cannot be renamed.\n\n   File.rename("afile", "afile.bak")   #=> 0\n
setgid? File.setgid?(p1)\nReturns `true` if the named file has the setgid bit set.\n
setuid? File.setuid?(p1)\nReturns `true` if the named file has the setuid bit set.\n
size File.size(p1)\nReturns the size of `file_name`.\n
size? File.size?(p1)\nReturns +nil+ if +file_name+ doesn't exist or has zero size, the size of the\nfile otherwise.\n
socket? File.socket?(p1)\nReturns `true` if the named file is a socket.\n
split File.split(p1)\nSplits the given string into a directory and a file component and\nreturns them in a two-element array. See also\n`File::dirname` and `File::basename`.\n\n   File.split("/home/gumby/.profile")   #=> ["/home/gumby", ".profile"]\n
stat File.stat(p1)\nReturns a `File::Stat` object for the named file (see\n`File::Stat`).\n\n   File.stat("testfile").mtime   #=> Tue Apr 08 12:58:04 CDT 2003\n
sticky? File.sticky?(p1)\nReturns `true` if the named file has the sticky bit set.\n
symlink File.symlink(p1, p2)\nCreates a symbolic link called <i>new_name</i> for the existing file\n<i>old_name</i>. Raises a `NotImplemented` exception on\nplatforms that do not support symbolic links.\n\n   File.symlink("testfile", "link2test")   #=> 0\n
symlink? File.symlink?(p1)\nReturns `true` if the named file is a symbolic link.\n
truncate File.truncate(p1, p2)\nTruncates the file <i>file_name</i> to be at most <i>integer</i>\nbytes long. Not available on all platforms.\n\n   f = File.new("out", "w")\n   f.write("1234567890")     #=> 10\n   f.close                   #=> nil\n   File.truncate("out", 5)   #=> 0\n   File.size("out")          #=> 5\n
umask File.umask(...)\nReturns the current umask value for this process. If the optional\nargument is given, set the umask to that value and return the\nprevious value. Umask values are <em>subtracted</em> from the\ndefault permissions, so a umask of `0222` would make a\nfile read-only for everyone.\n\n   File.umask(0006)   #=> 18\n   File.umask         #=> 6\n
unlink File.unlink(...)\nDeletes the named files, returning the number of names\npassed as arguments. Raises an exception on any error.\nSee also `Dir::rmdir`.\n
utime File.utime(...)\nSets the access and modification times of each\nnamed file to the first two arguments. Returns\nthe number of file names in the argument list.\n
world_readable? File.world_readable?(p1)\nIf <i>file_name</i> is readable by others, returns an integer\nrepresenting the file permission bits of <i>file_name</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   File.world_readable?("/etc/passwd")           #=> 420\n   m = File.world_readable?("/etc/passwd")\n   sprintf("%o", m)                              #=> "644"\n
world_writable? File.world_writable?(p1)\nIf <i>file_name</i> is writable by others, returns an integer\nrepresenting the file permission bits of <i>file_name</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   File.world_writable?("/tmp")                  #=> 511\n   m = File.world_writable?("/tmp")\n   sprintf("%o", m)                              #=> "777"\n
writable? File.writable?(p1)\nReturns `true` if the named file is writable by the effective\nuser id of this process.\n
writable_real? File.writable_real?(p1)\nReturns `true` if the named file is writable by the real\nuser id of this process.\n
zero? File.zero?(p1)\nReturns `true` if the named file exists and has\na zero size.\n
atime File.atime()\nReturns the last access time (a `Time` object)\n for <i>file</i>, or epoch if <i>file</i> has not been accessed.\n\n   File.new("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969\n
chmod File.chmod(p1)\nChanges permission bits on <i>file</i> to the bit pattern\nrepresented by <i>mode_int</i>. Actual effects are platform\ndependent; on Unix systems, see `chmod(2)` for details.\nFollows symbolic links. Also see `File#lchmod`.\n\n   f = File.new("out", "w");\n   f.chmod(0644)   #=> 0\n
chown File.chown(p1, p2)\nChanges the owner and group of <i>file</i> to the given numeric\nowner and group id's. Only a process with superuser privileges may\nchange the owner of a file. The current owner of a file may change\nthe file's group to any group to which the owner belongs. A\n`nil` or -1 owner or group id is ignored. Follows\nsymbolic links. See also `File#lchown`.\n\n   File.new("testfile").chown(502, 1000)\n
ctime File.ctime()\nReturns the change time for <i>file</i> (that is, the time directory\ninformation about the file was changed, not the file itself).\n\n   File.new("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003\n
flock File.flock(p1)\nLocks or unlocks a file according to <i>locking_constant</i> (a\nlogical <em>or</em> of the values in the table below).\nReturns `false` if `File::LOCK_NB` is\nspecified and the operation would otherwise have blocked. Not\navailable on all platforms.\n\nLocking constants (in class File):\n\n   LOCK_EX   | Exclusive lock. Only one process may hold an\n             | exclusive lock for a given file at a time.\n   ----------+------------------------------------------------\n   LOCK_NB   | Don't block when locking. May be combined\n             | with other lock options using logical or.\n   ----------+------------------------------------------------\n   LOCK_SH   | Shared lock. Multiple processes may each hold a\n             | shared lock for a given file at the same time.\n   ----------+------------------------------------------------\n   LOCK_UN   | Unlock.\n\nExample:\n update a counter using write lock\n don't use "w" because it truncates the file before lock.\n   File.open("counter", File::RDWR|File::CREAT, 0644) {|f|\n     f.flock(File::LOCK_EX)\n     value = f.read.to_i + 1\n     f.rewind\n     f.write("#{value}\\n")\n     f.flush\n     f.truncate(f.pos)\n   }\n read the counter using read lock\n   File.open("counter", "r") {|f|\n     f.flock(File::LOCK_SH)\n     p f.read\n   }\n
lstat File.lstat()\nSame as `IO#stat`, but does not follow the last symbolic\nlink. Instead, reports on the link itself.\n\n   File.symlink("testfile", "link2test")   #=> 0\n   File.stat("testfile").size              #=> 66\n   f = File.new("link2test")\n   f.lstat.size                            #=> 8\n   f.stat.size                             #=> 66\n
mtime File.mtime()\nReturns the modification time for <i>file</i>.\n\n   File.new("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003\n
path File.path()\nReturns the pathname used to create <i>file</i> as a string. Does\nnot normalize the name.\n\n   File.new("testfile").path               #=> "testfile"\n   File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"\n
size File.size()\nReturns the size of <i>file</i> in bytes.\n\n   File.new("testfile").size   #=> 66\n
to_path File.to_path()\nReturns the pathname used to create <i>file</i> as a string. Does\nnot normalize the name.\n\n   File.new("testfile").path               #=> "testfile"\n   File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"\n
truncate File.truncate(p1)\nTruncates <i>file</i> to at most <i>integer</i> bytes. The file\nmust be opened for writing. Not available on all platforms.\n\n   f = File.new("out", "w")\n   f.syswrite("1234567890")   #=> 10\n   f.truncate(5)              #=> 0\n   f.close()                  #=> nil\n   File.size("out")           #=> 5\n
new File::Stat.new(p1)\n  File::Stat.new(file_name)  -> stat\n\nCreate a File::Stat object for the given file name (raising an\nexception if the file doesn't exist).\n
atime File::Stat.atime()\nReturns the last access time for this file as an object of class\n`Time`.\n\n   File.stat("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969\n
blksize File::Stat.blksize()\nReturns the native file system's block size. Will return `nil`\non platforms that don't support this information.\n\n   File.stat("testfile").blksize   #=> 4096\n
blockdev? File::Stat.blockdev?()\nReturns `true` if the file is a block device,\n`false` if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").blockdev?    #=> false\n   File.stat("/dev/hda1").blockdev?   #=> true\n
blocks File::Stat.blocks()\nReturns the number of native file system blocks allocated for this\nfile, or `nil` if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").blocks   #=> 2\n
chardev? File::Stat.chardev?()\nReturns `true` if the file is a character device,\n`false` if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("/dev/tty").chardev?   #=> true\n
ctime File::Stat.ctime()\nReturns the change time for <i>stat</i> (that is, the time\ndirectory information about the file was changed, not the file\nitself).\n\n   File.stat("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003\n
dev File::Stat.dev()\nReturns an integer representing the device on which <i>stat</i>\nresides.\n\n   File.stat("testfile").dev   #=> 774\n
dev_major File::Stat.dev_major()\nReturns the major part of `File_Stat#dev` or\n`nil`.\n\n   File.stat("/dev/fd1").dev_major   #=> 2\n   File.stat("/dev/tty").dev_major   #=> 5\n
dev_minor File::Stat.dev_minor()\nReturns the minor part of `File_Stat#dev` or\n`nil`.\n\n   File.stat("/dev/fd1").dev_minor   #=> 1\n   File.stat("/dev/tty").dev_minor   #=> 0\n
directory? File::Stat.directory?()\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
executable? File::Stat.executable?()\nReturns `true` if <i>stat</i> is executable or if the\noperating system doesn't distinguish executable files from\nnonexecutable files. The tests are made using the effective owner of\nthe process.\n\n   File.stat("testfile").executable?   #=> false\n
executable_real? File::Stat.executable_real?()\nSame as `executable?`, but tests using the real owner of\nthe process.\n
file? File::Stat.file?()\nReturns `true` if <i>stat</i> is a regular file (not\na device file, pipe, socket, etc.).\n\n   File.stat("testfile").file?   #=> true\n
ftype File::Stat.ftype()\nIdentifies the type of <i>stat</i>. The return string is one of:\n```file`'', ```directory`'',\n```characterSpecial`'', ```blockSpecial`'',\n```fifo`'', ```link`'',\n```socket`'', or ```unknown`''.\n\n   File.stat("/dev/tty").ftype   #=> "characterSpecial"\n
gid File::Stat.gid()\nReturns the numeric group id of the owner of <i>stat</i>.\n\n   File.stat("testfile").gid   #=> 500\n
grpowned? File::Stat.grpowned?()\nReturns true if the effective group id of the process is the same as\nthe group id of <i>stat</i>. On Windows NT, returns `false`.\n\n   File.stat("testfile").grpowned?      #=> true\n   File.stat("/etc/passwd").grpowned?   #=> false\n
ino File::Stat.ino()\nReturns the inode number for <i>stat</i>.\n\n   File.stat("testfile").ino   #=> 1083669\n
inspect File::Stat.inspect()\nProduce a nicely formatted description of <i>stat</i>.\n\n  File.stat("/etc/passwd").inspect\n=> "#<File::Stat dev=0xe000005, ino=1078078, mode=0100644,\n    nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,\n    blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,\n    mtime=Fri Sep 12 15:41:41 CDT 2003,\n    ctime=Mon Oct 27 11:20:27 CST 2003>"\n
mode File::Stat.mode()\nReturns an integer representing the permission bits of\n<i>stat</i>. The meaning of the bits is platform dependent; on\nUnix systems, see `stat(2)`.\n\n   File.chmod(0644, "testfile")   #=> 1\n   s = File.stat("testfile")\n   sprintf("%o", s.mode)          #=> "100644"\n
mtime File::Stat.mtime()\nReturns the modification time of <i>stat</i>.\n\n   File.stat("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003\n
nlink File::Stat.nlink()\nReturns the number of hard links to <i>stat</i>.\n\n   File.stat("testfile").nlink             #=> 1\n   File.link("testfile", "testfile.bak")   #=> 0\n   File.stat("testfile").nlink             #=> 2\n
owned? File::Stat.owned?()\nReturns `true` if the effective user id of the process is\nthe same as the owner of <i>stat</i>.\n\n   File.stat("testfile").owned?      #=> true\n   File.stat("/etc/passwd").owned?   #=> false\n
pipe? File::Stat.pipe?()\nReturns `true` if the operating system supports pipes and\n<i>stat</i> is a pipe; `false` otherwise.\n
rdev File::Stat.rdev()\nReturns an integer representing the device type on which\n<i>stat</i> resides. Returns `nil` if the operating\nsystem doesn't support this feature.\n\n   File.stat("/dev/fd1").rdev   #=> 513\n   File.stat("/dev/tty").rdev   #=> 1280\n
rdev_major File::Stat.rdev_major()\nReturns the major part of `File_Stat#rdev` or\n`nil`.\n\n   File.stat("/dev/fd1").rdev_major   #=> 2\n   File.stat("/dev/tty").rdev_major   #=> 5\n
rdev_minor File::Stat.rdev_minor()\nReturns the minor part of `File_Stat#rdev` or\n`nil`.\n\n   File.stat("/dev/fd1").rdev_minor   #=> 1\n   File.stat("/dev/tty").rdev_minor   #=> 0\n
readable? File::Stat.readable?()\nReturns `true` if <i>stat</i> is readable by the\neffective user id of this process.\n\n   File.stat("testfile").readable?   #=> true\n
readable_real? File::Stat.readable_real?()\nReturns `true` if <i>stat</i> is readable by the real\nuser id of this process.\n\n   File.stat("testfile").readable_real?   #=> true\n
setgid? File::Stat.setgid?()\nReturns `true` if <i>stat</i> has the set-group-id\npermission bit set, `false` if it doesn't or if the\noperating system doesn't support this feature.\n\n   File.stat("/usr/sbin/lpc").setgid?   #=> true\n
setuid? File::Stat.setuid?()\nReturns `true` if <i>stat</i> has the set-user-id\npermission bit set, `false` if it doesn't or if the\noperating system doesn't support this feature.\n\n   File.stat("/bin/su").setuid?   #=> true\n
size File::Stat.size()\nReturns the size of <i>stat</i> in bytes.\n\n   File.stat("testfile").size   #=> 66\n
size? File::Stat.size?()\nReturns the size of <i>stat</i> in bytes.\n\n   File.stat("testfile").size   #=> 66\n
socket? File::Stat.socket?()\nReturns `true` if <i>stat</i> is a socket,\n`false` if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").socket?   #=> false\n
sticky? File::Stat.sticky?()\nReturns `true` if <i>stat</i> has its sticky bit set,\n`false` if it doesn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").sticky?   #=> false\n
symlink? File::Stat.symlink?()\nReturns `true` if <i>stat</i> is a symbolic link,\n`false` if it isn't or if the operating system doesn't\nsupport this feature. As `File::stat` automatically\nfollows symbolic links, `symlink?` will always be\n`false` for an object returned by\n`File::stat`.\n\n   File.symlink("testfile", "alink")   #=> 0\n   File.stat("alink").symlink?         #=> false\n   File.lstat("alink").symlink?        #=> true\n
uid File::Stat.uid()\nReturns the numeric user id of the owner of <i>stat</i>.\n\n   File.stat("testfile").uid   #=> 501\n
world_readable? File::Stat.world_readable?()\nIf <i>stat</i> is readable by others, returns an integer\nrepresenting the file permission bits of <i>stat</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   m = File.stat("/etc/passwd").world_readable?  #=> 420\n   sprintf("%o", m)                              #=> "644"\n
world_writable? File::Stat.world_writable?()\nIf <i>stat</i> is writable by others, returns an integer\nrepresenting the file permission bits of <i>stat</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   m = File.stat("/tmp").world_writable?         #=> 511\n   sprintf("%o", m)                              #=> "777"\n
writable? File::Stat.writable?()\nReturns `true` if <i>stat</i> is writable by the\neffective user id of this process.\n\n   File.stat("testfile").writable?   #=> true\n
writable_real? File::Stat.writable_real?()\nReturns `true` if <i>stat</i> is writable by the real\nuser id of this process.\n\n   File.stat("testfile").writable_real?   #=> true\n
zero? File::Stat.zero?()\nReturns `true` if <i>stat</i> is a zero-length file;\n`false` otherwise.\n\n   File.stat("testfile").zero?   #=> false\n
aliases Encoding.aliases()\nReturns the hash of available encoding alias and original encoding name.\n\n  Encoding.aliases\n=> {"BINARY"=>"ASCII-8BIT", "ASCII"=>"US-ASCII", "ANSI_X3.4-1986"=>"US-ASCII",\n        "SJIS"=>"Shift_JIS", "eucJP"=>"EUC-JP", "CP932"=>"Windows-31J"}\n
compatible? Encoding.compatible?(p1, p2)\nChecks the compatibility of two strings.\nIf they are compatible, means concatenatable,\nreturns an encoding which the concatenated string will be.\nIf they are not compatible, nil is returned.\n\n  Encoding.compatible?("\xa1".force_encoding("iso-8859-1"), "b")\n=> #<Encoding:ISO-8859-1>\n\n  Encoding.compatible?(\n    "\xa1".force_encoding("iso-8859-1"),\n    "\xa1\xa1".force_encoding("euc-jp"))\n=> nil\n
default_external Encoding.default_external()\nReturns default external encoding.\n\nIt is initialized by the locale or -E option.\n
default_external= Encoding.default_external=(p1)\nSets default external encoding.\n
default_internal Encoding.default_internal()\nReturns default internal encoding.\n\nIt is initialized by the source internal_encoding or -E option.\n
default_internal= Encoding.default_internal=(p1)\nSets default internal encoding.\nOr removes default internal encoding when passed nil.\n
find Encoding.find(p1)\nSearch the encoding with specified <i>name</i>.\n<i>name</i> should be a string or symbol.\n\n  Encoding.find("US-ASCII")  #=> #<Encoding:US-ASCII>\n  Encoding.find(:Shift_JIS)  #=> #<Encoding:Shift_JIS>\n\nNames which this method accept are encoding names and aliases\nincluding following special aliases\n\n"external"::   default external encoding\n"internal"::   default internal encoding\n"locale"::     locale encoding\n"filesystem":: filesystem encoding\n\nAn ArgumentError is raised when no encoding with <i>name</i>.\nOnly `Encoding.find("internal")` however returns nil\nwhen no encoding named "internal", in other words, when Ruby has no\ndefault internal encoding.\n
list Encoding.list()\nReturns the list of loaded encodings.\n\n  Encoding.list\n=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,\n<Encoding:ISO-2022-JP (dummy)>]\n\n  Encoding.find("US-ASCII")\n=> #<Encoding:US-ASCII>\n\n  Encoding.list\n=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,\n<Encoding:US-ASCII>, #<Encoding:ISO-2022-JP (dummy)>]\n
locale_charmap Encoding.locale_charmap()\nReturns the locale charmap name.\n\n  Debian GNU/Linux\n    LANG=C\n      Encoding.locale_charmap  #=> "ANSI_X3.4-1968"\n    LANG=ja_JP.EUC-JP\n      Encoding.locale_charmap  #=> "EUC-JP"\n\n  SunOS 5\n    LANG=C\n      Encoding.locale_charmap  #=> "646"\n    LANG=ja\n      Encoding.locale_charmap  #=> "eucJP"\n\nThe result is highly platform dependent.\nSo Encoding.find(Encoding.locale_charmap) may cause an error.\nIf you need some encoding object even for unknown locale,\nEncoding.find("locale") can be used.\n
name_list Encoding.name_list()\nReturns the list of available encoding names.\n\n  Encoding.name_list\n=> ["US-ASCII", "ASCII-8BIT", "UTF-8",\n        "ISO-8859-1", "Shift_JIS", "EUC-JP",\n        "Windows-31J",\n        "BINARY", "CP932", "eucJP"]\n
ascii_compatible? Encoding.ascii_compatible?()\nReturns whether ASCII-compatible or not.\n\n  Encoding::UTF_8.ascii_compatible?     #=> true\n  Encoding::UTF_16BE.ascii_compatible?  #=> false\n
dummy? Encoding.dummy?()\nReturns true for dummy encodings.\nA dummy encoding is an encoding for which character handling is not properly\nimplemented.\nIt is used for stateful encodings.\n\n  Encoding::ISO_2022_JP.dummy?       #=> true\n  Encoding::UTF_8.dummy?             #=> false\n
inspect Encoding.inspect()\nReturns a string which represents the encoding for programmers.\n\n  Encoding::UTF_8.inspect       #=> "#<Encoding:UTF-8>"\n  Encoding::ISO_2022_JP.inspect #=> "#<Encoding:ISO-2022-JP (dummy)>"\n
name Encoding.name()\nReturns the name of the encoding.\n\n  Encoding::UTF_8.name      #=> "UTF-8"\n
names Encoding.names()\nReturns the list of name and aliases of the encoding.\n\n  Encoding::WINDOWS_31J.names  #=> ["Windows-31J", "CP932", "csWindows31J"]\n
replicate Encoding.replicate(p1)\nReturns a replicated encoding of _enc_ whose name is _name_.\nThe new encoding should have the same byte structure of _enc_.\nIf _name_ is used by another encoding, raise ArgumentError.\n
to_s Encoding.to_s()\nReturns the name of the encoding.\n\n  Encoding::UTF_8.name      #=> "UTF-8"\n
asciicompat_encoding Encoding::Converter.asciicompat_encoding(p1)\nReturns the corresponding ASCII compatible encoding.\n\nReturns nil if the argument is an ASCII compatible encoding.\n\n"corresponding ASCII compatible encoding" is a ASCII compatible encoding which\ncan represents exactly the same characters as the given ASCII incompatible\nencoding.\nSo, no conversion undefined error occurs when converting between the two\nencodings.\n\n  Encoding::Converter.asciicompat_encoding("ISO-2022-JP") #=>\n  #<Encoding:stateless-ISO-2022-JP>\n  Encoding::Converter.asciicompat_encoding("UTF-16BE") #=> #<Encoding:UTF-8>\n  Encoding::Converter.asciicompat_encoding("UTF-8") #=> nil\n
new Encoding::Converter.new(...)\npossible options elements:\n  hash form:\n    :invalid => nil            # raise error on invalid byte sequence (default)\n    :invalid => :replace       # replace invalid byte sequence\n    :undef => nil              # raise error on undefined conversion (default)\n    :undef => :replace         # replace undefined conversion\n    :replace => string         # replacement string ("?" or "\uFFFD" if\n    not specified)\n    :universal_newline => true # decorator for converting CRLF and CR to LF\n    :crlf_newline => true      # decorator for converting LF to CRLF\n    :cr_newline => true        # decorator for converting LF to CR\n    :xml => :text              # escape as XML CharData.\n    :xml => :attr              # escape as XML AttValue\n  integer form:\n    Encoding::Converter::INVALID_REPLACE\n    Encoding::Converter::UNDEF_REPLACE\n    Encoding::Converter::UNDEF_HEX_CHARREF\n    Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR\n    Encoding::Converter::CRLF_NEWLINE_DECORATOR\n    Encoding::Converter::CR_NEWLINE_DECORATOR\n    Encoding::Converter::XML_TEXT_DECORATOR\n    Encoding::Converter::XML_ATTR_CONTENT_DECORATOR\n    Encoding::Converter::XML_ATTR_QUOTE_DECORATOR\n\nEncoding::Converter.new creates an instance of Encoding::Converter.\n\nSource_encoding and destination_encoding should be a string or\nEncoding object.\n\nopt should be nil, a hash or an integer.\n\nconvpath should be an array.\nconvpath may contain\n- two-element arrays which contain encodings or encoding names, or\n- strings representing decorator names.\n\nEncoding::Converter.new optionally takes an option.\nThe option should be a hash or an integer.\nThe option hash can contain :invalid => nil, etc.\nThe option integer should be logical-or of constants such as\nEncoding::Converter::INVALID_REPLACE, etc.\n\n[:invalid => nil]\n  Raise error on invalid byte sequence.  This is a default behavior.\n[:invalid => :replace]\n  Replace invalid byte sequence by replacement string.\n[:undef => nil]\n  Raise an error if a character in source_encoding is not defined in\n  destination_encoding.\n  This is a default behavior.\n[:undef => :replace]\n  Replace undefined character in destination_encoding with replacement string.\n[:replace => string]\n  Specify the replacement string.\n  If not specified, "\uFFFD" is used for Unicode encodings and "?" for others.\n[:universal_newline => true]\n  Convert CRLF and CR to LF.\n[:crlf_newline => true]\n  Convert LF to CRLF.\n[:cr_newline => true]\n  Convert LF to CR.\n[:xml => :text]\n  Escape as XML CharData.\n  This form can be used as a HTML 4.0 #PCDATA.\n  - '&' -> '&amp;'\n  - '<' -> '&lt;'\n  - '>' -> '&gt;'\n  - undefined characters in destination_encoding -> hexadecimal CharRef such\n  as &#xHH;\n[:xml => :attr]\n  Escape as XML AttValue.\n  The converted result is quoted as "...".\n  This form can be used as a HTML 4.0 attribute value.\n  - '&' -> '&amp;'\n  - '<' -> '&lt;'\n  - '>' -> '&gt;'\n  - '"' -> '&quot;'\n  - undefined characters in destination_encoding -> hexadecimal CharRef such\n  as &#xHH;\n\nExamples:\n UTF-16BE to UTF-8\n  ec = Encoding::Converter.new("UTF-16BE", "UTF-8")\n Usually, decorators such as newline conversion are inserted last.\n  ec = Encoding::Converter.new("UTF-16BE", "UTF-8", :universal_newline => true)\n  p ec.convpath #=> [[#<Encoding:UTF-16BE>, #<Encoding:UTF-8>],\n    "universal_newline"]\n But, if the last encoding is ASCII incompatible,\n decorators are inserted before the last conversion.\n  ec = Encoding::Converter.new("UTF-8", "UTF-16BE", :crlf_newline => true)\n  p ec.convpath #=> ["crlf_newline",\n    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]\n Conversion path can be specified directly.\n  ec = Encoding::Converter.new(["universal_newline", ["EUC-JP", "UTF-8"],\n  ["UTF-8", "UTF-16BE"]])\n  p ec.convpath #=> ["universal_newline",\n    [#<Encoding:EUC-JP>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]\n
search_convpath Encoding::Converter.search_convpath(...)\nReturns a conversion path.\n\n p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP")\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>]]\n\n p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP",\n universal_newline: true)\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],\n    "universal_newline"]\n\n p Encoding::Converter.search_convpath("ISO-8859-1", "UTF-32BE",\n universal_newline: true)\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    "universal_newline",\n    [#<Encoding:UTF-8>, #<Encoding:UTF-32BE>]]\n
convert Encoding::Converter.convert(p1)\nConvert source_string and return destination_string.\n\nsource_string is assumed as a part of source.\ni.e.  :partial_input=>true is specified internally.\nfinish method should be used last.\n\n  ec = Encoding::Converter.new("utf-8", "euc-jp")\n  puts ec.convert("\u3042").dump     #=> "\xA4\xA2"\n  puts ec.finish.dump                #=> ""\n\n  ec = Encoding::Converter.new("euc-jp", "utf-8")\n  puts ec.convert("\xA4").dump       #=> ""\n  puts ec.convert("\xA2").dump       #=> "\xE3\x81\x82"\n  puts ec.finish.dump                #=> ""\n\n  ec = Encoding::Converter.new("utf-8", "iso-2022-jp")\n  puts ec.convert("\xE3").dump       #=> "".force_encoding("ISO-2022-JP")\n  puts ec.convert("\x81").dump       #=> "".force_encoding("ISO-2022-JP")\n  puts ec.convert("\x82").dump       #=>\n  "\e$B$\"".force_encoding("ISO-2022-JP")\n  puts ec.finish.dump                #=> "\e(B".force_encoding("ISO-2022-JP")\n\nIf a conversion error occur,\nEncoding::UndefinedConversionError or\nEncoding::InvalidByteSequenceError is raised.\nEncoding::Converter#convert doesn't supply methods to recover or restart\nfrom these exceptions.\nWhen you want to handle these conversion errors,\nuse Encoding::Converter#primitive_convert.\n
convpath Encoding::Converter.convpath()\nReturns the conversion path of ec.\n\nThe result is an array of conversions.\n\n  ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP", crlf_newline: true)\n  p ec.convpath\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],\n    "crlf_newline"]\n\nEach element of the array is a pair of encodings or a string.\nA pair means an encoding conversion.\nA string means a decorator.\n\nIn the above example, [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>] means\na converter from ISO-8859-1 to UTF-8.\n"crlf_newline" means newline converter from LF to CRLF.\n
destination_encoding Encoding::Converter.destination_encoding()\nReturns the destination encoding as an Encoding object.\n
finish Encoding::Converter.finish()\nFinishes the converter.\nIt returns the last part of the converted string.\n\n  ec = Encoding::Converter.new("utf-8", "iso-2022-jp")\n  p ec.convert("\u3042")     #=> "\e$B$\""\n  p ec.finish                #=> "\e(B"\n
insert_output Encoding::Converter.insert_output(p1)\nInserts string into the encoding converter.\nThe string will be converted to the destination encoding and\noutput on later conversions.\n\nIf the destination encoding is stateful,\nstring is converted according to the state and the state is updated.\n\nThis method should be used only when a conversion error occurs.\n\n ec = Encoding::Converter.new("utf-8", "iso-8859-1")\n src = "HIRAGANA LETTER A is \u{3042}."\n dst = ""\n p ec.primitive_convert(src, dst)    #=> :undefined_conversion\n puts "[#{dst.dump}, #{src.dump}]"   #=> ["HIRAGANA LETTER A is ", "."]\n ec.insert_output("<err>")\n p ec.primitive_convert(src, dst)    #=> :finished\n puts "[#{dst.dump}, #{src.dump}]"   #=> ["HIRAGANA LETTER A is <err>.", ""]\n\n ec = Encoding::Converter.new("utf-8", "iso-2022-jp")\n src = "\u{306F 3041 3068 2661 3002}" # U+2661 is not representable in\n iso-2022-jp\n dst = ""\n p ec.primitive_convert(src, dst)    #=> :undefined_conversion\n puts "[#{dst.dump}, #{src.dump}]"   #=>\n ["\e$B$O$!$H".force_encoding("ISO-2022-JP"), "\xE3\x80\x82"]\n ec.insert_output "?"                # state change required to output "?".\n p ec.primitive_convert(src, dst)    #=> :finished\n puts "[#{dst.dump}, #{src.dump}]"   #=>\n ["\e$B$O$!$H\e(B?\e$B!#\e(B".force_encoding("ISO-2022-JP"), ""]\n
inspect Encoding::Converter.inspect()\nReturns a printable version of <i>ec</i>\n\n  ec = Encoding::Converter.new("iso-8859-1", "utf-8")\n  puts ec.inspect    #=> #<Encoding::Converter: ISO-8859-1 to UTF-8>\n
last_error Encoding::Converter.last_error()\nReturns an exception object for the last conversion.\nReturns nil if the last conversion did not produce an error.\n\n"error" means that\nEncoding::InvalidByteSequenceError and Encoding::UndefinedConversionError for\nEncoding::Converter#convert and\n:invalid_byte_sequence, :incomplete_input and :undefined_conversion for\nEncoding::Converter#primitive_convert.\n\n ec = Encoding::Converter.new("utf-8", "iso-8859-1")\n p ec.primitive_convert(src="\xf1abcd", dst="")       #=>\n :invalid_byte_sequence\n p ec.last_error      #=> #<Encoding::InvalidByteSequenceError: "\xF1"\n followed by "a" on UTF-8>\n p ec.primitive_convert(src, dst, nil, 1)             #=>\n :destination_buffer_full\n p ec.last_error      #=> nil\n
primitive_convert Encoding::Converter.primitive_convert(...)\npossible opt elements:\n  hash form:\n    :partial_input => true           # source buffer may be part of larger\n    source\n    :after_output => true            # stop conversion after output before\n    input\n  integer form:\n    Encoding::Converter::PARTIAL_INPUT\n    Encoding::Converter::AFTER_OUTPUT\n\npossible results:\n   :invalid_byte_sequence\n   :incomplete_input\n   :undefined_conversion\n   :after_output\n   :destination_buffer_full\n   :source_buffer_empty\n   :finished\n\nprimitive_convert converts source_buffer into destination_buffer.\n\nsource_buffer should be a string or nil.\nnil means a empty string.\n\ndestination_buffer should be a string.\n\ndestination_byteoffset should be an integer or nil.\nnil means the end of destination_buffer.\nIf it is omitted, nil is assumed.\n\ndestination_bytesize should be an integer or nil.\nnil means unlimited.\nIf it is omitted, nil is assumed.\n\nopt should be nil, a hash or an integer.\nnil means no flags.\nIf it is omitted, nil is assumed.\n\nprimitive_convert converts the content of source_buffer from beginning\nand store the result into destination_buffer.\n\ndestination_byteoffset and destination_bytesize specify the region which\nthe converted result is stored.\ndestination_byteoffset specifies the start position in destination_buffer\nin bytes.\nIf destination_byteoffset is nil,\ndestination_buffer.bytesize is used for appending the result.\ndestination_bytesize specifies maximum number of bytes.\nIf destination_bytesize is nil,\ndestination size is unlimited.\nAfter conversion, destination_buffer is resized to\ndestination_byteoffset + actually produced number of bytes.\nAlso destination_buffer's encoding is set to destination_encoding.\n\nprimitive_convert drops the converted part of source_buffer.\nthe dropped part is converted in destination_buffer or\nbuffered in Encoding::Converter object.\n\nprimitive_convert stops conversion when one of following condition met.\n- invalid byte sequence found in source buffer (:invalid_byte_sequence)\n- unexpected end of source buffer (:incomplete_input)\n  this occur only when :partial_input is not specified.\n- character not representable in output encoding (:undefined_conversion)\n- after some output is generated, before input is done (:after_output)\n  this occur only when :after_output is specified.\n- destination buffer is full (:destination_buffer_full)\n  this occur only when destination_bytesize is non-nil.\n- source buffer is empty (:source_buffer_empty)\n  this occur only when :partial_input is specified.\n- conversion is finished (:finished)\n\nexample:\n  ec = Encoding::Converter.new("UTF-8", "UTF-16BE")\n  ret = ec.primitive_convert(src="pi", dst="", nil, 100)\n  p [ret, src, dst] #=> [:finished, "", "\x00p\x00i"]\n\n  ec = Encoding::Converter.new("UTF-8", "UTF-16BE")\n  ret = ec.primitive_convert(src="pi", dst="", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, "i", "\x00"]\n  ret = ec.primitive_convert(src, dst="", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, "", "p"]\n  ret = ec.primitive_convert(src, dst="", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, "", "\x00"]\n  ret = ec.primitive_convert(src, dst="", nil, 1)\n  p [ret, src, dst] #=> [:finished, "", "i"]\n
primitive_errinfo Encoding::Converter.primitive_errinfo()\nprimitive_errinfo returns important information regarding the last error\nas a 5-element array:\n\n  [result, enc1, enc2, error_bytes, readagain_bytes]\n\nresult is the last result of primitive_convert.\n\nOther elements are only meaningful when result is\n:invalid_byte_sequence, :incomplete_input or :undefined_conversion.\n\nenc1 and enc2 indicate a conversion step as a pair of strings.\nFor example, a converter from EUC-JP to ISO-8859-1 converts\na string as follows: EUC-JP -> UTF-8 -> ISO-8859-1.\nSo [enc1, enc2] is either ["EUC-JP", "UTF-8"] or ["UTF-8", "ISO-8859-1"].\n\nerror_bytes and readagain_bytes indicate the byte sequences which caused\nthe error.\nerror_bytes is discarded portion.\nreadagain_bytes is buffered portion which is read again on next conversion.\n\nExample:\n \xff is invalid as EUC-JP.\n  ec = Encoding::Converter.new("EUC-JP", "Shift_JIS")\n  ec.primitive_convert(src="\xff", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:invalid_byte_sequence, "EUC-JP", "UTF-8", "\xFF", ""]\n HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.\n Since this error is occur in UTF-8 to ISO-8859-1 conversion,\n error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).\n  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n  ec.primitive_convert(src="\xa4\xa2", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:undefined_conversion, "UTF-8", "ISO-8859-1", "\xE3\x81\x82", ""]\n partial character is invalid\n  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n  ec.primitive_convert(src="\xa4", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:incomplete_input, "EUC-JP", "UTF-8", "\xA4", ""]\n Encoding::Converter::PARTIAL_INPUT prevents invalid errors by\n partial characters.\n  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n  ec.primitive_convert(src="\xa4", dst="", nil, 10,\n  Encoding::Converter::PARTIAL_INPUT)\n  p ec.primitive_errinfo\n=> [:source_buffer_empty, nil, nil, nil, nil]\n \xd8\x00\x00@ is invalid as UTF-16BE because\n no low surrogate after high surrogate (\xd8\x00).\n It is detected by 3rd byte (\00) which is part of next character.\n So the high surrogate (\xd8\x00) is discarded and\n the 3rd byte is read again later.\n Since the byte is buffered in ec, it is dropped from src.\n  ec = Encoding::Converter.new("UTF-16BE", "UTF-8")\n  ec.primitive_convert(src="\xd8\x00\x00@", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:invalid_byte_sequence, "UTF-16BE", "UTF-8", "\xD8\x00", "\x00"]\n  p src\n=> "@"\n Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.\n The problem is detected by 4th byte.\n  ec = Encoding::Converter.new("UTF-16LE", "UTF-8")\n  ec.primitive_convert(src="\x00\xd8@\x00", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8", "\x00\xD8", "@\x00"]\n  p src\n=> ""\n
putback Encoding::Converter.putback(...)\ncall-seq\n  ec.putback                    -> string\n  ec.putback(max_numbytes)      -> string\n\nPut back the bytes which will be converted.\n\nThe bytes are caused by invalid_byte_sequence error.\nWhen invalid_byte_sequence error, some bytes are discarded and\nsome bytes are buffered to be converted later.\nThe latter bytes can be put back.\nIt can be observed by\nEncoding::InvalidByteSequenceError#readagain_bytes and\nEncoding::Converter#primitive_errinfo.\n\n  ec = Encoding::Converter.new("utf-16le", "iso-8859-1")\n  src = "\x00\xd8\x61\x00"\n  dst = ""\n  p ec.primitive_convert(src, dst)   #=> :invalid_byte_sequence\n  p ec.primitive_errinfo     #=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8",\n  "\x00\xD8", "a\x00"]\n  p ec.putback               #=> "a\x00"\n  p ec.putback               #=> ""          # no more bytes to put back\n
replacement Encoding::Converter.replacement()\nReturns the replacement string.\n\n ec = Encoding::Converter.new("euc-jp", "us-ascii")\n p ec.replacement    #=> "?"\n\n ec = Encoding::Converter.new("euc-jp", "utf-8")\n p ec.replacement    #=> "\uFFFD"\n
replacement= Encoding::Converter.replacement=(p1)\nSets the replacement string.\n\n ec = Encoding::Converter.new("utf-8", "us-ascii", :undef => :replace)\n ec.replacement = "<undef>"\n p ec.convert("a \u3042 b")      #=> "a <undef> b"\n
source_encoding Encoding::Converter.source_encoding()\nReturns the source encoding as an Encoding object.\n
destination_encoding Encoding::InvalidByteSequenceError.destination_encoding()\nReturns the destination encoding as an encoding object.\n
destination_encoding_name Encoding::InvalidByteSequenceError.destination_encoding_name()\nReturns the destination encoding name as a string.\n
error_bytes Encoding::InvalidByteSequenceError.error_bytes()\nReturns the discarded bytes when Encoding::InvalidByteSequenceError occurs.\n\n ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n begin\n   ec.convert("abc\xA1\xFFdef")\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by\n   "\xFF" on EUC-JP>\n   puts $!.error_bytes.dump          #=> "\xA1"\n   puts $!.readagain_bytes.dump      #=> "\xFF"\n end\n
incomplete_input? Encoding::InvalidByteSequenceError.incomplete_input?()\nReturns true if the invalid byte sequence error is caused by\npremature end of string.\n\n ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n\n begin\n   ec.convert("abc\xA1z")\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by\n   "z" on EUC-JP>\n   p $!.incomplete_input?    #=> false\n end\n\n begin\n   ec.convert("abc\xA1")\n   ec.finish\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: incomplete "\xA1"\n   on EUC-JP>\n   p $!.incomplete_input?    #=> true\n end\n
readagain_bytes Encoding::InvalidByteSequenceError.readagain_bytes()\nReturns the bytes to be read again when Encoding::InvalidByteSequenceError\noccurs.\n
source_encoding Encoding::InvalidByteSequenceError.source_encoding()\nReturns the source encoding as an encoding object.\n\nNote that the result may not be equal to the source encoding of\nthe encoding converter if the conversion has multiple steps.\n\n ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8\n -> EUC-JP\n begin\n   ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not\n   in EUC-JP.\n rescue Encoding::UndefinedConversionError\n   p $!.source_encoding              #=> #<Encoding:UTF-8>\n   p $!.destination_encoding         #=> #<Encoding:EUC-JP>\n   p $!.source_encoding_name         #=> "UTF-8"\n   p $!.destination_encoding_name    #=> "EUC-JP"\n end\n
source_encoding_name Encoding::InvalidByteSequenceError.source_encoding_name()\nReturns the source encoding name as a string.\n
destination_encoding Encoding::UndefinedConversionError.destination_encoding()\nReturns the destination encoding as an encoding object.\n
destination_encoding_name Encoding::UndefinedConversionError.destination_encoding_name()\nReturns the destination encoding name as a string.\n
error_char Encoding::UndefinedConversionError.error_char()\nReturns the one-character string which cause\nEncoding::UndefinedConversionError.\n\n ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP")\n begin\n   ec.convert("\xa0")\n rescue Encoding::UndefinedConversionError\n   puts $!.error_char.dump   #=> "\xC2\xA0"\n   p $!.error_char.encoding  #=> #<Encoding:UTF-8>\n end\n
source_encoding Encoding::UndefinedConversionError.source_encoding()\nReturns the source encoding as an encoding object.\n\nNote that the result may not be equal to the source encoding of\nthe encoding converter if the conversion has multiple steps.\n\n ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8\n -> EUC-JP\n begin\n   ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not\n   in EUC-JP.\n rescue Encoding::UndefinedConversionError\n   p $!.source_encoding              #=> #<Encoding:UTF-8>\n   p $!.destination_encoding         #=> #<Encoding:EUC-JP>\n   p $!.source_encoding_name         #=> "UTF-8"\n   p $!.destination_encoding_name    #=> "EUC-JP"\n end\n
source_encoding_name Encoding::UndefinedConversionError.source_encoding_name()\nReturns the source encoding name as a string.\n
new Enumerator.new(...)\nCreates a new Enumerator object, which is to be used as an\nEnumerable object iterating in a given way.\n\nIn the first form, a generated Enumerator iterates over the given\nobject using the given method with the given arguments passed.\nUse of this form is discouraged.  Use Kernel#enum_for(), alias\nto_enum, instead.\n\n  e = Enumerator.new(ObjectSpace, :each_object)\n-> ObjectSpace.enum_for(:each_object)\n\n  e.select { |obj| obj.is_a?(Class) }  #=> array of all classes\n\nIn the second form, iteration is defined by the given block, in\nwhich a "yielder" object given as block parameter can be used to\nyield a value by calling the +yield+ method, alias +<<+.\n\n  fib = Enumerator.new { |y|\n    a = b = 1\n    loop {\n      y << a\n      a, b = b, a + b\n    }\n  }\n\n  p fib.take(10) #=> [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n
each Enumerator.each()\nIterates the given block using the object and the method specified\nin the first place.  If no block is given, returns self.\n
each_with_index Enumerator.each_with_index()\nSame as Enumerator#with_index, except each_with_index does not\nreceive an offset argument.\n
each_with_object Enumerator.each_with_object(p1)\nIterates the given block for each element with an arbitrary\nobject given, and returns the initially given object.\n\nIf no block is given, returns an enumerator.\n
feed Enumerator.feed(p1)\nSet the value for the next yield in the enumerator returns.\n\nIf the value is not set, the yield returns nil.\n\nThis value is cleared after used.\n\n  o = Object.new\n  def o.each\n (2)\n    x = yield\n    p x          #=> "foo"\n (5)\n    x = yield\n    p x          #=> nil\n (7)\n    x = yield\n not reached\n    p x\n  end\n  e = o.to_enum\n (1)\n  e.next\n (3)\n  e.feed "foo"\n (4)\n  e.next\n (6)\n  e.next\n (8)\n
inspect Enumerator.inspect()\nCreate a printable version of <i>e</i>.\n
next Enumerator.next()\nReturns the next object in the enumerator, and move the internal\nposition forward.  When the position reached at the end, StopIteration\nis raised.\n\n  a = [1,2,3]\n  e = a.to_enum\n  p e.next   #=> 1\n  p e.next   #=> 2\n  p e.next   #=> 3\n  p e.next   #raises StopIteration\n\nNote that enumeration sequence by next method does not affect other\nnon-external enumeration methods, unless underlying iteration\nmethods itself has side-effect, e.g. IO#each_line.\n
next_values Enumerator.next_values()\nReturns the next object as an array in the enumerator,\nand move the internal position forward.\nWhen the position reached at the end, StopIteration is raised.\n\nThis method can be used to distinguish `yield` and `yield nil`.\n\n  o = Object.new\n  def o.each\n    yield\n    yield 1\n    yield 1, 2\n    yield nil\n    yield [1, 2]\n  end\n  e = o.to_enum\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  e = o.to_enum\n  p e.next\n  p e.next\n  p e.next\n  p e.next\n  p e.next\n yield args       next_values      next\n  yield            []               nil\n  yield 1          [1]              1\n  yield 1, 2       [1, 2]           [1, 2]\n  yield nil        [nil]            nil\n  yield [1, 2]     [[1, 2]]         [1, 2]\n\nNote that enumeration sequence by next_values method does not affect other\nnon-external enumeration methods, unless underlying iteration\nmethods itself has side-effect, e.g. IO#each_line.\n
peek Enumerator.peek()\nReturns the next object in the enumerator, but don't move the internal\nposition forward.  When the position reached at the end, StopIteration\nis raised.\n\n  a = [1,2,3]\n  e = a.to_enum\n  p e.next   #=> 1\n  p e.peek   #=> 2\n  p e.peek   #=> 2\n  p e.peek   #=> 2\n  p e.next   #=> 2\n  p e.next   #=> 3\n  p e.next   #raises StopIteration\n
peek_values Enumerator.peek_values()\nReturns the next object as an array in the enumerator,\nbut don't move the internal position forward.\nWhen the position reached at the end, StopIteration is raised.\n\n  o = Object.new\n  def o.each\n    yield\n    yield 1\n    yield 1, 2\n  end\n  e = o.to_enum\n  p e.peek_values    #=> []\n  e.next\n  p e.peek_values    #=> [1]\n  p e.peek_values    #=> [1]\n  e.next\n  p e.peek_values    #=> [1, 2]\n  e.next\n  p e.peek_values    # raises StopIteration\n
rewind Enumerator.rewind()\nRewinds the enumeration sequence by the next method.\n\nIf the enclosed object responds to a "rewind" method, it is called.\n
with_index Enumerator.with_index(...)\nIterates the given block for each element with an index, which\nstarts from +offset+.  If no block is given, returns an enumerator.\n
with_object Enumerator.with_object(p1)\nIterates the given block for each element with an arbitrary\nobject given, and returns the initially given object.\n\nIf no block is given, returns an enumerator.\n
result StopIteration.result()\nReturns the return value of the iterator.\n\n  o = Object.new\n  def o.each\n    yield 1\n    yield 2\n    yield 3\n    100\n  end\n  e = o.to_enum\n  p e.next                   #=> 1\n  p e.next                   #=> 2\n  p e.next                   #=> 3\n  begin\n    e.next\n  rescue StopIteration\n    p $!.result              #=> 100\n  end\n
exception Exception.exception(...)\nWith no argument, or if the argument is the same as the receiver,\nreturn the receiver. Otherwise, create a new\nexception object of the same class as the receiver, but with a\nmessage equal to `string.to_str`.\n
new Exception.new(...)\nConstruct a new Exception object, optionally passing in\na message.\n
backtrace Exception.backtrace()\nReturns any backtrace associated with the exception. The backtrace\nis an array of strings, each containing either ``filename:lineNo: in\n`method''' or ``filename:lineNo.''\n\n   def a\n     raise "boom"\n   end\n\n   def b\n     a()\n   end\n\n   begin\n     b()\n   rescue => detail\n     print detail.backtrace.join("\\n")\n   end\n\n<em>produces:</em>\n\n   prog.rb:2:in `a'\n   prog.rb:6:in `b'\n   prog.rb:10\n
exception Exception.exception(...)\nWith no argument, or if the argument is the same as the receiver,\nreturn the receiver. Otherwise, create a new\nexception object of the same class as the receiver, but with a\nmessage equal to `string.to_str`.\n
inspect Exception.inspect()\nReturn this exception's class name an message\n
message Exception.message()\nReturns the result of invoking `exception.to_s`.\nNormally this returns the exception's message or name. By\nsupplying a to_str method, exceptions are agreeing to\nbe used where Strings are expected.\n
set_backtrace Exception.set_backtrace(p1)\nSets the backtrace information associated with <i>exc</i>. The\nargument must be an array of `String` objects in the\nformat described in `Exception#backtrace`.\n
to_s Exception.to_s()\nReturns exception's message (or the name of the exception if\nno message is set).\n
new SystemExit.new(...)\nCreate a new +SystemExit+ exception with the given status.\n
status SystemExit.status()\nReturn the status value associated with this system exit.\n
success? SystemExit.success?()\nReturns +true+ if exiting successful, +false+ if not.\n
new NameError.new(...)\nConstruct a new NameError exception. If given the <i>name</i>\nparameter may subsequently be examined using the `NameError.name`\nmethod.\n
name NameError.name()\nReturn the name associated with this NameError exception.\n
to_s NameError.to_s()\nProduce a nicely-formatted string representing the +NameError+.\n
new NoMethodError.new(...)\nConstruct a NoMethodError exception for a method of the given name\ncalled with the given arguments. The name may be accessed using\nthe `#name` method on the resulting object, and the\narguments using the `#args` method.\n
args NoMethodError.args()\nReturn the arguments passed in as the third parameter to\nthe constructor.\n
new SystemCallError.new(...)\nIf _errno_ corresponds to a known system error code, constructs\nthe appropriate `Errno` class for that error, otherwise\nconstructs a generic `SystemCallError` object. The\nerror number is subsequently available via the `errno`\nmethod.\n
errno SystemCallError.errno()\nReturn this SystemCallError's error number.\n
new File::Stat.new(p1)\n  File::Stat.new(file_name)  -> stat\n\nCreate a File::Stat object for the given file name (raising an\nexception if the file doesn't exist).\n
atime File::Stat.atime()\nReturns the last access time for this file as an object of class\n`Time`.\n\n   File.stat("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969\n
blksize File::Stat.blksize()\nReturns the native file system's block size. Will return `nil`\non platforms that don't support this information.\n\n   File.stat("testfile").blksize   #=> 4096\n
blockdev? File::Stat.blockdev?()\nReturns `true` if the file is a block device,\n`false` if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").blockdev?    #=> false\n   File.stat("/dev/hda1").blockdev?   #=> true\n
blocks File::Stat.blocks()\nReturns the number of native file system blocks allocated for this\nfile, or `nil` if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").blocks   #=> 2\n
chardev? File::Stat.chardev?()\nReturns `true` if the file is a character device,\n`false` if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("/dev/tty").chardev?   #=> true\n
ctime File::Stat.ctime()\nReturns the change time for <i>stat</i> (that is, the time\ndirectory information about the file was changed, not the file\nitself).\n\n   File.stat("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003\n
dev File::Stat.dev()\nReturns an integer representing the device on which <i>stat</i>\nresides.\n\n   File.stat("testfile").dev   #=> 774\n
dev_major File::Stat.dev_major()\nReturns the major part of `File_Stat#dev` or\n`nil`.\n\n   File.stat("/dev/fd1").dev_major   #=> 2\n   File.stat("/dev/tty").dev_major   #=> 5\n
dev_minor File::Stat.dev_minor()\nReturns the minor part of `File_Stat#dev` or\n`nil`.\n\n   File.stat("/dev/fd1").dev_minor   #=> 1\n   File.stat("/dev/tty").dev_minor   #=> 0\n
directory? File::Stat.directory?()\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
executable? File::Stat.executable?()\nReturns `true` if <i>stat</i> is executable or if the\noperating system doesn't distinguish executable files from\nnonexecutable files. The tests are made using the effective owner of\nthe process.\n\n   File.stat("testfile").executable?   #=> false\n
executable_real? File::Stat.executable_real?()\nSame as `executable?`, but tests using the real owner of\nthe process.\n
file? File::Stat.file?()\nReturns `true` if <i>stat</i> is a regular file (not\na device file, pipe, socket, etc.).\n\n   File.stat("testfile").file?   #=> true\n
ftype File::Stat.ftype()\nIdentifies the type of <i>stat</i>. The return string is one of:\n```file`'', ```directory`'',\n```characterSpecial`'', ```blockSpecial`'',\n```fifo`'', ```link`'',\n```socket`'', or ```unknown`''.\n\n   File.stat("/dev/tty").ftype   #=> "characterSpecial"\n
gid File::Stat.gid()\nReturns the numeric group id of the owner of <i>stat</i>.\n\n   File.stat("testfile").gid   #=> 500\n
grpowned? File::Stat.grpowned?()\nReturns true if the effective group id of the process is the same as\nthe group id of <i>stat</i>. On Windows NT, returns `false`.\n\n   File.stat("testfile").grpowned?      #=> true\n   File.stat("/etc/passwd").grpowned?   #=> false\n
ino File::Stat.ino()\nReturns the inode number for <i>stat</i>.\n\n   File.stat("testfile").ino   #=> 1083669\n
inspect File::Stat.inspect()\nProduce a nicely formatted description of <i>stat</i>.\n\n  File.stat("/etc/passwd").inspect\n=> "#<File::Stat dev=0xe000005, ino=1078078, mode=0100644,\n    nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,\n    blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,\n    mtime=Fri Sep 12 15:41:41 CDT 2003,\n    ctime=Mon Oct 27 11:20:27 CST 2003>"\n
mode File::Stat.mode()\nReturns an integer representing the permission bits of\n<i>stat</i>. The meaning of the bits is platform dependent; on\nUnix systems, see `stat(2)`.\n\n   File.chmod(0644, "testfile")   #=> 1\n   s = File.stat("testfile")\n   sprintf("%o", s.mode)          #=> "100644"\n
mtime File::Stat.mtime()\nReturns the modification time of <i>stat</i>.\n\n   File.stat("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003\n
nlink File::Stat.nlink()\nReturns the number of hard links to <i>stat</i>.\n\n   File.stat("testfile").nlink             #=> 1\n   File.link("testfile", "testfile.bak")   #=> 0\n   File.stat("testfile").nlink             #=> 2\n
owned? File::Stat.owned?()\nReturns `true` if the effective user id of the process is\nthe same as the owner of <i>stat</i>.\n\n   File.stat("testfile").owned?      #=> true\n   File.stat("/etc/passwd").owned?   #=> false\n
pipe? File::Stat.pipe?()\nReturns `true` if the operating system supports pipes and\n<i>stat</i> is a pipe; `false` otherwise.\n
rdev File::Stat.rdev()\nReturns an integer representing the device type on which\n<i>stat</i> resides. Returns `nil` if the operating\nsystem doesn't support this feature.\n\n   File.stat("/dev/fd1").rdev   #=> 513\n   File.stat("/dev/tty").rdev   #=> 1280\n
rdev_major File::Stat.rdev_major()\nReturns the major part of `File_Stat#rdev` or\n`nil`.\n\n   File.stat("/dev/fd1").rdev_major   #=> 2\n   File.stat("/dev/tty").rdev_major   #=> 5\n
rdev_minor File::Stat.rdev_minor()\nReturns the minor part of `File_Stat#rdev` or\n`nil`.\n\n   File.stat("/dev/fd1").rdev_minor   #=> 1\n   File.stat("/dev/tty").rdev_minor   #=> 0\n
readable? File::Stat.readable?()\nReturns `true` if <i>stat</i> is readable by the\neffective user id of this process.\n\n   File.stat("testfile").readable?   #=> true\n
readable_real? File::Stat.readable_real?()\nReturns `true` if <i>stat</i> is readable by the real\nuser id of this process.\n\n   File.stat("testfile").readable_real?   #=> true\n
setgid? File::Stat.setgid?()\nReturns `true` if <i>stat</i> has the set-group-id\npermission bit set, `false` if it doesn't or if the\noperating system doesn't support this feature.\n\n   File.stat("/usr/sbin/lpc").setgid?   #=> true\n
setuid? File::Stat.setuid?()\nReturns `true` if <i>stat</i> has the set-user-id\npermission bit set, `false` if it doesn't or if the\noperating system doesn't support this feature.\n\n   File.stat("/bin/su").setuid?   #=> true\n
size File::Stat.size()\nReturns the size of <i>stat</i> in bytes.\n\n   File.stat("testfile").size   #=> 66\n
size? File::Stat.size?()\nReturns the size of <i>stat</i> in bytes.\n\n   File.stat("testfile").size   #=> 66\n
socket? File::Stat.socket?()\nReturns `true` if <i>stat</i> is a socket,\n`false` if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").socket?   #=> false\n
sticky? File::Stat.sticky?()\nReturns `true` if <i>stat</i> has its sticky bit set,\n`false` if it doesn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").sticky?   #=> false\n
symlink? File::Stat.symlink?()\nReturns `true` if <i>stat</i> is a symbolic link,\n`false` if it isn't or if the operating system doesn't\nsupport this feature. As `File::stat` automatically\nfollows symbolic links, `symlink?` will always be\n`false` for an object returned by\n`File::stat`.\n\n   File.symlink("testfile", "alink")   #=> 0\n   File.stat("alink").symlink?         #=> false\n   File.lstat("alink").symlink?        #=> true\n
uid File::Stat.uid()\nReturns the numeric user id of the owner of <i>stat</i>.\n\n   File.stat("testfile").uid   #=> 501\n
world_readable? File::Stat.world_readable?()\nIf <i>stat</i> is readable by others, returns an integer\nrepresenting the file permission bits of <i>stat</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   m = File.stat("/etc/passwd").world_readable?  #=> 420\n   sprintf("%o", m)                              #=> "644"\n
world_writable? File::Stat.world_writable?()\nIf <i>stat</i> is writable by others, returns an integer\nrepresenting the file permission bits of <i>stat</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   m = File.stat("/tmp").world_writable?         #=> 511\n   sprintf("%o", m)                              #=> "777"\n
writable? File::Stat.writable?()\nReturns `true` if <i>stat</i> is writable by the\neffective user id of this process.\n\n   File.stat("testfile").writable?   #=> true\n
writable_real? File::Stat.writable_real?()\nReturns `true` if <i>stat</i> is writable by the real\nuser id of this process.\n\n   File.stat("testfile").writable_real?   #=> true\n
zero? File::Stat.zero?()\nReturns `true` if <i>stat</i> is a zero-length file;\n`false` otherwise.\n\n   File.stat("testfile").zero?   #=> false\n
binread IO.binread(...)\nOpens the file, optionally seeks to the given <i>offset</i>, then returns\n<i>length</i> bytes (defaulting to the rest of the file).\n`binread` ensures the file is closed before returning.\nThe open mode would be "rb:ASCII-8BIT".\n\n   IO.binread("testfile")           #=> "This is line one\\nThis is line\n   two\\nThis is line three\\nAnd so on...\\n"\n   IO.binread("testfile", 20)       #=> "This is line one\\nThi"\n   IO.binread("testfile", 20, 10)   #=> "ne one\\nThis is line "\n
copy_stream IO.copy_stream(...)\nIO.copy_stream copies <i>src</i> to <i>dst</i>.\n<i>src</i> and <i>dst</i> is either a filename or an IO.\n\nThis method returns the number of bytes copied.\n\nIf optional arguments are not given,\nthe start position of the copy is\nthe beginning of the filename or\nthe current file offset of the IO.\nThe end position of the copy is the end of file.\n\nIf <i>copy_length</i> is given,\nNo more than <i>copy_length</i> bytes are copied.\n\nIf <i>src_offset</i> is given,\nit specifies the start position of the copy.\n\nWhen <i>src_offset</i> is specified and\n<i>src</i> is an IO,\nIO.copy_stream doesn't move the current file offset.\n
for_fd IO.for_fd(...)\nSynonym for `IO.new`.\n
foreach IO.foreach(...)\nExecutes the block for every line in the named I/O port, where lines\nare separated by <em>sep</em>.\n\nIf no block is given, an enumerator is returned instead.\n\n   IO.foreach("testfile") {|x| print "GOT ", x }\n\n<em>produces:</em>\n\n   GOT This is line one\n   GOT This is line two\n   GOT This is line three\n   GOT And so on...\n\nIf the last argument is a hash, it's the keyword argument to open.\nSee `IO.read` for detail.\n
new IO.new(...)\nReturns a new `IO` object (a stream) for the given\n`IO` object or integer file descriptor and mode\nstring. See also `IO.sysopen` and\n`IO.for_fd`.\n\n=== Parameters\nfd:: numeric file descriptor\nmode:: file mode. a string or an integer\nopt:: hash for specifying mode by name.\n\n==== Mode\nWhen `mode` is an integer it must be combination of\nthe modes defined in `File::Constants`.\n\nWhen `mode` is a string it must be in one of the\nfollowing forms:\n- "fmode",\n- "fmode:extern",\n- "fmode:extern:intern".\n`extern` is the external encoding name for the IO.\n`intern` is the internal encoding.\n`fmode` must be combination of the directives. See\nthe description of class +IO+ for a description of the directives.\n\nWhen the mode of original IO is read only, the mode cannot be changed to\nbe writable.  Similarly, the mode cannot be changed from write only to\nreadable.\nIf such a wrong change is directed, timing where the error actually occurs\nis different according to the platform.\n\n==== Options\n`opt` can have the following keys\n:mode ::\n  same as `mode` parameter\n:external_encoding ::\n  external encoding for the IO. "-" is a\n  synonym for the default external encoding.\n:internal_encoding ::\n  internal encoding for the IO.\n  "-" is a synonym for the default internal encoding.\n  If the value is nil no conversion occurs.\n:encoding ::\n  specifies external and internal encodings as "extern:intern".\n:textmode ::\n  If the value is truth value, same as "t" in argument `mode`.\n:binmode ::\n  If the value is truth value, same as "b" in argument `mode`.\n:autoclose ::\n  If the value is +false+, the _fd_ will be kept open after this\n  +IO+ instance gets finalized.\n\nAlso `opt` can have same keys in `String#encode` for\ncontrolling conversion between the external encoding and the internal encoding.\n\n=== Example1\n\n   fd = IO.sysopen("/dev/tty", "w")\n   a = IO.new(fd,"w")\n   $stderr.puts "Hello"\n   a.puts "World"\n\n<em>produces:</em>\n\n   Hello\n   World\n\n=== Example2\n\n   require 'fcntl'\n\n   fd = STDERR.fcntl(Fcntl::F_DUPFD)\n   io = IO.new(fd, mode: 'w:UTF-16LE', cr_newline: true)\n   io.puts "Hello, World!"\n\n   fd = STDERR.fcntl(Fcntl::F_DUPFD)\n   io = IO.new(fd, mode: 'w', cr_newline: true, external_encoding:\n   Encoding::UTF_16LE)\n   io.puts "Hello, World!"\n\nboth of above print "Hello, World!" in UTF-16LE to standard error output with\nconverting EOL generated by `puts` to CR.\n
open IO.open(...)\nWith no associated block, `open` is a synonym for\n`IO.new`. If the optional code block is given, it will\nbe passed <i>io</i> as an argument, and the IO object will\nautomatically be closed when the block terminates. In this instance,\n`IO.open` returns the value of the block.\n
pipe IO.pipe(...)\n   IO.pipe(...) {|read_io, write_io| ... }\n\nCreates a pair of pipe endpoints (connected to each other) and\nreturns them as a two-element array of `IO` objects:\n`[` <i>read_io</i>, <i>write_io</i> `]`.\n\nIf a block is given, the block is called and\nreturns the value of the block.\n<i>read_io</i> and <i>write_io</i> are sent to the block as arguments.\nIf read_io and write_io are not closed when the block exits, they are closed.\ni.e. closing read_io and/or write_io doesn't cause an error.\n\nNot available on all platforms.\n\nIf an encoding (encoding name or encoding object) is specified as an optional\nargument,\nread string from pipe is tagged with the encoding specified.\nIf the argument is a colon separated two encoding names "A:B",\nthe read string is converted from encoding A (external encoding)\nto encoding B (internal encoding), then tagged with B.\nIf two optional arguments are specified, those must be\nencoding objects or encoding names,\nand the first one is the external encoding,\nand the second one is the internal encoding.\nIf the external encoding and the internal encoding is specified,\noptional hash argument specify the conversion option.\n\nIn the example below, the two processes close the ends of the pipe\nthat they are not using. This is not just a cosmetic nicety. The\nread end of a pipe will not generate an end of file condition if\nthere are any writers with the pipe still open. In the case of the\nparent process, the `rd.read` will never return if it\ndoes not first issue a `wr.close`.\n\n   rd, wr = IO.pipe\n\n   if fork\n     wr.close\n     puts "Parent got: <#{rd.read}>"\n     rd.close\n     Process.wait\n   else\n     rd.close\n     puts "Sending message to parent"\n     wr.write "Hi Dad"\n     wr.close\n   end\n\n<em>produces:</em>\n\n   Sending message to parent\n   Parent got: <Hi Dad>\n
popen IO.popen(...)\nRuns the specified command as a subprocess; the subprocess's\nstandard input and output will be connected to the returned\n`IO` object.\n\nThe PID of the started process can be obtained by IO#pid method.\n\n_cmd_ is a string or an array as follows.\n\n  cmd:\n    "-"                                      : fork\n    commandline                              : command line string which is\n    passed to a shell\n    [env, cmdname, arg1, ..., opts]          : command name and zero or more\n    arguments (no shell)\n    [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and\n    zero or more arguments (no shell)\n  (env and opts are optional.)\n\nIf _cmd_ is a +String+ ```-`'',\nthen a new instance of Ruby is started as the subprocess.\n\nIf <i>cmd</i> is an +Array+ of +String+,\nthen it will be used as the subprocess's +argv+ bypassing a shell.\nThe array can contains a hash at first for environments and\na hash at last for options similar to `spawn`.\n\nThe default mode for the new file object is ``r'',\nbut <i>mode</i> may be set to any of the modes listed in the description\nfor class IO.\nThe last argument <i>opt</i> qualifies <i>mode</i>.\n set IO encoding\n  IO.popen("nkf -e filename", :external_encoding=>"EUC-JP") {|nkf_io|\n    euc_jp_string = nkf_io.read\n  }\n merge standard output and standard error using\n spawn option.  See the document of Kernel.spawn.\n  IO.popen(["ls", "/", :err=>[:child, :out]]) {|ls_io|\n    ls_result_with_error = ls_io.read\n  }\n\nRaises exceptions which `IO.pipe` and\n`Kernel.spawn` raise.\n\nIf a block is given, Ruby will run the command as a child connected\nto Ruby with a pipe. Ruby's end of the pipe will be passed as a\nparameter to the block.\nAt the end of block, Ruby close the pipe and sets `$?`.\nIn this case `IO.popen` returns\nthe value of the block.\n\nIf a block is given with a _cmd_ of ```-`'',\nthe block will be run in two separate processes: once in the parent,\nand once in a child. The parent process will be passed the pipe\nobject as a parameter to the block, the child version of the block\nwill be passed `nil`, and the child's standard in and\nstandard out will be connected to the parent through the pipe. Not\navailable on all platforms.\n\n   f = IO.popen("uname")\n   p f.readlines\n   f.close\n   puts "Parent is #{Process.pid}"\n   IO.popen("date") { |f| puts f.gets }\n   IO.popen("-") {|f| $stderr.puts "#{Process.pid} is here, f is #{f.inspect}"}\n   p $?\n   IO.popen(%w"sed -e s|^|<foo>| -e s&$&;zot;&", "r+") {|f|\n     f.puts "bar"; f.close_write; puts f.gets\n   }\n\n<em>produces:</em>\n\n   ["Linux\\n"]\n   Parent is 21346\n   Thu Jan 15 22:41:19 JST 2009\n   21346 is here, f is #<IO:fd 3>\n   21352 is here, f is nil\n<Process::Status: pid 21352 exit 0>\n   <foo>bar;zot;\n
read IO.read(...)\nOpens the file, optionally seeks to the given <i>offset</i>, then returns\n<i>length</i> bytes (defaulting to the rest of the file).\n`read` ensures the file is closed before returning.\n\nIf the last argument is a hash, it specifies option for internal\nopen().  The key would be the following.  open_args: is exclusive\nto others.\n\n encoding: string or encoding\n\n  specifies encoding of the read string.  encoding will be ignored\n  if length is specified.\n\n mode: string\n\n  specifies mode argument for open().  it should start with "r"\n  otherwise it would cause error.\n\n open_args: array of strings\n\n  specifies arguments for open() as an array.\n\n   IO.read("testfile")           #=> "This is line one\\nThis is line\n   two\\nThis is line three\\nAnd so on...\\n"\n   IO.read("testfile", 20)       #=> "This is line one\\nThi"\n   IO.read("testfile", 20, 10)   #=> "ne one\\nThis is line "\n
readlines IO.readlines(...)\nReads the entire file specified by <i>name</i> as individual\nlines, and returns those lines in an array. Lines are separated by\n<i>sep</i>.\n\n   a = IO.readlines("testfile")\n   a[0]   #=> "This is line one\\n"\n\nIf the last argument is a hash, it's the keyword argument to open.\nSee `IO.read` for detail.\n
select IO.select(...)\nSee `Kernel#select`.\n
sysopen IO.sysopen(...)\nOpens the given path, returning the underlying file descriptor as a\n`Fixnum`.\n\n   IO.sysopen("testfile")   #=> 3\n
try_convert IO.try_convert(p1)\nTry to convert <i>obj</i> into an IO, using to_io method.\nReturns converted IO or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   IO.try_convert(STDOUT)     #=> STDOUT\n   IO.try_convert("STDOUT")   #=> nil\n\n   require 'zlib'\n   f = open("/tmp/zz.gz")       #=> #<File:/tmp/zz.gz>\n   z = Zlib::GzipReader.open(f) #=> #<Zlib::GzipReader:0x81d8744>\n   IO.try_convert(z)            #=> #<File:/tmp/zz.gz>\n
autoclose= IO.autoclose=(p1)\nSets auto-close flag.\n\n   f = open("/dev/null")\n   IO.for_fd(f.fileno)\n ...\n   f.gets # may cause IOError\n\n   f = open("/dev/null")\n   IO.for_fd(f.fileno).autoclose = true\n ...\n   f.gets # won't cause IOError\n
autoclose? IO.autoclose?()\nReturns +true+ if the underlying file descriptor of _ios_ will be\nclosed automatically at its finalization, otherwise +false+.\n
binmode IO.binmode()\nPuts <em>ios</em> into binary mode.\nOnce a stream is in binary mode, it cannot be reset to nonbinary mode.\n\n- newline conversion disabled\n- encoding conversion disabled\n- content is treated as ASCII-8BIT\n
binmode? IO.binmode?()\nReturns `true` if <em>ios</em> is binmode.\n
bytes IO.bytes()\n   ios.each_byte {|byte| block }  -> ios\n   ios.each_byte                  -> an_enumerator\n\nCalls the given block once for each byte (0..255) in <em>ios</em>,\npassing the byte as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   checksum = 0\n   f.each_byte {|x| checksum ^= x }   #=> #<File:testfile>\n   checksum                           #=> 12\n
chars IO.chars()\n   ios.each_char {|c| block }  -> ios\n   ios.each_char               -> an_enumerator\n\nCalls the given block once for each character in <em>ios</em>,\npassing the character as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   f.each_char {|c| print c, ' ' }   #=> #<File:testfile>\n
close IO.close()\nCloses <em>ios</em> and flushes any pending writes to the operating\nsystem. The stream is unavailable for any further data operations;\nan `IOError` is raised if such an attempt is made. I/O\nstreams are automatically closed when they are claimed by the\ngarbage collector.\n\nIf <em>ios</em> is opened by `IO.popen`,\n`close` sets `$?`.\n
close_on_exec= IO.close_on_exec=(p1)\nSets a close-on-exec flag.\n\n   f = open("/dev/null")\n   f.close_on_exec = true\n   system("cat", "/proc/self/fd/#{f.fileno}") # cat: /proc/self/fd/3: No\n   such file or directory\n   f.closed?                #=> false\n
close_on_exec? IO.close_on_exec?()\nReturns `true` if <em>ios</em> will be closed on exec.\n\n   f = open("/dev/null")\n   f.close_on_exec?                 #=> false\n   f.close_on_exec = true\n   f.close_on_exec?                 #=> true\n   f.close_on_exec = false\n   f.close_on_exec?                 #=> false\n
close_read IO.close_read()\nCloses the read end of a duplex I/O stream (i.e., one that contains\nboth a read and a write stream, such as a pipe). Will raise an\n`IOError` if the stream is not duplexed.\n\n   f = IO.popen("/bin/sh","r+")\n   f.close_read\n   f.readlines\n\n<em>produces:</em>\n\n   prog.rb:3:in `readlines': not opened for reading (IOError)\n    from prog.rb:3\n
close_write IO.close_write()\nCloses the write end of a duplex I/O stream (i.e., one that contains\nboth a read and a write stream, such as a pipe). Will raise an\n`IOError` if the stream is not duplexed.\n\n   f = IO.popen("/bin/sh","r+")\n   f.close_write\n   f.print "nowhere"\n\n<em>produces:</em>\n\n   prog.rb:3:in `write': not opened for writing (IOError)\n    from prog.rb:3:in `print'\n    from prog.rb:3\n
closed? IO.closed?()\nReturns `true` if <em>ios</em> is completely closed (for\nduplex streams, both reader and writer), `false`\notherwise.\n\n   f = File.new("testfile")\n   f.close         #=> nil\n   f.closed?       #=> true\n   f = IO.popen("/bin/sh","r+")\n   f.close_write   #=> nil\n   f.closed?       #=> false\n   f.close_read    #=> nil\n   f.closed?       #=> true\n
codepoints IO.codepoints()\nPasses the `Integer` ordinal of each character in <i>ios</i>,\npassing the codepoint as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n
each IO.each(...)\n   ios.each_line(sep=$/) {|line| block }    -> ios\n   ios.each_line(limit) {|line| block }     -> ios\n   ios.each_line(sep,limit) {|line| block } -> ios\n   ios.each_line(...)                       -> an_enumerator\n\n   ios.lines(sep=$/) {|line| block }        -> ios\n   ios.lines(limit) {|line| block }         -> ios\n   ios.lines(sep,limit) {|line| block }     -> ios\n   ios.lines(...)                           -> an_enumerator\n\nExecutes the block for every line in <em>ios</em>, where lines are\nseparated by <i>sep</i>. <em>ios</em> must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   f.each {|line| puts "#{f.lineno}: #{line}" }\n\n<em>produces:</em>\n\n   1: This is line one\n   2: This is line two\n   3: This is line three\n   4: And so on...\n
each_byte IO.each_byte()\n   ios.each_byte {|byte| block }  -> ios\n   ios.each_byte                  -> an_enumerator\n\nCalls the given block once for each byte (0..255) in <em>ios</em>,\npassing the byte as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   checksum = 0\n   f.each_byte {|x| checksum ^= x }   #=> #<File:testfile>\n   checksum                           #=> 12\n
each_char IO.each_char()\n   ios.each_char {|c| block }  -> ios\n   ios.each_char               -> an_enumerator\n\nCalls the given block once for each character in <em>ios</em>,\npassing the character as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   f.each_char {|c| print c, ' ' }   #=> #<File:testfile>\n
each_codepoint IO.each_codepoint()\nPasses the `Integer` ordinal of each character in <i>ios</i>,\npassing the codepoint as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n
each_line IO.each_line(...)\n   ios.each_line(sep=$/) {|line| block }    -> ios\n   ios.each_line(limit) {|line| block }     -> ios\n   ios.each_line(sep,limit) {|line| block } -> ios\n   ios.each_line(...)                       -> an_enumerator\n\n   ios.lines(sep=$/) {|line| block }        -> ios\n   ios.lines(limit) {|line| block }         -> ios\n   ios.lines(sep,limit) {|line| block }     -> ios\n   ios.lines(...)                           -> an_enumerator\n\nExecutes the block for every line in <em>ios</em>, where lines are\nseparated by <i>sep</i>. <em>ios</em> must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   f.each {|line| puts "#{f.lineno}: #{line}" }\n\n<em>produces:</em>\n\n   1: This is line one\n   2: This is line two\n   3: This is line three\n   4: And so on...\n
eof IO.eof()\nReturns true if <em>ios</em> is at end of file that means\nthere are no more data to read.\nThe stream must be opened for reading or an `IOError` will be\nraised.\n\n   f = File.new("testfile")\n   dummy = f.readlines\n   f.eof   #=> true\n\nIf <em>ios</em> is a stream such as pipe or socket, `IO#eof?`\nblocks until the other end sends some data or closes it.\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.close }\n   r.eof?  #=> true after 1 second blocking\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.puts "a" }\n   r.eof?  #=> false after 1 second blocking\n\n   r, w = IO.pipe\n   r.eof?  # blocks forever\n\nNote that `IO#eof?` reads data to the input byte buffer.\nSo `IO#sysread` may not behave as you intend with\n`IO#eof?`, unless you call `IO#rewind`\nfirst (which is not available for some streams).\n
eof? IO.eof?()\nReturns true if <em>ios</em> is at end of file that means\nthere are no more data to read.\nThe stream must be opened for reading or an `IOError` will be\nraised.\n\n   f = File.new("testfile")\n   dummy = f.readlines\n   f.eof   #=> true\n\nIf <em>ios</em> is a stream such as pipe or socket, `IO#eof?`\nblocks until the other end sends some data or closes it.\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.close }\n   r.eof?  #=> true after 1 second blocking\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.puts "a" }\n   r.eof?  #=> false after 1 second blocking\n\n   r, w = IO.pipe\n   r.eof?  # blocks forever\n\nNote that `IO#eof?` reads data to the input byte buffer.\nSo `IO#sysread` may not behave as you intend with\n`IO#eof?`, unless you call `IO#rewind`\nfirst (which is not available for some streams).\n
external_encoding IO.external_encoding()\nReturns the Encoding object that represents the encoding of the file.\nIf io is write mode and no encoding is specified, returns `nil`.\n
fcntl IO.fcntl(...)\nProvides a mechanism for issuing low-level commands to control or\nquery file-oriented I/O streams. Arguments and results are platform\ndependent. If <i>arg</i> is a number, its value is passed\ndirectly. If it is a string, it is interpreted as a binary sequence\nof bytes (`Array#pack` might be a useful way to build this\nstring). On Unix platforms, see `fcntl(2)` for details.\nNot implemented on all platforms.\n
fdatasync IO.fdatasync()\nImmediately writes all buffered data in <em>ios</em> to disk.\n\n`NotImplementedError` is raised\nif the underlying operating system does not support <em>fdatasync(2)</em>.\n
fileno IO.fileno()\nReturns an integer representing the numeric file descriptor for\n<em>ios</em>.\n\n   $stdin.fileno    #=> 0\n   $stdout.fileno   #=> 1\n
flush IO.flush()\nFlushes any buffered data within <em>ios</em> to the underlying\noperating system (note that this is Ruby internal buffering only;\nthe OS may buffer the data as well).\n\n   $stdout.print "no newline"\n   $stdout.flush\n\n<em>produces:</em>\n\n   no newline\n
fsync IO.fsync()\nImmediately writes all buffered data in <em>ios</em> to disk.\nNote that `fsync` differs from\nusing `IO#sync=`. The latter ensures that data is flushed\nfrom Ruby's buffers, but doesn't not guarantee that the underlying\noperating system actually writes it to disk.\n\n`NotImplementedError` is raised\nif the underlying operating system does not support <em>fsync(2)</em>.\n
getbyte IO.getbyte()\nGets the next 8-bit byte (0..255) from <em>ios</em>. Returns\n`nil` if called at end of file.\n\n   f = File.new("testfile")\n   f.getbyte   #=> 84\n   f.getbyte   #=> 104\n
getc IO.getc()\nReads a one-character string from <em>ios</em>. Returns\n`nil` if called at end of file.\n\n   f = File.new("testfile")\n   f.getc   #=> "h"\n   f.getc   #=> "e"\n
gets IO.gets(...)\nReads the next ``line'' from the I/O stream; lines are separated by\n<i>sep</i>. A separator of `nil` reads the entire\ncontents, and a zero-length separator reads the input a paragraph at\na time (two successive newlines in the input separate paragraphs).\nThe stream must be opened for reading or an `IOError`\nwill be raised. The line read in will be returned and also assigned\nto `$_`. Returns `nil` if called at end of\nfile.  If the first argument is an integer, or optional second\nargument is given, the returning string would not be longer than the\ngiven value in bytes.\n\n   File.new("testfile").gets   #=> "This is line one\\n"\n   $_                          #=> "This is line one\\n"\n
inspect IO.inspect()\nReturn a string describing this IO object.\n
internal_encoding IO.internal_encoding()\nReturns the Encoding of the internal string if conversion is\nspecified.  Otherwise returns nil.\n
ioctl IO.ioctl(...)\nProvides a mechanism for issuing low-level commands to control or\nquery I/O devices. Arguments and results are platform dependent. If\n<i>arg</i> is a number, its value is passed directly. If it is a\nstring, it is interpreted as a binary sequence of bytes. On Unix\nplatforms, see `ioctl(2)` for details. Not implemented on\nall platforms.\n
isatty IO.isatty()\nReturns `true` if <em>ios</em> is associated with a\nterminal device (tty), `false` otherwise.\n\n   File.new("testfile").isatty   #=> false\n   File.new("/dev/tty").isatty   #=> true\n
lineno IO.lineno()\nReturns the current line number in <em>ios</em>. The stream must be\nopened for reading. `lineno` counts the number of times\n`gets` is called, rather than the number of newlines\nencountered. The two values will differ if `gets` is\ncalled with a separator other than newline. See also the\n`$.` variable.\n\n   f = File.new("testfile")\n   f.lineno   #=> 0\n   f.gets     #=> "This is line one\\n"\n   f.lineno   #=> 1\n   f.gets     #=> "This is line two\\n"\n   f.lineno   #=> 2\n
lineno= IO.lineno=(p1)\nManually sets the current line number to the given value.\n`$.` is updated only on the next read.\n\n   f = File.new("testfile")\n   f.gets                     #=> "This is line one\\n"\n   $.                         #=> 1\n   f.lineno = 1000\n   f.lineno                   #=> 1000\n   $.                         #=> 1         # lineno of last read\n   f.gets                     #=> "This is line two\\n"\n   $.                         #=> 1001      # lineno of last read\n
lines IO.lines(...)\n   ios.each_line(sep=$/) {|line| block }    -> ios\n   ios.each_line(limit) {|line| block }     -> ios\n   ios.each_line(sep,limit) {|line| block } -> ios\n   ios.each_line(...)                       -> an_enumerator\n\n   ios.lines(sep=$/) {|line| block }        -> ios\n   ios.lines(limit) {|line| block }         -> ios\n   ios.lines(sep,limit) {|line| block }     -> ios\n   ios.lines(...)                           -> an_enumerator\n\nExecutes the block for every line in <em>ios</em>, where lines are\nseparated by <i>sep</i>. <em>ios</em> must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   f.each {|line| puts "#{f.lineno}: #{line}" }\n\n<em>produces:</em>\n\n   1: This is line one\n   2: This is line two\n   3: This is line three\n   4: And so on...\n
pid IO.pid()\nReturns the process ID of a child process associated with\n<em>ios</em>. This will be set by `IO.popen`.\n\n   pipe = IO.popen("-")\n   if pipe\n     $stderr.puts "In parent, child pid is #{pipe.pid}"\n   else\n     $stderr.puts "In child, pid is #{$$}"\n   end\n\n<em>produces:</em>\n\n   In child, pid is 26209\n   In parent, child pid is 26209\n
pos IO.pos()\nReturns the current offset (in bytes) of <em>ios</em>.\n\n   f = File.new("testfile")\n   f.pos    #=> 0\n   f.gets   #=> "This is line one\\n"\n   f.pos    #=> 17\n
pos= IO.pos=(p1)\nSeeks to the given position (in bytes) in <em>ios</em>.\n\n   f = File.new("testfile")\n   f.pos = 17\n   f.gets   #=> "This is line two\\n"\n
print IO.print(...)\nWrites the given object(s) to <em>ios</em>. The stream must be\nopened for writing. If the output field separator (`$,`)\nis not `nil`, it will be inserted between each object.\nIf the output record separator (`$\\`)\nis not `nil`, it will be appended to the output. If no\narguments are given, prints `$_`. Objects that aren't\nstrings will be converted by calling their `to_s` method.\nWith no argument, prints the contents of the variable `$_`.\nReturns `nil`.\n\n   $stdout.print("This is ", 100, " percent.\\n")\n\n<em>produces:</em>\n\n   This is 100 percent.\n
printf IO.printf(...)\nFormats and writes to <em>ios</em>, converting parameters under\ncontrol of the format string. See `Kernel#sprintf`\nfor details.\n
putc IO.putc(p1)\nIf <i>obj</i> is `Numeric`, write the character whose code is\nthe least-significant byte of <i>obj</i>, otherwise write the first byte\nof the string representation of <i>obj</i> to <em>ios</em>. Note: This\nmethod is not safe for use with multi-byte characters as it will truncate\nthem.\n\n   $stdout.putc "A"\n   $stdout.putc 65\n\n<em>produces:</em>\n\n   AA\n
puts IO.puts(...)\nWrites the given objects to <em>ios</em> as with\n`IO#print`. Writes a record separator (typically a\nnewline) after any that do not already end with a newline sequence.\nIf called with an array argument, writes each element on a new line.\nIf called without arguments, outputs a single record separator.\n\n   $stdout.puts("this", "is", "a", "test")\n\n<em>produces:</em>\n\n   this\n   is\n   a\n   test\n
read IO.read(...)\nReads <i>length</i> bytes from the I/O stream.\n\n<i>length</i> must be a non-negative integer or `nil`.\n\nIf <i>length</i> is a positive integer,\nit try to read <i>length</i> bytes without any conversion (binary mode).\nIt returns `nil` or a string whose length is 1 to <i>length</i> bytes.\n`nil` means it met EOF at beginning.\nThe 1 to <i>length</i>-1 bytes string means it met EOF after reading the\nresult.\nThe <i>length</i> bytes string means it doesn't meet EOF.\nThe resulted string is always ASCII-8BIT encoding.\n\nIf <i>length</i> is omitted or is `nil`,\nit reads until EOF and the encoding conversion is applied.\nIt returns a string even if EOF is met at beginning.\n\nIf <i>length</i> is zero, it returns `""`.\n\nIf the optional <i>buffer</i> argument is present, it must reference\na String, which will receive the data.\n\nAt end of file, it returns `nil` or `""`\ndepend on <i>length</i>.\n`<i>ios</i>.read()` and\n`<i>ios</i>.read(nil)` returns `""`.\n`<i>ios</i>.read(<i>positive-integer</i>)` returns `nil`.\n\n   f = File.new("testfile")\n   f.read(16)   #=> "This is line one"\n reads whole file\n   open("file") {|f|\n     data = f.read # This returns a string even if the file is empty.\n     ...\n   }\n iterate over fixed length records.\n   open("fixed-record-file") {|f|\n     while record = f.read(256)\n       ...\n     end\n   }\n iterate over variable length records.\n record is prefixed by 32-bit length.\n   open("variable-record-file") {|f|\n     while len = f.read(4)\n       len = len.unpack("N")[0] # 32-bit length\n       record = f.read(len) # This returns a string even if len is 0.\n     end\n   }\n\nNote that this method behaves like fread() function in C.\nIf you need the behavior like read(2) system call,\nconsider readpartial, read_nonblock and sysread.\n
read_nonblock IO.read_nonblock(...)\nReads at most <i>maxlen</i> bytes from <em>ios</em> using\nthe read(2) system call after O_NONBLOCK is set for\nthe underlying file descriptor.\n\nIf the optional <i>outbuf</i> argument is present,\nit must reference a String, which will receive the data.\n\nread_nonblock just calls the read(2) system call.\nIt causes all errors the read(2) system call causes: Errno::EWOULDBLOCK,\nErrno::EINTR, etc.\nThe caller should care such errors.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying\nread_nonblock.\n\nread_nonblock causes EOFError on EOF.\n\nIf the read byte buffer is not empty,\nread_nonblock reads from the buffer like readpartial.\nIn this case, the read(2) system call is not called.\n\nWhen read_nonblock raises an exception kind of IO::WaitReadable,\nread_nonblock should not be called\nuntil io is readable for avoiding busy loop.\nThis can be done as follows.\n emulates blocking read (readpartial).\n  begin\n    result = io.read_nonblock(maxlen)\n  rescue IO::WaitReadable\n    IO.select([io])\n    retry\n  end\n\nAlthough IO#read_nonblock doesn't raise IO::WaitWritable.\nOpenSSL::Buffering#read_nonblock can raise IO::WaitWritable.\nIf IO and SSL should be used polymorphically,\nIO::WaitWritable should be rescued too.\nSee the document of OpenSSL::Buffering#read_nonblock for sample code.\n\nNote that this method is identical to readpartial\nexcept the non-blocking flag is set.\n
readbyte IO.readbyte()\nReads a byte as with `IO#getbyte`, but raises an\n`EOFError` on end of file.\n
readchar IO.readchar()\nReads a one-character string from <em>ios</em>. Raises an\n`EOFError` on end of file.\n\n   f = File.new("testfile")\n   f.readchar   #=> "h"\n   f.readchar   #=> "e"\n
readline IO.readline(...)\nReads a line as with `IO#gets`, but raises an\n`EOFError` on end of file.\n
readlines IO.readlines(...)\nReads all of the lines in <em>ios</em>, and returns them in\n<i>anArray</i>. Lines are separated by the optional <i>sep</i>. If\n<i>sep</i> is `nil`, the rest of the stream is returned\nas a single record.  If the first argument is an integer, or\noptional second argument is given, the returning string would not be\nlonger than the given value in bytes. The stream must be opened for\nreading or an `IOError` will be raised.\n\n   f = File.new("testfile")\n   f.readlines[0]   #=> "This is line one\\n"\n
readpartial IO.readpartial(...)\nReads at most <i>maxlen</i> bytes from the I/O stream.\nIt blocks only if <em>ios</em> has no data immediately available.\nIt doesn't block if some data available.\nIf the optional <i>outbuf</i> argument is present,\nit must reference a String, which will receive the data.\nIt raises `EOFError` on end of file.\n\nreadpartial is designed for streams such as pipe, socket, tty, etc.\nIt blocks only when no data immediately available.\nThis means that it blocks only when following all conditions hold.\n* the byte buffer in the IO object is empty.\n* the content of the stream is empty.\n* the stream is not reached to EOF.\n\nWhen readpartial blocks, it waits data or EOF on the stream.\nIf some data is reached, readpartial returns with the data.\nIf EOF is reached, readpartial raises EOFError.\n\nWhen readpartial doesn't blocks, it returns or raises immediately.\nIf the byte buffer is not empty, it returns the data in the buffer.\nOtherwise if the stream has some content,\nit returns the data in the stream.\nOtherwise if the stream is reached to EOF, it raises EOFError.\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << "abc"               #               ""              "abc".\n   r.readpartial(4096)      #=> "abc"       ""              ""\n   r.readpartial(4096)      # blocks because buffer and pipe is empty.\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << "abc"               #               ""              "abc"\n   w.close                  #               ""              "abc" EOF\n   r.readpartial(4096)      #=> "abc"       ""              EOF\n   r.readpartial(4096)      # raises EOFError\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << "abc\\ndef\\n"        #               ""              "abc\\ndef\\n"\n   r.gets                   #=> "abc\\n"     "def\\n"         ""\n   w << "ghi\\n"             #               "def\\n"         "ghi\\n"\n   r.readpartial(4096)      #=> "def\\n"     ""              "ghi\\n"\n   r.readpartial(4096)      #=> "ghi\\n"     ""              ""\n\nNote that readpartial behaves similar to sysread.\nThe differences are:\n* If the byte buffer is not empty, read from the byte buffer instead of\n"sysread for buffered IO (IOError)".\n* It doesn't cause Errno::EWOULDBLOCK and Errno::EINTR.  When readpartial meets\nEWOULDBLOCK and EINTR by read system call, readpartial retry the system call.\n\nThe later means that readpartial is nonblocking-flag insensitive.\nIt blocks on the situation IO#sysread causes Errno::EWOULDBLOCK as if the\nfd is blocking mode.\n
reopen IO.reopen(...)\nReassociates <em>ios</em> with the I/O stream given in\n<i>other_IO</i> or to a new stream opened on <i>path</i>. This may\ndynamically change the actual class of this stream.\n\n   f1 = File.new("testfile")\n   f2 = File.new("testfile")\n   f2.readlines[0]   #=> "This is line one\\n"\n   f2.reopen(f1)     #=> #<File:testfile>\n   f2.readlines[0]   #=> "This is line one\\n"\n
rewind IO.rewind()\nPositions <em>ios</em> to the beginning of input, resetting\n`lineno` to zero.\n\n   f = File.new("testfile")\n   f.readline   #=> "This is line one\\n"\n   f.rewind     #=> 0\n   f.lineno     #=> 0\n   f.readline   #=> "This is line one\\n"\n\nNote that it cannot be used with streams such as pipes, ttys, and sockets.\n
seek IO.seek(...)\nSeeks to a given offset <i>anInteger</i> in the stream according to\nthe value of <i>whence</i>:\n\n  IO::SEEK_CUR  | Seeks to _amount_ plus current position\n  --------------+----------------------------------------------------\n  IO::SEEK_END  | Seeks to _amount_ plus end of stream (you probably\n                | want a negative value for _amount_)\n  --------------+----------------------------------------------------\n  IO::SEEK_SET  | Seeks to the absolute location given by _amount_\n\nExample:\n\n   f = File.new("testfile")\n   f.seek(-13, IO::SEEK_END)   #=> 0\n   f.readline                  #=> "And so on...\\n"\n
set_encoding IO.set_encoding(...)\nIf single argument is specified, read string from io is tagged\nwith the encoding specified.  If encoding is a colon separated two\nencoding names "A:B", the read string is converted from encoding A\n(external encoding) to encoding B (internal encoding), then tagged\nwith B.  If two arguments are specified, those must be encoding\nobjects or encoding names, and the first one is the external encoding, and the\nsecond one is the internal encoding.\nIf the external encoding and the internal encoding is specified,\noptional hash argument specify the conversion option.\n
stat IO.stat()\nReturns status information for <em>ios</em> as an object of type\n`File::Stat`.\n\n   f = File.new("testfile")\n   s = f.stat\n   "%o" % s.mode   #=> "100644"\n   s.blksize       #=> 4096\n   s.atime         #=> Wed Apr 09 08:53:54 CDT 2003\n
sync IO.sync()\nReturns the current ``sync mode'' of <em>ios</em>. When sync mode is\ntrue, all output is immediately flushed to the underlying operating\nsystem and is not buffered by Ruby internally. See also\n`IO#fsync`.\n\n   f = File.new("testfile")\n   f.sync   #=> false\n
sync= IO.sync=(p1)\nSets the ``sync mode'' to `true` or `false`.\nWhen sync mode is true, all output is immediately flushed to the\nunderlying operating system and is not buffered internally. Returns\nthe new state. See also `IO#fsync`.\n\n   f = File.new("testfile")\n   f.sync = true\n\n<em>(produces no output)</em>\n
sysread IO.sysread(...)\nReads <i>integer</i> bytes from <em>ios</em> using a low-level\nread and returns them as a string. Do not mix with other methods\nthat read from <em>ios</em> or you may get unpredictable results.\nIf the optional <i>outbuf</i> argument is present, it must reference\na String, which will receive the data.\nRaises `SystemCallError` on error and\n`EOFError` at end of file.\n\n   f = File.new("testfile")\n   f.sysread(16)   #=> "This is line one"\n
sysseek IO.sysseek(...)\nSeeks to a given <i>offset</i> in the stream according to the value\nof <i>whence</i> (see `IO#seek` for values of\n<i>whence</i>). Returns the new offset into the file.\n\n   f = File.new("testfile")\n   f.sysseek(-13, IO::SEEK_END)   #=> 53\n   f.sysread(10)                  #=> "And so on."\n
syswrite IO.syswrite(p1)\nWrites the given string to <em>ios</em> using a low-level write.\nReturns the number of bytes written. Do not mix with other methods\nthat write to <em>ios</em> or you may get unpredictable results.\nRaises `SystemCallError` on error.\n\n   f = File.new("out", "w")\n   f.syswrite("ABCDEF")   #=> 6\n
tell IO.tell()\nReturns the current offset (in bytes) of <em>ios</em>.\n\n   f = File.new("testfile")\n   f.pos    #=> 0\n   f.gets   #=> "This is line one\\n"\n   f.pos    #=> 17\n
to_i IO.to_i()\n\n
to_io IO.to_io()\nReturns <em>ios</em>.\n
tty? IO.tty?()\nReturns `true` if <em>ios</em> is associated with a\nterminal device (tty), `false` otherwise.\n\n   File.new("testfile").isatty   #=> false\n   File.new("/dev/tty").isatty   #=> true\n
ungetbyte IO.ungetbyte(p1)\nPushes back bytes (passed as a parameter) onto <em>ios</em>,\nsuch that a subsequent buffered read will return it. Only one byte\nmay be pushed back before a subsequent read operation (that is,\nyou will be able to read only the last of several bytes that have been pushed\nback). Has no effect with unbuffered reads (such as `IO#sysread`).\n\n   f = File.new("testfile")   #=> #<File:testfile>\n   b = f.getbyte              #=> 0x38\n   f.ungetbyte(b)             #=> nil\n   f.getbyte                  #=> 0x38\n
ungetc IO.ungetc(p1)\nPushes back one character (passed as a parameter) onto <em>ios</em>,\nsuch that a subsequent buffered character read will return it. Only one\ncharacter\nmay be pushed back before a subsequent read operation (that is,\nyou will be able to read only the last of several characters that have\nbeen pushed\nback). Has no effect with unbuffered reads (such as `IO#sysread`).\n\n   f = File.new("testfile")   #=> #<File:testfile>\n   c = f.getc                 #=> "8"\n   f.ungetc(c)                #=> nil\n   f.getc                     #=> "8"\n
write IO.write(p1)\nWrites the given string to <em>ios</em>. The stream must be opened\nfor writing. If the argument is not a string, it will be converted\nto a string using `to_s`. Returns the number of bytes\nwritten.\n\n   count = $stdout.write( "This is a test\\n" )\n   puts "That was #{count} bytes of data"\n\n<em>produces:</em>\n\n   This is a test\n   That was 15 bytes of data\n
write_nonblock IO.write_nonblock(p1)\nWrites the given string to <em>ios</em> using\nthe write(2) system call after O_NONBLOCK is set for\nthe underlying file descriptor.\n\nIt returns the number of bytes written.\n\nwrite_nonblock just calls the write(2) system call.\nIt causes all errors the write(2) system call causes: Errno::EWOULDBLOCK,\nErrno::EINTR, etc.\nThe result may also be smaller than string.length (partial write).\nThe caller should care such errors and partial write.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitWritable.\nSo IO::WaitWritable can be used to rescue the exceptions for retrying\nwrite_nonblock.\n Creates a pipe.\n  r, w = IO.pipe\n write_nonblock writes only 65536 bytes and return 65536.\n (The pipe size is 65536 bytes on this environment.)\n  s = "a" * 100000\n  p w.write_nonblock(s)     #=> 65536\n write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).\n  p w.write_nonblock("b")   # Resource temporarily unavailable (Errno::EAGAIN)\n\nIf the write buffer is not empty, it is flushed at first.\n\nWhen write_nonblock raises an exception kind of IO::WaitWritable,\nwrite_nonblock should not be called\nuntil io is writable for avoiding busy loop.\nThis can be done as follows.\n\n  begin\n    result = io.write_nonblock(string)\n  rescue IO::WaitWritable, Errno::EINTR\n    IO.select(nil, [io])\n    retry\n  end\n\nNote that this doesn't guarantee to write all data in string.\nThe length written is reported as result and it should be checked later.\n\nOn some platforms such as Windows, write_nonblock is not supported\naccording to the kind of the IO object.\nIn such cases, write_nonblock raises `Errno::EBADF`.\n
new Hash.new(...)\nReturns a new, empty hash. If this hash is subsequently accessed by\na key that doesn't correspond to a hash entry, the value returned\ndepends on the style of `new` used to create the hash. In\nthe first form, the access returns `nil`. If\n<i>obj</i> is specified, this single object will be used for\nall <em>default values</em>. If a block is specified, it will be\ncalled with the hash object and the key, and should return the\ndefault value. It is the block's responsibility to store the value\nin the hash if required.\n\n   h = Hash.new("Go Fish")\n   h["a"] = 100\n   h["b"] = 200\n   h["a"]           #=> 100\n   h["c"]           #=> "Go Fish"\n The following alters the single default object\n   h["c"].upcase!   #=> "GO FISH"\n   h["d"]           #=> "GO FISH"\n   h.keys           #=> ["a", "b"]\n While this creates a new default object each time\n   h = Hash.new { |hash, key| hash[key] = "Go Fish: #{key}" }\n   h["c"]           #=> "Go Fish: c"\n   h["c"].upcase!   #=> "GO FISH: C"\n   h["d"]           #=> "Go Fish: d"\n   h.keys           #=> ["c", "d"]\n
try_convert Hash.try_convert(p1)\nTry to convert <i>obj</i> into a hash, using to_hash method.\nReturns converted hash or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   Hash.try_convert({1=>2})   # => {1=>2}\n   Hash.try_convert("1=>2")   # => nil\n
assoc Hash.assoc(p1)\nSearches through the hash comparing _obj_ with the key using `==`.\nReturns the key-value pair (two elements array) or +nil+\nif no match is found.  See `Array#assoc`.\n\n   h = {"colors"  => ["red", "blue", "green"],\n        "letters" => ["a", "b", "c" ]}\n   h.assoc("letters")  #=> ["letters", ["a", "b", "c"]]\n   h.assoc("foo")      #=> nil\n
clear Hash.clear()\nRemoves all key-value pairs from <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }   #=> {"a"=>100, "b"=>200}\n   h.clear                          #=> {}\n
compare_by_identity Hash.compare_by_identity()\nMakes <i>hsh</i> compare its keys by their identity, i.e. it\nwill consider exact same objects as same keys.\n\n   h1 = { "a" => 100, "b" => 200, :c => "c" }\n   h1["a"]        #=> 100\n   h1.compare_by_identity\n   h1.compare_by_identity? #=> true\n   h1["a"]        #=> nil  # different objects.\n   h1[:c]         #=> "c"  # same symbols are all same.\n
compare_by_identity? Hash.compare_by_identity?()\nReturns `true` if <i>hsh</i> will compare its keys by\ntheir identity.  Also see `Hash#compare_by_identity`.\n
default Hash.default(...)\nReturns the default value, the value that would be returned by\n<i>hsh</i>[<i>key</i>] if <i>key</i> did not exist in <i>hsh</i>.\nSee also `Hash::new` and `Hash#default=`.\n\n   h = Hash.new                            #=> {}\n   h.default                               #=> nil\n   h.default(2)                            #=> nil\n\n   h = Hash.new("cat")                     #=> {}\n   h.default                               #=> "cat"\n   h.default(2)                            #=> "cat"\n\n   h = Hash.new {|h,k| h[k] = k.to_i*10}   #=> {}\n   h.default                               #=> nil\n   h.default(2)                            #=> 20\n
default= Hash.default=(p1)\nSets the default value, the value returned for a key that does not\nexist in the hash. It is not possible to set the default to a\n`Proc` that will be executed on each key lookup.\n\n   h = { "a" => 100, "b" => 200 }\n   h.default = "Go fish"\n   h["a"]     #=> 100\n   h["z"]     #=> "Go fish"\n This doesn't do what you might hope...\n   h.default = proc do |hash, key|\n     hash[key] = key + key\n   end\n   h[2]       #=> #<Proc:0x401b3948@-:6>\n   h["cat"]   #=> #<Proc:0x401b3948@-:6>\n
default_proc Hash.default_proc()\nIf `Hash::new` was invoked with a block, return that\nblock, otherwise return `nil`.\n\n   h = Hash.new {|h,k| h[k] = k*k }   #=> {}\n   p = h.default_proc                 #=> #<Proc:0x401b3d08@-:1>\n   a = []                             #=> []\n   p.call(a, 2)\n   a                                  #=> [nil, nil, 4]\n
default_proc= Hash.default_proc=(p1)\nSets the default proc to be executed on each key lookup.\n\n   h.default_proc = proc do |hash, key|\n     hash[key] = key + key\n   end\n   h[2]       #=> 4\n   h["cat"]   #=> "catcat"\n
delete Hash.delete(p1)\nDeletes and returns a key-value pair from <i>hsh</i> whose key is\nequal to <i>key</i>. If the key is not found, returns the\n<em>default value</em>. If the optional code block is given and the\nkey is not found, pass in the key and return the result of\n<i>block</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.delete("a")                              #=> 100\n   h.delete("z")                              #=> nil\n   h.delete("z") { |el| "#{el} not found" }   #=> "z not found"\n
delete_if Hash.delete_if()\nDeletes every key-value pair from <i>hsh</i> for which <i>block</i>\nevaluates to `true`.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200, "c" => 300 }\n   h.delete_if {|key, value| key >= "b" }   #=> {"a"=>100}\n
each Hash.each()\nCalls <i>block</i> once for each key in <i>hsh</i>, passing the key-value\npair as parameters.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200 }\n   h.each {|key, value| puts "#{key} is #{value}" }\n\n<em>produces:</em>\n\n   a is 100\n   b is 200\n
each_key Hash.each_key()\nCalls <i>block</i> once for each key in <i>hsh</i>, passing the key\nas a parameter.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200 }\n   h.each_key {|key| puts key }\n\n<em>produces:</em>\n\n   a\n   b\n
each_pair Hash.each_pair()\nCalls <i>block</i> once for each key in <i>hsh</i>, passing the key-value\npair as parameters.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200 }\n   h.each {|key, value| puts "#{key} is #{value}" }\n\n<em>produces:</em>\n\n   a is 100\n   b is 200\n
each_value Hash.each_value()\nCalls <i>block</i> once for each key in <i>hsh</i>, passing the\nvalue as a parameter.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200 }\n   h.each_value {|value| puts value }\n\n<em>produces:</em>\n\n   100\n   200\n
empty? Hash.empty?()\nReturns `true` if <i>hsh</i> contains no key-value pairs.\n\n   {}.empty?   #=> true\n
eql? Hash.eql?(p1)\nReturns `true` if <i>hash</i> and <i>other</i> are\nboth hashes with the same content.\n
fetch Hash.fetch(...)\nReturns a value from the hash for the given key. If the key can't be\nfound, there are several options: With no other arguments, it will\nraise an `KeyError` exception; if <i>default</i> is\ngiven, then that will be returned; if the optional code block is\nspecified, then that will be run and its result returned.\n\n   h = { "a" => 100, "b" => 200 }\n   h.fetch("a")                            #=> 100\n   h.fetch("z", "go fish")                 #=> "go fish"\n   h.fetch("z") { |el| "go fish, #{el}"}   #=> "go fish, z"\n\nThe following example shows that an exception is raised if the key\nis not found and a default value is not supplied.\n\n   h = { "a" => 100, "b" => 200 }\n   h.fetch("z")\n\n<em>produces:</em>\n\n   prog.rb:2:in `fetch': key not found (KeyError)\n    from prog.rb:2\n
flatten Hash.flatten(...)\nReturns a new array that is a one-dimensional flattening of this\nhash. That is, for every key or value that is an array, extract\nits elements into the new array.  Unlike Array#flatten, this\nmethod does not flatten recursively by default.  The optional\n<i>level</i> argument determines the level of recursion to flatten.\n\n   a =  {1=> "one", 2 => [2,"two"], 3 => "three"}\n   a.flatten    # => [1, "one", 2, [2, "two"], 3, "three"]\n   a.flatten(2) # => [1, "one", 2, 2, "two", 3, "three"]\n
has_key? Hash.has_key?(p1)\nReturns `true` if the given key is present in <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_key?("a")   #=> true\n   h.has_key?("z")   #=> false\n
has_value? Hash.has_value?(p1)\nReturns `true` if the given value is present for some key\nin <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_value?(100)   #=> true\n   h.has_value?(999)   #=> false\n
hash Hash.hash()\nCompute a hash-code for this hash. Two hashes with the same content\nwill have the same hash code (and will compare using `eql?`).\n
include? Hash.include?(p1)\nReturns `true` if the given key is present in <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_key?("a")   #=> true\n   h.has_key?("z")   #=> false\n
initialize_copy Hash.initialize_copy(p1)\nReplaces the contents of <i>hsh</i> with the contents of\n<i>other_hash</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.replace({ "c" => 300, "d" => 400 })   #=> {"c"=>300, "d"=>400}\n
inspect Hash.inspect()\nReturn the contents of this hash as a string.\n\n    h = { "c" => 300, "a" => 100, "d" => 400, "c" => 300  }\n    h.to_s   #=> "{\"c\"=>300, \"a\"=>100, \"d\"=>400}"\n
invert Hash.invert()\nReturns a new hash created by using <i>hsh</i>'s values as keys, and\nthe keys as values.\n\n   h = { "n" => 100, "m" => 100, "y" => 300, "d" => 200, "a" => 0 }\n   h.invert   #=> {0=>"a", 100=>"m", 200=>"d", 300=>"y"}\n
keep_if Hash.keep_if()\nDeletes every key-value pair from <i>hsh</i> for which <i>block</i>\nevaluates to false.\n\nIf no block is given, an enumerator is returned instead.\n
key Hash.key(p1)\nReturns the key for a given value. If not found, returns `nil`.\n\n   h = { "a" => 100, "b" => 200 }\n   h.key(200)   #=> "b"\n   h.key(999)   #=> nil\n
key? Hash.key?(p1)\nReturns `true` if the given key is present in <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_key?("a")   #=> true\n   h.has_key?("z")   #=> false\n
keys Hash.keys()\nReturns a new array populated with the keys from this hash. See also\n`Hash#values`.\n\n   h = { "a" => 100, "b" => 200, "c" => 300, "d" => 400 }\n   h.keys   #=> ["a", "b", "c", "d"]\n
length Hash.length()\nReturns the number of key-value pairs in the hash.\n\n   h = { "d" => 100, "a" => 200, "v" => 300, "e" => 400 }\n   h.length        #=> 4\n   h.delete("a")   #=> 200\n   h.length        #=> 3\n
member? Hash.member?(p1)\nReturns `true` if the given key is present in <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_key?("a")   #=> true\n   h.has_key?("z")   #=> false\n
merge Hash.merge(p1)\nReturns a new hash containing the contents of <i>other_hash</i> and\nthe contents of <i>hsh</i>. If no block is specified, the value for\nentries with duplicate keys will be that of <i>other_hash</i>. Otherwise\nthe value for each duplicate key is determined by calling the block\nwith the key, its value in <i>hsh</i> and its value in <i>other_hash</i>.\n\n   h1 = { "a" => 100, "b" => 200 }\n   h2 = { "b" => 254, "c" => 300 }\n   h1.merge(h2)   #=> {"a"=>100, "b"=>254, "c"=>300}\n   h1.merge(h2){|key, oldval, newval| newval - oldval}\n=> {"a"=>100, "b"=>54,  "c"=>300}\n   h1             #=> {"a"=>100, "b"=>200}\n
merge! Hash.merge!(p1)\nAdds the contents of <i>other_hash</i> to <i>hsh</i>.  If no\nblock is specified, entries with duplicate keys are overwritten\nwith the values from <i>other_hash</i>, otherwise the value\nof each duplicate key is determined by calling the block with\nthe key, its value in <i>hsh</i> and its value in <i>other_hash</i>.\n\n   h1 = { "a" => 100, "b" => 200 }\n   h2 = { "b" => 254, "c" => 300 }\n   h1.merge!(h2)   #=> {"a"=>100, "b"=>254, "c"=>300}\n\n   h1 = { "a" => 100, "b" => 200 }\n   h2 = { "b" => 254, "c" => 300 }\n   h1.merge!(h2) { |key, v1, v2| v1 }\n=> {"a"=>100, "b"=>200, "c"=>300}\n
rassoc Hash.rassoc(p1)\nSearches through the hash comparing _obj_ with the value using `==`.\nReturns the first key-value pair (two-element array) that matches. See\nalso `Array#rassoc`.\n\n   a = {1=> "one", 2 => "two", 3 => "three", "ii" => "two"}\n   a.rassoc("two")    #=> [2, "two"]\n   a.rassoc("four")   #=> nil\n
rehash Hash.rehash()\nRebuilds the hash based on the current hash values for each key. If\nvalues of key objects have changed since they were inserted, this\nmethod will reindex <i>hsh</i>. If `Hash#rehash` is\ncalled while an iterator is traversing the hash, an\n`RuntimeError` will be raised in the iterator.\n\n   a = [ "a", "b" ]\n   c = [ "c", "d" ]\n   h = { a => 100, c => 300 }\n   h[a]       #=> 100\n   a[0] = "z"\n   h[a]       #=> nil\n   h.rehash   #=> {["z", "b"]=>100, ["c", "d"]=>300}\n   h[a]       #=> 100\n
reject Hash.reject()\nSame as `Hash#delete_if`, but works on (and returns) a\ncopy of the <i>hsh</i>. Equivalent to\n`<i>hsh</i>.dup.delete_if`.\n
reject! Hash.reject!()\nEquivalent to `Hash#delete_if`, but returns\n`nil` if no changes were made.\n
replace Hash.replace(p1)\nReplaces the contents of <i>hsh</i> with the contents of\n<i>other_hash</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.replace({ "c" => 300, "d" => 400 })   #=> {"c"=>300, "d"=>400}\n
select Hash.select()\nReturns a new hash consisting of entries for which the block returns true.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200, "c" => 300 }\n   h.select {|k,v| k > "a"}  #=> {"b" => 200, "c" => 300}\n   h.select {|k,v| v < 200}  #=> {"a" => 100}\n
select! Hash.select!()\nEquivalent to `Hash#keep_if`, but returns\n`nil` if no changes were made.\n
shift Hash.shift()\nRemoves a key-value pair from <i>hsh</i> and returns it as the\ntwo-item array `[` <i>key, value</i> `]`, or\nthe hash's default value if the hash is empty.\n\n   h = { 1 => "a", 2 => "b", 3 => "c" }\n   h.shift   #=> [1, "a"]\n   h         #=> {2=>"b", 3=>"c"}\n
size Hash.size()\nReturns the number of key-value pairs in the hash.\n\n   h = { "d" => 100, "a" => 200, "v" => 300, "e" => 400 }\n   h.length        #=> 4\n   h.delete("a")   #=> 200\n   h.length        #=> 3\n
store Hash.store(p1, p2)\nElement Assignment---Associates the value given by\n<i>value</i> with the key given by <i>key</i>.\n<i>key</i> should not have its value changed while it is in\nuse as a key (a `String` passed as a key will be\nduplicated and frozen).\n\n   h = { "a" => 100, "b" => 200 }\n   h["a"] = 9\n   h["c"] = 4\n   h   #=> {"a"=>9, "b"=>200, "c"=>4}\n
to_a Hash.to_a()\nConverts <i>hsh</i> to a nested array of `[` <i>key,\nvalue</i> `]` arrays.\n\n   h = { "c" => 300, "a" => 100, "d" => 400, "c" => 300  }\n   h.to_a   #=> [["c", 300], ["a", 100], ["d", 400]]\n
to_hash Hash.to_hash()\nReturns +self+.\n
to_s Hash.to_s()\n\n
update Hash.update(p1)\nAdds the contents of <i>other_hash</i> to <i>hsh</i>.  If no\nblock is specified, entries with duplicate keys are overwritten\nwith the values from <i>other_hash</i>, otherwise the value\nof each duplicate key is determined by calling the block with\nthe key, its value in <i>hsh</i> and its value in <i>other_hash</i>.\n\n   h1 = { "a" => 100, "b" => 200 }\n   h2 = { "b" => 254, "c" => 300 }\n   h1.merge!(h2)   #=> {"a"=>100, "b"=>254, "c"=>300}\n\n   h1 = { "a" => 100, "b" => 200 }\n   h2 = { "b" => 254, "c" => 300 }\n   h1.merge!(h2) { |key, v1, v2| v1 }\n=> {"a"=>100, "b"=>200, "c"=>300}\n
value? Hash.value?(p1)\nReturns `true` if the given value is present for some key\nin <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_value?(100)   #=> true\n   h.has_value?(999)   #=> false\n
values Hash.values()\nReturns a new array populated with the values from <i>hsh</i>. See\nalso `Hash#keys`.\n\n   h = { "a" => 100, "b" => 200, "c" => 300 }\n   h.values   #=> [100, 200, 300]\n
values_at Hash.values_at(...)\nReturn an array containing the values associated with the given keys.\nAlso see `Hash.select`.\n\n  h = { "cat" => "feline", "dog" => "canine", "cow" => "bovine" }\n  h.values_at("cow", "cat")  #=> ["bovine", "feline"]\n
argv ARGF.argv()\nReturns the +ARGV+ array, which contains the arguments passed to your\nscript, one per element.\n\nFor example:\n\n    $ ruby argf.rb -v glark.txt\n\n    ARGF.argv   #=> ["-v", "glark.txt"]\n
binmode ARGF.binmode()\nPuts +ARGF+ into binary mode. Once a stream is in binary mode, it cannot\nbe reset to non-binary mode. This option has the following effects:\n\n*  Newline conversion is disabled.\n*  Encoding conversion is disabled.\n*  Content is treated as ASCII-8BIT.\n
binmode? ARGF.binmode?()\n\n Returns true if +ARGF+ is being read in binary mode; false otherwise. (To\n enable binary mode use +ARGF.binmode+.\n\nFor example:\n\n    ARGF.binmode?  #=> false\n    ARGF.binmode\n    ARGF.binmode?  #=> true\n
bytes ARGF.bytes()\n\n    ARGF.each_byte {|byte| block }  -> ARGF\n    ARGF.each_byte                  -> an_enumerator\n\n Iterates over each byte of each file in +ARGV+.\n A byte is returned as a +Fixnum+ in the range 0..255.\n\n This method allows you to treat the files supplied on the command line as\n a single file consisting of the concatenation of each named file. After\n the last byte of the first file has been returned, the first byte of the\n second file is returned. The +ARGF.filename+ method can be used to\n determine the filename of the current byte.\n\n If no block is given, an enumerator is returned instead.\n\nFor example:\n\n    ARGF.bytes.to_a  #=> [35, 32, ... 95, 10]\n
chars ARGF.chars()\n   ARGF.each_char  {|char| block }  -> ARGF\n   ARGF.each_char                   -> an_enumerator\n\nIterates over each character of each file in +ARGF+.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last character of the first file has been returned, the first\ncharacter of the second file is returned. The +ARGF.filename+ method can\nbe used to determine the name of the file in which the current character\nappears.\n\nIf no block is given, an enumerator is returned instead.\n
close ARGF.close()\n\n Closes the current file and skips to the next in the stream. Trying to\n close a file that has already been closed causes an +IOError+ to be\n raised.\n\nFor example:\n\n    $ ruby argf.rb foo bar\n\n    ARGF.filename  #=> "foo"\n    ARGF.close\n    ARGF.filename  #=> "bar"\n    ARGF.close\n    ARGF.close     #=> closed stream (IOError)\n
closed? ARGF.closed?()\nReturns _true_ if the current file has been closed; _false_ otherwise. Use\n+ARGF.close+ to actually close the current file.\n
each ARGF.each(...)\n   ARGF.each_line(sep=$/)       {|line| block }  -> ARGF\n   ARGF.each_line(sep=$/,limit) {|line| block }  -> ARGF\n   ARGF.each_line(...)                           -> an_enumerator\n\n   ARGF.lines(sep=$/)           {|line| block }   -> ARGF\n   ARGF.lines(sep=$/,limit)     {|line| block }   -> ARGF\n   ARGF.lines(...)                                -> an_enumerator\n\nReturns an enumerator which iterates over each line (separated by _sep_,\nwhich defaults to your platform's newline character) of each file in\n+ARGV+. If a block is supplied, each line in turn will be yielded to the\nblock, otherwise an enumerator is returned.\nThe optional _limit_ argument is a +Fixnum+ specifying the maximum\nlength of each line; longer lines will be split according to this limit.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last line of the first file has been returned, the first line of the\nsecond file is returned. The +ARGF.filename+ and +ARGF.lineno+ methods can\nbe used to determine the filename and line number, respectively, of the\ncurrent line.\n\nFor example, the following code prints out each line of each named file\nprefixed with its line number, displaying the filename once per file:\n\n   ARGF.lines do |line|\n     puts ARGF.filename if ARGF.lineno == 1\n     puts "#{ARGF.lineno}: #{line}"\n   end\n
each_byte ARGF.each_byte()\n\n    ARGF.each_byte {|byte| block }  -> ARGF\n    ARGF.each_byte                  -> an_enumerator\n\n Iterates over each byte of each file in +ARGV+.\n A byte is returned as a +Fixnum+ in the range 0..255.\n\n This method allows you to treat the files supplied on the command line as\n a single file consisting of the concatenation of each named file. After\n the last byte of the first file has been returned, the first byte of the\n second file is returned. The +ARGF.filename+ method can be used to\n determine the filename of the current byte.\n\n If no block is given, an enumerator is returned instead.\n\nFor example:\n\n    ARGF.bytes.to_a  #=> [35, 32, ... 95, 10]\n
each_char ARGF.each_char()\n   ARGF.each_char  {|char| block }  -> ARGF\n   ARGF.each_char                   -> an_enumerator\n\nIterates over each character of each file in +ARGF+.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last character of the first file has been returned, the first\ncharacter of the second file is returned. The +ARGF.filename+ method can\nbe used to determine the name of the file in which the current character\nappears.\n\nIf no block is given, an enumerator is returned instead.\n
each_line ARGF.each_line(...)\n   ARGF.each_line(sep=$/)       {|line| block }  -> ARGF\n   ARGF.each_line(sep=$/,limit) {|line| block }  -> ARGF\n   ARGF.each_line(...)                           -> an_enumerator\n\n   ARGF.lines(sep=$/)           {|line| block }   -> ARGF\n   ARGF.lines(sep=$/,limit)     {|line| block }   -> ARGF\n   ARGF.lines(...)                                -> an_enumerator\n\nReturns an enumerator which iterates over each line (separated by _sep_,\nwhich defaults to your platform's newline character) of each file in\n+ARGV+. If a block is supplied, each line in turn will be yielded to the\nblock, otherwise an enumerator is returned.\nThe optional _limit_ argument is a +Fixnum+ specifying the maximum\nlength of each line; longer lines will be split according to this limit.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last line of the first file has been returned, the first line of the\nsecond file is returned. The +ARGF.filename+ and +ARGF.lineno+ methods can\nbe used to determine the filename and line number, respectively, of the\ncurrent line.\n\nFor example, the following code prints out each line of each named file\nprefixed with its line number, displaying the filename once per file:\n\n   ARGF.lines do |line|\n     puts ARGF.filename if ARGF.lineno == 1\n     puts "#{ARGF.lineno}: #{line}"\n   end\n
eof ARGF.eof()\nReturns true if the current file in +ARGF+ is at end of file, i.e. it has\nno data to read. The stream must be opened for reading or an +IOError+\nwill be raised.\n\n   $ echo "eof" | ruby argf.rb\n\n   ARGF.eof?                 #=> false\n   3.times { ARGF.readchar }\n   ARGF.eof?                 #=> false\n   ARGF.readchar             #=> "\\n"\n   ARGF.eof?                 #=> true\n
eof? ARGF.eof?()\nReturns true if the current file in +ARGF+ is at end of file, i.e. it has\nno data to read. The stream must be opened for reading or an +IOError+\nwill be raised.\n\n   $ echo "eof" | ruby argf.rb\n\n   ARGF.eof?                 #=> false\n   3.times { ARGF.readchar }\n   ARGF.eof?                 #=> false\n   ARGF.readchar             #=> "\\n"\n   ARGF.eof?                 #=> true\n
external_encoding ARGF.external_encoding()\n\n Returns the external encoding for files read from +ARGF+ as an +Encoding+\n object. The external encoding is the encoding of the text as stored in a\n file. Contrast with +ARGF.internal_encoding+, which is the encoding used\n to represent this text within Ruby.\n\n To set the external encoding use +ARGF.set_encoding+.\n\nFor example:\n\n    ARGF.external_encoding  #=>  #<Encoding:UTF-8>\n
file ARGF.file()\nReturns the current file as an +IO+ or +File+ object. #<IO:<STDIN>> is\nreturned when the current file is STDIN.\n\nFor example:\n\n   $ echo "foo" > foo\n   $ echo "bar" > bar\n\n   $ ruby argf.rb foo bar\n\n   ARGF.file      #=> #<File:foo>\n   ARGF.read(5)   #=> "foo\\nb"\n   ARGF.file      #=> #<File:bar>\n
filename ARGF.filename()\nReturns the current filename. "-" is returned when the current file is\nSTDIN.\n\nFor example:\n\n   $ echo "foo" > foo\n   $ echo "bar" > bar\n   $ echo "glark" > glark\n\n   $ ruby argf.rb foo bar glark\n\n   ARGF.filename  #=> "foo"\n   ARGF.read(5)   #=> "foo\\nb"\n   ARGF.filename  #=> "bar"\n   ARGF.skip\n   ARGF.filename  #=> "glark"\n
fileno ARGF.fileno()\nReturns an integer representing the numeric file descriptor for\nthe current file. Raises an +ArgumentError+ if there isn't a current file.\n\n   ARGF.fileno    #=> 3\n
getbyte ARGF.getbyte()\nGets the next 8-bit byte (0..255) from +ARGF+. Returns +nil+ if called at\nthe end of the stream.\n\nFor example:\n\n   $ echo "foo" > file\n   $ ruby argf.rb file\n\n   ARGF.getbyte #=> 102\n   ARGF.getbyte #=> 111\n   ARGF.getbyte #=> 111\n   ARGF.getbyte #=> 10\n   ARGF.getbyte #=> nil\n
getc ARGF.getc()\nReads the next character from +ARGF+ and returns it as a +String+. Returns\n+nil+ at the end of the stream.\n\n+ARGF+ treats the files named on the command line as a single file created\nby concatenating their contents. After returning the last character of the\nfirst file, it returns the first character of the second file, and so on.\n\nFor example:\n\n   $ echo "foo" > file\n   $ ruby argf.rb file\n\n   ARGF.getc  #=> "f"\n   ARGF.getc  #=> "o"\n   ARGF.getc  #=> "o"\n   ARGF.getc  #=> "\\n"\n   ARGF.getc  #=> nil\n   ARGF.getc  #=> nil\n
gets ARGF.gets(...)\nReturns the next line from the current file in +ARGF+.\n\nBy default lines are assumed to be separated by +$/+; to use a different\ncharacter as a separator, supply it as a +String+ for the _sep_ argument.\n\nThe optional  _limit_ argument specifies how many characters of each line\nto return. By default all characters are returned.\n
inplace_mode ARGF.inplace_mode()\nReturns the file extension appended to the names of modified files under\ninplace-edit mode. This value can be set using +ARGF.inplace_mode=+ or\npassing the +-i+ switch to the Ruby binary.\n
inplace_mode= ARGF.inplace_mode=(p1)\n\n Sets the filename extension for inplace editing mode to the given String.\n Each file being edited has this value appended to its filename. The\n modified file is saved under this new name.\n\n For example:\n\n     $ ruby argf.rb file.txt\n\n     ARGF.inplace_mode = '.bak'\n     ARGF.lines do |line|\n       print line.sub("foo","bar")\n     end\n\nEach line of _file.txt_ has the first occurrence of "foo" replaced with\n"bar", then the new line is written out to _file.txt.bak_.\n
internal_encoding ARGF.internal_encoding()\nReturns the internal encoding for strings read from +ARGF+ as an\n+Encoding+ object.\n\nIf +ARGF.set_encoding+ has been called with two encoding names, the second\nis returned. Otherwise, if +Encoding.default_external+ has been set, that\nvalue is returned. Failing that, if a default external encoding was\nspecified on the command-line, that value is used. If the encoding is\nunknown, nil is returned.\n
lineno ARGF.lineno()\nReturns the current line number of ARGF as a whole. This value\ncan be set manually with +ARGF.lineno=+.\n\nFor example:\n\n    ARGF.lineno   #=> 0\n    ARGF.readline #=> "This is line 1\\n"\n    ARGF.lineno   #=> 1\n
lineno= ARGF.lineno=(p1)\nSets the line number of +ARGF+ as a whole to the given +Integer+.\n\n+ARGF+ sets the line number automatically as you read data, so normally\nyou will not need to set it explicitly. To access the current line number\nuse +ARGF.lineno+.\n\nFor example:\n\n    ARGF.lineno      #=> 0\n    ARGF.readline    #=> "This is line 1\\n"\n    ARGF.lineno      #=> 1\n    ARGF.lineno = 0  #=> nil\n    ARGF.lineno      #=> 0\n
lines ARGF.lines(...)\n   ARGF.each_line(sep=$/)       {|line| block }  -> ARGF\n   ARGF.each_line(sep=$/,limit) {|line| block }  -> ARGF\n   ARGF.each_line(...)                           -> an_enumerator\n\n   ARGF.lines(sep=$/)           {|line| block }   -> ARGF\n   ARGF.lines(sep=$/,limit)     {|line| block }   -> ARGF\n   ARGF.lines(...)                                -> an_enumerator\n\nReturns an enumerator which iterates over each line (separated by _sep_,\nwhich defaults to your platform's newline character) of each file in\n+ARGV+. If a block is supplied, each line in turn will be yielded to the\nblock, otherwise an enumerator is returned.\nThe optional _limit_ argument is a +Fixnum+ specifying the maximum\nlength of each line; longer lines will be split according to this limit.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last line of the first file has been returned, the first line of the\nsecond file is returned. The +ARGF.filename+ and +ARGF.lineno+ methods can\nbe used to determine the filename and line number, respectively, of the\ncurrent line.\n\nFor example, the following code prints out each line of each named file\nprefixed with its line number, displaying the filename once per file:\n\n   ARGF.lines do |line|\n     puts ARGF.filename if ARGF.lineno == 1\n     puts "#{ARGF.lineno}: #{line}"\n   end\n
path ARGF.path()\nReturns the current filename. "-" is returned when the current file is\nSTDIN.\n\nFor example:\n\n   $ echo "foo" > foo\n   $ echo "bar" > bar\n   $ echo "glark" > glark\n\n   $ ruby argf.rb foo bar glark\n\n   ARGF.filename  #=> "foo"\n   ARGF.read(5)   #=> "foo\\nb"\n   ARGF.filename  #=> "bar"\n   ARGF.skip\n   ARGF.filename  #=> "glark"\n
pos ARGF.pos()\nReturns the current offset (in bytes) of the current file in +ARGF+.\n\n   ARGF.pos    #=> 0\n   ARGF.gets   #=> "This is line one\\n"\n   ARGF.pos    #=> 17\n
pos= ARGF.pos=(p1)\nSeeks to the position given by _position_ (in bytes) in +ARGF+.\n\nFor example:\n\n    ARGF.pos = 17\n    ARGF.gets   #=> "This is line two\\n"\n
read ARGF.read(...)\n\n Reads _length_ bytes from ARGF. The files named on the command line\n are concatenated and treated as a single file by this method, so when\n called without arguments the contents of this pseudo file are returned in\n their entirety.\n\n _length_ must be a non-negative integer or nil. If it is a positive\n integer, +read+ tries to read at most _length_ bytes. It returns nil\n if an EOF was encountered before anything could be read. Fewer than\n _length_ bytes may be returned if an EOF is encountered during the read.\n\n If _length_ is omitted or is _nil_, it reads until EOF. A String is\n returned even if EOF is encountered before any data is read.\n\n If _length_ is zero, it returns _""_.\n\n If the optional _buffer_ argument is present, it must reference a String,\n which will receive the data.\n\nFor example:\n\n    $ echo "small" > small.txt\n    $ echo "large" > large.txt\n    $ ./glark.rb small.txt large.txt\n\n    ARGF.read      #=> "small\\nlarge"\n    ARGF.read(200) #=> "small\\nlarge"\n    ARGF.read(2)   #=> "sm"\n    ARGF.read(0)   #=> ""\n\n Note that this method behaves like fread() function in C.  If you need the\n behavior like read(2) system call, consider +ARGF.readpartial+.\n
readbyte ARGF.readbyte()\nReads the next 8-bit byte from ARGF and returns it as a +Fixnum+. Raises\nan +EOFError+ after the last byte of the last file has been read.\n\nFor example:\n\n   $ echo "foo" > file\n   $ ruby argf.rb file\n\n   ARGF.readbyte  #=> 102\n   ARGF.readbyte  #=> 111\n   ARGF.readbyte  #=> 111\n   ARGF.readbyte  #=> 10\n   ARGF.readbyte  #=> end of file reached (EOFError)\n
readchar ARGF.readchar()\nReads the next character from +ARGF+ and returns it as a +String+. Raises\nan +EOFError+ after the last character of the last file has been read.\n\nFor example:\n\n   $ echo "foo" > file\n   $ ruby argf.rb file\n\n   ARGF.readchar  #=> "f"\n   ARGF.readchar  #=> "o"\n   ARGF.readchar  #=> "o"\n   ARGF.readchar  #=> "\\n"\n   ARGF.readchar  #=> end of file reached (EOFError)\n
readline ARGF.readline(...)\nReturns the next line from the current file in +ARGF+.\n\nBy default lines are assumed to be separated by +$/+; to use a different\ncharacter as a separator, supply it as a +String+ for the _sep_ argument.\n\nThe optional  _limit_ argument specifies how many characters of each line\nto return. By default all characters are returned.\n\nAn +EOFError+ is raised at the end of the file.\n
readlines ARGF.readlines(...)\n   ARGF.to_a(sep=$/)     -> array\n   ARGF.to_a(limit)      -> array\n   ARGF.to_a(sep, limit) -> array\n\nReads +ARGF+'s current file in its entirety, returning an +Array+ of its\nlines, one line per element. Lines are assumed to be separated by _sep_.\n\n   lines = ARGF.readlines\n   lines[0]                #=> "This is line one\\n"\n
readpartial ARGF.readpartial(...)\nReads at most _maxlen_ bytes from the ARGF stream. It blocks only if\n+ARGF+ has no data immediately available. If the optional _outbuf_\nargument is present, it must reference a String, which will receive the\ndata. It raises `EOFError` on end of file.\n\n+readpartial+ is designed for streams such as pipes, sockets, and ttys. It\nblocks only when no data is immediately available. This means that it\nblocks only when following all conditions hold:\n\n* The byte buffer in the +IO+ object is empty.\n* The content of the stream is empty.\n* The stream has not reached EOF.\n\nWhen +readpartial+ blocks, it waits for data or EOF. If some data is read,\n+readpartial+ returns with the data. If EOF is reached, readpartial raises\nan +EOFError+.\n\nWhen +readpartial+ doesn't block, it returns or raises immediately.  If\nthe byte buffer is not empty, it returns the data in the buffer. Otherwise, if\nthe stream has some content, it returns the data in the stream. If the\nstream reaches EOF an +EOFError+ is raised.\n
rewind ARGF.rewind()\nPositions the current file to the beginning of input, resetting\n+ARGF.lineno+ to zero.\n\n   ARGF.readline   #=> "This is line one\\n"\n   ARGF.rewind     #=> 0\n   ARGF.lineno     #=> 0\n   ARGF.readline   #=> "This is line one\\n"\n
seek ARGF.seek(...)\nSeeks to offset _amount_ (an +Integer+) in the +ARGF+ stream according to\nthe value of _whence_. See +IO#seek+ for further details.\n
set_encoding ARGF.set_encoding(...)\nIf single argument is specified, strings read from ARGF are tagged with\nthe encoding specified.\n\nIf two encoding names separated by a colon are given, e.g. "ascii:utf-8",\nthe read string is converted from the first encoding (external encoding)\nto the second encoding (internal encoding), then tagged with the second\nencoding.\n\nIf two arguments are specified, they must be encoding objects or encoding\nnames. Again, the first specifies the external encoding; the second\nspecifies the internal encoding.\n\nIf the external encoding and the internal encoding are specified, the\noptional +Hash+ argument can be used to adjust the conversion process. The\nstructure of this hash is explained in the +String#encode+ documentation.\n\nFor example:\n\n    ARGF.set_encoding('ascii')         # Tag the input as US-ASCII text\n    ARGF.set_encoding(Encoding::UTF_8) # Tag the input as UTF-8 text\n    ARGF.set_encoding('utf-8','ascii') # Transcode the input from US-ASCII\n to UTF-8.\n
skip ARGF.skip()\n\n Sets the current file to the next file in ARGV. If there aren't any more\n files it has no effect.\n\nFor example:\n\n    $ ruby argf.rb foo bar\n    ARGF.filename  #=> "foo"\n    ARGF.skip\n    ARGF.filename  #=> "bar"\n
tell ARGF.tell()\nReturns the current offset (in bytes) of the current file in +ARGF+.\n\n   ARGF.pos    #=> 0\n   ARGF.gets   #=> "This is line one\\n"\n   ARGF.pos    #=> 17\n
to_a ARGF.to_a(...)\n   ARGF.to_a(sep=$/)     -> array\n   ARGF.to_a(limit)      -> array\n   ARGF.to_a(sep, limit) -> array\n\nReads +ARGF+'s current file in its entirety, returning an +Array+ of its\nlines, one line per element. Lines are assumed to be separated by _sep_.\n\n   lines = ARGF.readlines\n   lines[0]                #=> "This is line one\\n"\n
to_i ARGF.to_i()\nReturns an integer representing the numeric file descriptor for\nthe current file. Raises an +ArgumentError+ if there isn't a current file.\n\n   ARGF.fileno    #=> 3\n
to_io ARGF.to_io()\nReturns an +IO+ object representing the current file. This will be a\n+File+ object unless the current file is a stream such as STDIN.\n\nFor example:\n\n   ARGF.to_io    #=> #<File:glark.txt>\n   ARGF.to_io    #=> #<IO:<STDIN>>\n
to_s ARGF.to_s()\nReturns "ARGF".\n
ceil Integer.ceil()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
chr Integer.chr(...)\nReturns a string containing the character represented by the\nreceiver's value according to +encoding+.\n\n   65.chr    #=> "A"\n   230.chr   #=> "\346"\n   255.chr(Encoding::UTF_8)   #=> "\303\277"\n
denominator Integer.denominator()\nReturns 1.\n
downto Integer.downto(p1)\nIterates <em>block</em>, passing decreasing values from <i>int</i>\ndown to and including <i>limit</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   5.downto(1) { |n| print n, ".. " }\n   print "  Liftoff!\\n"\n\n<em>produces:</em>\n\n   5.. 4.. 3.. 2.. 1..   Liftoff!\n
even? Integer.even?()\nReturns `true` if <i>int</i> is an even number.\n
floor Integer.floor()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
gcd Integer.gcd(p1)\nReturns the greatest common divisor (always positive).  0.gcd(x)\nand x.gcd(0) return abs(x).\n\nFor example:\n\n   2.gcd(2)                    #=> 2\n   3.gcd(-7)                   #=> 1\n   ((1<<31)-1).gcd((1<<61)-1)  #=> 1\n
gcdlcm Integer.gcdlcm(p1)\nReturns an array; [int.gcd(int2), int.lcm(int2)].\n\nFor example:\n\n   2.gcdlcm(2)                    #=> [2, 2]\n   3.gcdlcm(-7)                   #=> [1, 21]\n   ((1<<31)-1).gcdlcm((1<<61)-1)  #=> [1, 4951760154835678088235319297]\n
integer? Integer.integer?()\nAlways returns `true`.\n
lcm Integer.lcm(p1)\nReturns the least common multiple (always positive).  0.lcm(x) and\nx.lcm(0) return zero.\n\nFor example:\n\n   2.lcm(2)                    #=> 2\n   3.lcm(-7)                   #=> 21\n   ((1<<31)-1).lcm((1<<61)-1)  #=> 4951760154835678088235319297\n
next Integer.next()\nReturns the `Integer` equal to <i>int</i> + 1.\n\n   1.next      #=> 2\n   (-1).next   #=> 0\n
numerator Integer.numerator()\nReturns self.\n
odd? Integer.odd?()\nReturns `true` if <i>int</i> is an odd number.\n
ord Integer.ord()\nReturns the int itself.\n\n   ?a.ord    #=> 97\n\nThis method is intended for compatibility to\ncharacter constant in Ruby 1.9.\nFor example, ?a.ord returns 97 both in 1.8 and 1.9.\n
pred Integer.pred()\nReturns the `Integer` equal to <i>int</i> - 1.\n\n   1.pred      #=> 0\n   (-1).pred   #=> -2\n
rationalize Integer.rationalize(...)\nReturns the value as a rational.  An optional argument eps is\nalways ignored.\n
round Integer.round(...)\nRounds <i>flt</i> to a given precision in decimal digits (default 0 digits).\nPrecision may be negative.  Returns a floating point number when +ndigits+\nis positive, +self+ for zero, and round down for negative.\n\n   1.round        #=> 1\n   1.round(2)     #=> 1.0\n   15.round(-1)   #=> 20\n
succ Integer.succ()\nReturns the `Integer` equal to <i>int</i> + 1.\n\n   1.next      #=> 2\n   (-1).next   #=> 0\n
times Integer.times()\nIterates block <i>int</i> times, passing in values from zero to\n<i>int</i> - 1.\n\nIf no block is given, an enumerator is returned instead.\n\n   5.times do |i|\n     print i, " "\n   end\n\n<em>produces:</em>\n\n   0 1 2 3 4\n
to_i Integer.to_i()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
to_int Integer.to_int()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
to_r Integer.to_r()\nReturns the value as a rational.\n\nFor example:\n\n   1.to_r        #=> (1/1)\n   (1<<64).to_r  #=> (18446744073709551616/1)\n
truncate Integer.truncate()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
upto Integer.upto(p1)\nIterates <em>block</em>, passing in integer values from <i>int</i>\nup to and including <i>limit</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   5.upto(10) { |i| print i, " " }\n\n<em>produces:</em>\n\n   5 6 7 8 9 10\n
abs Fixnum.abs()\nReturns the absolute value of <i>fix</i>.\n\n   -12345.abs   #=> 12345\n   12345.abs    #=> 12345\n
div Fixnum.div(p1)\nPerforms integer division: returns integer value.\n
divmod Fixnum.divmod(p1)\nSee `Numeric#divmod`.\n
even? Fixnum.even?()\nReturns `true` if <i>fix</i> is an even number.\n
fdiv Fixnum.fdiv(p1)\nReturns the floating point result of dividing <i>fix</i> by\n<i>numeric</i>.\n\n   654321.fdiv(13731)      #=> 47.6528293642124\n   654321.fdiv(13731.24)   #=> 47.6519964693647\n
magnitude Fixnum.magnitude()\nReturns the absolute value of <i>fix</i>.\n\n   -12345.abs   #=> 12345\n   12345.abs    #=> 12345\n
modulo Fixnum.modulo(p1)\nReturns `fix` modulo `other`.\nSee `numeric.divmod` for more information.\n
odd? Fixnum.odd?()\nReturns `true` if <i>fix</i> is an odd number.\n
size Fixnum.size()\nReturns the number of <em>bytes</em> in the machine representation\nof a `Fixnum`.\n\n   1.size            #=> 4\n   -1.size           #=> 4\n   2147483647.size   #=> 4\n
succ Fixnum.succ()\nReturns the `Integer` equal to <i>int</i> + 1.\n\n   1.next      #=> 2\n   (-1).next   #=> 0\n
to_f Fixnum.to_f()\nConverts <i>fix</i> to a `Float`.\n
to_s Fixnum.to_s(...)\nReturns a string containing the representation of <i>fix</i> radix\n<i>base</i> (between 2 and 36).\n\n   12345.to_s       #=> "12345"\n   12345.to_s(2)    #=> "11000000111001"\n   12345.to_s(8)    #=> "30071"\n   12345.to_s(10)   #=> "12345"\n   12345.to_s(16)   #=> "3039"\n   12345.to_s(36)   #=> "9ix"\n
zero? Fixnum.zero?()\nReturns `true` if <i>fix</i> is zero.\n
to_s TrueClass.to_s()\nThe string representation of `true` is "true".\n
to_s FalseClass.to_s()\n'nuf said...\n
new Ripper.new(...)\nCreate a new Ripper object.\n_src_ must be a String, an IO, or an Object which has #gets method.\n\nThis method does not starts parsing.\nSee also Ripper#parse and Ripper.parse.\n
column Ripper.column()\nReturn column number of current parsing line.\nThis number starts from 0.\n
encoding Ripper.encoding()\nReturn encoding of the source.\n
end_seen? Ripper.end_seen?()\nReturn if parsed source ended by +\_\_END\_\_+.\nThis number starts from 1.\n
filename Ripper.filename()\nReturn current parsing filename.\n
lineno Ripper.lineno()\nReturn line number of current parsing line.\nThis number starts from 1.\n
parse Ripper.parse()\nStart parsing and returns the value of the root action.\n
yydebug Ripper.yydebug()\nGet yydebug.\n
yydebug= Ripper.yydebug=(p1)\nSet yydebug.\n
new Proc.new(...)\nCreates a new `Proc` object, bound to the current\ncontext. `Proc::new` may be called without a block only\nwithin a method with an attached block, in which case that block is\nconverted to the `Proc` object.\n\n   def proc_from\n     Proc.new\n   end\n   proc = proc_from { "hello" }\n   proc.call   #=> "hello"\n
arity Proc.arity()\nReturns the number of arguments that would not be ignored. If the block\nis declared to take no arguments, returns 0. If the block is known\nto take exactly n arguments, returns n. If the block has optional\narguments, return -n-1, where n is the number of mandatory\narguments. A `proc` with no argument declarations\nis the same a block declaring `||` as its arguments.\n\n   Proc.new {}.arity          #=>  0\n   Proc.new {||}.arity        #=>  0\n   Proc.new {|a|}.arity       #=>  1\n   Proc.new {|a,b|}.arity     #=>  2\n   Proc.new {|a,b,c|}.arity   #=>  3\n   Proc.new {|*a|}.arity      #=> -1\n   Proc.new {|a,*b|}.arity    #=> -2\n   Proc.new {|a,*b, c|}.arity    #=> -3\n
binding Proc.binding()\nReturns the binding associated with <i>prc</i>. Note that\n`Kernel#eval` accepts either a `Proc` or a\n`Binding` object as its second parameter.\n\n   def fred(param)\n     proc {}\n   end\n\n   b = fred(99)\n   eval("param", b.binding)   #=> 99\n
call Proc.call(...)\nInvokes the block, with <i>obj</i> as the block's parameter.  It is\nto allow a proc object to be a target of +when+ clause in the case statement.\n
curry Proc.curry(...)\nReturns a curried proc. If the optional <i>arity</i> argument is given,\nit determines the number of arguments.\nA curried proc receives some arguments. If a sufficient number of\narguments are supplied, it passes the supplied arguments to the original\nproc and returns the result. Otherwise, returns another curried proc that\ntakes the rest of arguments.\n\n   b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 6\n   p b.curry(5)[1][2][3][4][5]  #=> 6\n   p b.curry(5)[1, 2][3, 4][5]  #=> 6\n   p b.curry(1)[1]              #=> 1\n\n   b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 10\n   p b.curry(5)[1][2][3][4][5]  #=> 15\n   p b.curry(5)[1, 2][3, 4][5]  #=> 15\n   p b.curry(1)[1]              #=> 1\n\n   b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> wrong number of arguments (4 for 3)\n   p b.curry(5)                 #=> wrong number of arguments (5 for 3)\n   p b.curry(1)                 #=> wrong number of arguments (1 for 3)\n\n   b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 10\n   p b.curry(5)[1][2][3][4][5]  #=> 15\n   p b.curry(5)[1, 2][3, 4][5]  #=> 15\n   p b.curry(1)                 #=> wrong number of arguments (1 for 3)\n\n   b = proc { :foo }\n   p b.curry[]                  #=> :foo\n
eql? Proc.eql?(p1)\nReturn `true` if <i>prc</i> is the same object as\n<i>other_proc</i>, or if they are both procs with the same body.\n
hash Proc.hash()\nReturn hash value corresponding to proc body.\n
lambda? Proc.lambda?()\nReturns true for a Proc object which argument handling is rigid.\nSuch procs are typically generated by lambda.\n\nA Proc object generated by proc ignore extra arguments.\n\n  proc {|a,b| [a,b] }.call(1,2,3)    #=> [1,2]\n\nIt provides nil for lacked arguments.\n\n  proc {|a,b| [a,b] }.call(1)        #=> [1,nil]\n\nIt expand single-array argument.\n\n  proc {|a,b| [a,b] }.call([1,2])    #=> [1,2]\n\nA Proc object generated by lambda doesn't have such tricks.\n\n  lambda {|a,b| [a,b] }.call(1,2,3)  #=> ArgumentError\n  lambda {|a,b| [a,b] }.call(1)      #=> ArgumentError\n  lambda {|a,b| [a,b] }.call([1,2])  #=> ArgumentError\n\nProc#lambda? is a predicate for the tricks.\nIt returns true if no tricks.\n\n  lambda {}.lambda?            #=> true\n  proc {}.lambda?              #=> false\n\nProc.new is same as proc.\n\n  Proc.new {}.lambda?          #=> false\n\nlambda, proc and Proc.new preserves the tricks of\na Proc object given by & argument.\n\n  lambda(&lambda {}).lambda?   #=> true\n  proc(&lambda {}).lambda?     #=> true\n  Proc.new(&lambda {}).lambda? #=> true\n\n  lambda(&proc {}).lambda?     #=> false\n  proc(&proc {}).lambda?       #=> false\n  Proc.new(&proc {}).lambda?   #=> false\n\nA Proc object generated by & argument has the tricks\n\n  def n(&b) b.lambda? end\n  n {}                         #=> false\n\nThe & argument preserves the tricks if a Proc object is given\nby & argument.\n\n  n(&lambda {})                #=> true\n  n(&proc {})                  #=> false\n  n(&Proc.new {})              #=> false\n\nA Proc object converted from a method has no tricks.\n\n  def m() end\n  method(:m).to_proc.lambda?   #=> true\n\n  n(&method(:m))               #=> true\n  n(&method(:m).to_proc)       #=> true\n\ndefine_method is treated same as method definition.\nThe defined method has no tricks.\n\n  class C\n    define_method(:d) {}\n  end\n  C.new.e(1,2)       #=> ArgumentError\n  C.new.method(:d).to_proc.lambda?   #=> true\n\ndefine_method always defines a method without the tricks,\neven if a non-lambda Proc object is given.\nThis is the only exception which the tricks are not preserved.\n\n  class C\n    define_method(:e, &proc {})\n  end\n  C.new.e(1,2)       #=> ArgumentError\n  C.new.method(:e).to_proc.lambda?   #=> true\n\nThis exception is for a wrapper of define_method.\nIt eases defining a method defining method which defines a usual method\nwhich has no tricks.\n\n  class << C\n    def def2(name, &body)\n      define_method(name, &body)\n    end\n  end\n  class C\n    def2(:f) {}\n  end\n  C.new.f(1,2)       #=> ArgumentError\n\nThe wrapper, def2, defines a method which has no tricks.\n
parameters Proc.parameters()\nreturns the parameter information of this proc.\n\n   prc = lambda{|x, y=42, *rest|}\n   prc.parameters  #=> [[:req, :x], [:opt, :y], [:rest, :rest]]\n
source_location Proc.source_location()\nreturns the ruby source filename and line number containing this proc\nor nil if this proc was not defined in ruby (i.e. native)\n
to_proc Proc.to_proc()\nPart of the protocol for converting objects to `Proc`\nobjects. Instances of class `Proc` simply return\nthemselves.\n
to_s Proc.to_s()\nShows the unique identifier for this proc, along with\nan indication of where the proc was defined.\n
yield Proc.yield(...)\nInvokes the block, with <i>obj</i> as the block's parameter.  It is\nto allow a proc object to be a target of +when+ clause in the case statement.\n
exit_value LocalJumpError.exit_value()\ncall_seq:\n  local_jump_error.exit_value  -> obj\n\nReturns the exit value associated with this +LocalJumpError+.\n
reason LocalJumpError.reason()\nThe reason this block was terminated:\n:break, :redo, :retry, :next, :return, or :noreason.\n
arity Method.arity()\nReturns an indication of the number of arguments accepted by a\nmethod. Returns a nonnegative integer for methods that take a fixed\nnumber of arguments. For Ruby methods that take a variable number of\narguments, returns -n-1, where n is the number of required\narguments. For methods written in C, returns -1 if the call takes a\nvariable number of arguments.\n\n   class C\n     def one;    end\n     def two(a); end\n     def three(*a);  end\n     def four(a, b); end\n     def five(a, b, *c);    end\n     def six(a, b, *c, &d); end\n   end\n   c = C.new\n   c.method(:one).arity     #=> 0\n   c.method(:two).arity     #=> 1\n   c.method(:three).arity   #=> -1\n   c.method(:four).arity    #=> 2\n   c.method(:five).arity    #=> -3\n   c.method(:six).arity     #=> -3\n\n   "cat".method(:size).arity      #=> 0\n   "cat".method(:replace).arity   #=> 1\n   "cat".method(:squeeze).arity   #=> -1\n   "cat".method(:count).arity     #=> -1\n
call Method.call(...)\nInvokes the <i>meth</i> with the specified arguments, returning the\nmethod's return value.\n\n   m = 12.method("+")\n   m.call(3)    #=> 15\n   m.call(20)   #=> 32\n
clone Method.clone()\nMISSING: documentation\n
eql? Method.eql?(p1)\nTwo method objects are equal if they are bound to the same\nobject and refer to the same method definition.\n
hash Method.hash()\nReturn a hash value corresponding to the method object.\n
inspect Method.inspect()\nShow the name of the underlying method.\n\n  "cat".method(:count).inspect   #=> "#<Method: String#count>"\n
name Method.name()\nReturns the name of the method.\n
owner Method.owner()\nReturns the class or module that defines the method.\n
parameters Method.parameters()\nreturns the parameter information of this method\n
receiver Method.receiver()\nReturns the bound receiver of the method object.\n
source_location Method.source_location()\nreturns the ruby source filename and line number containing this method\nor nil if this method was not defined in ruby (i.e. native)\n
to_proc Method.to_proc()\nReturns a `Proc` object corresponding to this method.\n
to_s Method.to_s()\nShow the name of the underlying method.\n\n  "cat".method(:count).inspect   #=> "#<Method: String#count>"\n
unbind Method.unbind()\nDissociates <i>meth</i> from it's current receiver. The resulting\n`UnboundMethod` can subsequently be bound to a new object\nof the same class (see `UnboundMethod`).\n
arity UnboundMethod.arity()\nReturns an indication of the number of arguments accepted by a\nmethod. Returns a nonnegative integer for methods that take a fixed\nnumber of arguments. For Ruby methods that take a variable number of\narguments, returns -n-1, where n is the number of required\narguments. For methods written in C, returns -1 if the call takes a\nvariable number of arguments.\n\n   class C\n     def one;    end\n     def two(a); end\n     def three(*a);  end\n     def four(a, b); end\n     def five(a, b, *c);    end\n     def six(a, b, *c, &d); end\n   end\n   c = C.new\n   c.method(:one).arity     #=> 0\n   c.method(:two).arity     #=> 1\n   c.method(:three).arity   #=> -1\n   c.method(:four).arity    #=> 2\n   c.method(:five).arity    #=> -3\n   c.method(:six).arity     #=> -3\n\n   "cat".method(:size).arity      #=> 0\n   "cat".method(:replace).arity   #=> 1\n   "cat".method(:squeeze).arity   #=> -1\n   "cat".method(:count).arity     #=> -1\n
bind UnboundMethod.bind(p1)\nBind <i>umeth</i> to <i>obj</i>. If `Klass` was the class\nfrom which <i>umeth</i> was obtained,\n`obj.kind_of?(Klass)` must be true.\n\n   class A\n     def test\n       puts "In test, class = #{self.class}"\n     end\n   end\n   class B < A\n   end\n   class C < B\n   end\n\n\n   um = B.instance_method(:test)\n   bm = um.bind(C.new)\n   bm.call\n   bm = um.bind(B.new)\n   bm.call\n   bm = um.bind(A.new)\n   bm.call\n\n<em>produces:</em>\n\n   In test, class = C\n   In test, class = B\n   prog.rb:16:in `bind': bind argument must be an instance of B (TypeError)\n    from prog.rb:16\n
clone UnboundMethod.clone()\nMISSING: documentation\n
eql? UnboundMethod.eql?(p1)\nTwo method objects are equal if they are bound to the same\nobject and refer to the same method definition.\n
hash UnboundMethod.hash()\nReturn a hash value corresponding to the method object.\n
inspect UnboundMethod.inspect()\nShow the name of the underlying method.\n\n  "cat".method(:count).inspect   #=> "#<Method: String#count>"\n
name UnboundMethod.name()\nReturns the name of the method.\n
owner UnboundMethod.owner()\nReturns the class or module that defines the method.\n
parameters UnboundMethod.parameters()\nreturns the parameter information of this method\n
source_location UnboundMethod.source_location()\nreturns the ruby source filename and line number containing this method\nor nil if this method was not defined in ruby (i.e. native)\n
to_s UnboundMethod.to_s()\nShow the name of the underlying method.\n\n  "cat".method(:count).inspect   #=> "#<Method: String#count>"\n
eval Binding.eval(...)\nEvaluates the Ruby expression(s) in <em>string</em>, in the\n<em>binding</em>'s context.  If the optional <em>filename</em> and\n<em>lineno</em> parameters are present, they will be used when\nreporting syntax errors.\n\n   def getBinding(param)\n     return binding\n   end\n   b = getBinding("hello")\n   b.eval("param")   #=> "hello"\n
coredump? Process::Status.coredump?()\nReturns +true+ if _stat_ generated a coredump\nwhen it terminated. Not available on all platforms.\n
exited? Process::Status.exited?()\nReturns +true+ if _stat_ exited normally (for\nexample using an `exit()` call or finishing the\nprogram).\n
exitstatus Process::Status.exitstatus()\nReturns the least significant eight bits of the return code of\n_stat_. Only available if `exited?` is\n+true+.\n\n   fork { }           #=> 26572\n   Process.wait       #=> 26572\n   $?.exited?         #=> true\n   $?.exitstatus      #=> 0\n\n   fork { exit 99 }   #=> 26573\n   Process.wait       #=> 26573\n   $?.exited?         #=> true\n   $?.exitstatus      #=> 99\n
inspect Process::Status.inspect()\nOverride the inspection method.\n
pid Process::Status.pid()\nReturns the process ID that this status object represents.\n\n   fork { exit }   #=> 26569\n   Process.wait    #=> 26569\n   $?.pid          #=> 26569\n
signaled? Process::Status.signaled?()\nReturns +true+ if _stat_ terminated because of\nan uncaught signal.\n
stopped? Process::Status.stopped?()\nReturns +true+ if this process is stopped. This is only\nreturned if the corresponding `wait` call had the\n`WUNTRACED` flag set.\n
stopsig Process::Status.stopsig()\nReturns the number of the signal that caused _stat_ to stop\n(or +nil+ if self is not stopped).\n
success? Process::Status.success?()\nReturns +true+ if _stat_ is successful, +false+ if not.\nReturns +nil+ if `exited?` is not +true+.\n
termsig Process::Status.termsig()\nReturns the number of the signal that caused _stat_ to\nterminate (or +nil+ if self was not terminated by an\nuncaught signal).\n
to_i Process::Status.to_i()\nReturns the bits in _stat_ as a `Fixnum`. Poking\naround in these bits is platform dependent.\n\n   fork { exit 0xab }         #=> 26566\n   Process.wait               #=> 26566\n   sprintf('%04x', $?.to_i)   #=> "ab00"\n
to_s Process::Status.to_s()\nShow pid and exit status as a string.\n
new Random.new(...)\nCreates new Mersenne Twister based pseudorandom number generator with\nseed.  When the argument seed is omitted, the generator is initialized\nwith Random.new_seed.\n\nThe argument seed is used to ensure repeatable sequences of random numbers\nbetween different runs of the program.\n\n    prng = Random.new(1234)\n    [ prng.rand, prng.rand ]   #=> [0.191519450378892, 0.622108771039832]\n    [ prng.integer(10), prng.integer(1000) ]  #=> [4, 664]\n    prng = Random.new(1234)\n    [ prng.rand, prng.rand ]   #=> [0.191519450378892, 0.622108771039832]\n
new_seed Random.new_seed()\nReturns arbitrary value for seed.\n
rand Random.rand(...)\nConverts <i>max</i> to an integer using max1 =\nmax`.to_i.abs`. If _max_ is +nil+ the result is zero, returns a\npseudorandom floating point number greater than or equal to 0.0 and\nless than 1.0. Otherwise, returns a pseudorandom integer greater\nthan or equal to zero and less than max1. `Kernel::srand`\nmay be used to ensure repeatable sequences of random numbers between\ndifferent runs of the program. Ruby currently uses a modified\nMersenne Twister with a period of 2**19937-1.\n\n   srand 1234                 #=> 0\n   [ rand,  rand ]            #=> [0.191519450163469, 0.49766366626136]\n   [ rand(10), rand(1000) ]   #=> [6, 817]\n   srand 1234                 #=> 1234\n   [ rand,  rand ]            #=> [0.191519450163469, 0.49766366626136]\n
srand Random.srand(...)\nSeeds the pseudorandom number generator to the value of\n<i>number</i>. If <i>number</i> is omitted\nor zero, seeds the generator using a combination of the time, the\nprocess id, and a sequence number. (This is also the behavior if\n`Kernel::rand` is called without previously calling\n`srand`, but without the sequence.) By setting the seed\nto a known value, scripts can be made deterministic during testing.\nThe previous seed value is returned. Also see `Kernel::rand`.\n
bytes Random.bytes(p1)\nReturns a random binary string.  The argument size specified the length of\nthe result string.\n
rand Random.rand(...)\nWhen the argument is an +Integer+ or a +Bignum+, it returns a\nrandom integer greater than or equal to zero and less than the\nargument.  Unlike Random.rand, when the argument is a negative\ninteger or zero, it raises an ArgumentError.\n\nWhen the argument is a +Float+, it returns a random floating point\nnumber between 0.0 and _max_, including 0.0 and excluding _max_.\n\nWhen the argument _limit_ is a +Range+, it returns a random\nnumber where range.member?(number) == true.\n    prng.rand(5..9)  #=> one of [5, 6, 7, 8, 9]\n    prng.rand(5...9) #=> one of [5, 6, 7, 8]\n    prng.rand(5.0..9.0) #=> between 5.0 and 9.0, including 9.0\n    prng.rand(5.0...9.0) #=> between 5.0 and 9.0, excluding 9.0\n\n+begin+/+end+ of the range have to have subtract and add methods.\n\nOtherwise, it raises an ArgumentError.\n
seed Random.seed()\nReturns the seed of the generator.\n
new Range.new(...)\nConstructs a range using the given <i>start</i> and <i>end</i>. If the third\nparameter is omitted or is `false`, the <i>range</i> will include\nthe end object; otherwise, it will be excluded.\n
begin Range.begin()\nReturns the first object in <i>rng</i>.\n
cover? Range.cover?(p1)\nReturns `true` if <i>obj</i> is between beg and end,\ni.e `beg <= obj <= end` (or <i>end</i> exclusive when\n`exclude_end?` is true).\n\n   ("a".."z").cover?("c")    #=> true\n   ("a".."z").cover?("5")    #=> false\n
each Range.each()\nIterates over the elements <i>rng</i>, passing each in turn to the\nblock. You can only iterate if the start object of the range\nsupports the +succ+ method (which means that you can't iterate over\nranges of +Float+ objects).\n\nIf no block is given, an enumerator is returned instead.\n\n   (10..15).each do |n|\n      print n, ' '\n   end\n\n<em>produces:</em>\n\n   10 11 12 13 14 15\n
end Range.end()\nReturns the object that defines the end of <i>rng</i>.\n\n   (1..10).end    #=> 10\n   (1...10).end   #=> 10\n
eql? Range.eql?(p1)\nReturns `true` only if <i>obj</i> is a Range, has equivalent\nbeginning and end items (by comparing them with #eql?), and has the same\nexclude_end? setting as <i>rng</i>.\n\n  (0..2).eql?(0..2)            #=> true\n  (0..2).eql?(Range.new(0,2))  #=> true\n  (0..2).eql?(0...2)           #=> false\n
exclude_end? Range.exclude_end?()\nReturns `true` if <i>rng</i> excludes its end value.\n
first Range.first(...)\nReturns the first object in <i>rng</i>, or the first +n+ elements.\n
hash Range.hash()\nGenerate a hash value such that two ranges with the same start and\nend points, and the same value for the "exclude end" flag, generate\nthe same hash value.\n
include? Range.include?(p1)\nReturns `true` if <i>obj</i> is an element of\n<i>rng</i>, `false` otherwise.  If beg and end are\nnumeric, comparison is done according magnitude of values.\n\n   ("a".."z").include?("g")  # -> true\n   ("a".."z").include?("A")  # -> false\n
inspect Range.inspect()\nConvert this range object to a printable form (using\n`inspect` to convert the start and end\nobjects).\n
last Range.last(...)\nReturns the last object in <i>rng</i>, or the last +n+ elements.\n
max Range.max()\nReturns the maximum value in <i>rng</i>. The second uses\nthe block to compare values.  Returns nil if the first\nvalue in range is larger than the last value.\n
member? Range.member?(p1)\nReturns `true` if <i>obj</i> is an element of\n<i>rng</i>, `false` otherwise.  If beg and end are\nnumeric, comparison is done according magnitude of values.\n\n   ("a".."z").include?("g")  # -> true\n   ("a".."z").include?("A")  # -> false\n
min Range.min()\nReturns the minimum value in <i>rng</i>. The second uses\nthe block to compare values.  Returns nil if the first\nvalue in range is larger than the last value.\n
step Range.step(...)\nIterates over <i>rng</i>, passing each <i>n</i>th element to the block. If\nthe range contains numbers, <i>n</i> is added for each iteration.  Otherwise\n`step` invokes `succ` to iterate through range\nelements. The following code uses class `Xs`, which is defined\nin the class-level documentation.\n\nIf no block is given, an enumerator is returned instead.\n\n   range = Xs.new(1)..Xs.new(10)\n   range.step(2) {|x| puts x}\n   range.step(3) {|x| puts x}\n\n<em>produces:</em>\n\n    1 x\n    3 xxx\n    5 xxxxx\n    7 xxxxxxx\n    9 xxxxxxxxx\n    1 x\n    4 xxxx\n    7 xxxxxxx\n   10 xxxxxxxxxx\n
to_s Range.to_s()\nConvert this range object to a printable form.\n
ceil Rational.ceil(...)\nReturns the truncated value (toward positive infinity).\n\nFor example:\n\n   Rational(3).ceil      #=> 3\n   Rational(2, 3).ceil   #=> 1\n   Rational(-3, 2).ceil  #=> -1\n\n          decimal      -  1  2  3 . 4  5  6\n                         ^  ^  ^  ^   ^  ^\n         precision      -3 -2 -1  0  +1 +2\n\n   '%f' % Rational('-123.456').ceil(+1)  #=> "-123.400000"\n   '%f' % Rational('-123.456').ceil(-1)  #=> "-120.000000"\n
denominator Rational.denominator()\nReturns the denominator (always positive).\n\nFor example:\n\n   Rational(7).denominator             #=> 1\n   Rational(7, 1).denominator          #=> 1\n   Rational(9, -4).denominator         #=> 4\n   Rational(-2, -10).denominator       #=> 5\n   rat.numerator.gcd(rat.denominator)  #=> 1\n
fdiv Rational.fdiv(p1)\nPerforms division and returns the value as a float.\n\nFor example:\n\n   Rational(2, 3).fdiv(1)       #=> 0.6666666666666666\n   Rational(2, 3).fdiv(0.5)     #=> 1.3333333333333333\n   Rational(2).fdiv(3)          #=> 0.6666666666666666\n
floor Rational.floor(...)\nReturns the truncated value (toward negative infinity).\n\nFor example:\n\n   Rational(3).floor      #=> 3\n   Rational(2, 3).floor   #=> 0\n   Rational(-3, 2).floor  #=> -1\n\n          decimal      -  1  2  3 . 4  5  6\n                         ^  ^  ^  ^   ^  ^\n         precision      -3 -2 -1  0  +1 +2\n\n   '%f' % Rational('-123.456').floor(+1)  #=> "-123.500000"\n   '%f' % Rational('-123.456').floor(-1)  #=> "-130.000000"\n
inspect Rational.inspect()\nReturns the value as a string for inspection.\n\nFor example:\n\n   Rational(2).inspect      #=> "(2/1)"\n   Rational(-8, 6).inspect  #=> "(-4/3)"\n   Rational('0.5').inspect  #=> "(1/2)"\n
numerator Rational.numerator()\nReturns the numerator.\n\nFor example:\n\n   Rational(7).numerator        #=> 7\n   Rational(7, 1).numerator     #=> 7\n   Rational(9, -4).numerator    #=> -9\n   Rational(-2, -10).numerator  #=> 1\n
quo Rational.quo(p1)\nPerforms division.\n\nFor example:\n\n   Rational(2, 3)  / Rational(2, 3)   #=> (1/1)\n   Rational(900)   / Rational(1)      #=> (900/1)\n   Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)\n   Rational(9, 8)  / 4                #=> (9/32)\n   Rational(20, 9) / 9.8              #=> 0.22675736961451246\n
rationalize Rational.rationalize(...)\nReturns a simpler approximation of the value if an optional\nargument eps is given (rat-|eps| <= result <= rat+|eps|), self\notherwise.\n\nFor example:\n\n   r = Rational(5033165, 16777216)\n   r.rationalize                    #=> (5033165/16777216)\n   r.rationalize(Rational('0.01'))  #=> (3/10)\n   r.rationalize(Rational('0.1'))   #=> (1/3)\n
round Rational.round(...)\nReturns the truncated value (toward the nearest integer;\n0.5 => 1; -0.5 => -1).\n\nFor example:\n\n   Rational(3).round      #=> 3\n   Rational(2, 3).round   #=> 1\n   Rational(-3, 2).round  #=> -2\n\n          decimal      -  1  2  3 . 4  5  6\n                         ^  ^  ^  ^   ^  ^\n         precision      -3 -2 -1  0  +1 +2\n\n   '%f' % Rational('-123.456').round(+1)  #=> "-123.500000"\n   '%f' % Rational('-123.456').round(-1)  #=> "-120.000000"\n
to_f Rational.to_f()\nReturn the value as a float.\n\nFor example:\n\n   Rational(2).to_f      #=> 2.0\n   Rational(9, 4).to_f   #=> 2.25\n   Rational(-3, 4).to_f  #=> -0.75\n   Rational(20, 3).to_f  #=> 6.666666666666667\n
to_i Rational.to_i()\nReturns the truncated value as an integer.\n\nEquivalent to\n   rat.truncate.\n\nFor example:\n\n   Rational(2, 3).to_i   #=> 0\n   Rational(3).to_i      #=> 3\n   Rational(300.6).to_i  #=> 300\n   Rational(98,71).to_i  #=> 1\n   Rational(-30,2).to_i  #=> -15\n
to_r Rational.to_r()\nReturns self.\n\nFor example:\n\n   Rational(2).to_r      #=> (2/1)\n   Rational(-8, 6).to_r  #=> (-4/3)\n
to_s Rational.to_s()\nReturns the value as a string.\n\nFor example:\n\n   Rational(2).to_s      #=> "2/1"\n   Rational(-8, 6).to_s  #=> "-4/3"\n   Rational('0.5').to_s  #=> "1/2"\n
truncate Rational.truncate(...)\nReturns the truncated value (toward zero).\n\nFor example:\n\n   Rational(3).truncate      #=> 3\n   Rational(2, 3).truncate   #=> 0\n   Rational(-3, 2).truncate  #=> -1\n\n          decimal      -  1  2  3 . 4  5  6\n                         ^  ^  ^  ^   ^  ^\n         precision      -3 -2 -1  0  +1 +2\n\n   '%f' % Rational('-123.456').truncate(+1)  #=>  "-123.400000"\n   '%f' % Rational('-123.456').truncate(-1)  #=>  "-120.000000"\n
compile Regexp.compile(...)\nSynonym for `Regexp.new`\n
escape Regexp.escape(p1)\nEscapes any characters that would have special meaning in a regular\nexpression. Returns a new escaped string, or self if no characters are\nescaped.  For any string,\n`Regexp.new(Regexp.escape(<i>str</i>))=~<i>str</i>` will be true.\n\n   Regexp.escape('\*?{}.')   #=> \\\*\?\{\}\.\n
last_match Regexp.last_match(...)\nThe first form returns the `MatchData` object generated by the\nlast successful pattern match. Equivalent to reading the global variable\n`$~`. The second form returns the <i>n</i>th field in this\n`MatchData` object.\n<em>n</em> can be a string or symbol to reference a named capture.\n\nNote that the `last_match` is local to the thread and method scope\nof the method that did the pattern match.\n\n   /c(.)t/ =~ 'cat'        #=> 0\n   Regexp.last_match       #=> #<MatchData "cat" 1:"a">\n   Regexp.last_match(0)    #=> "cat"\n   Regexp.last_match(1)    #=> "a"\n   Regexp.last_match(2)    #=> nil\n\n   /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "var = val"\n   Regexp.last_match       #=> #<MatchData "var = val" lhs:"var" rhs:"val">\n   Regexp.last_match(:lhs) #=> "var"\n   Regexp.last_match(:rhs) #=> "val"\n
new Regexp.new(...)\nConstructs a new regular expression from <i>pattern</i>, which can be either\na `String` or a `Regexp` (in which case that regexp's\noptions are propagated, and new options may not be specified (a change as of\nRuby 1.8). If <i>options</i> is a `Fixnum`, it should be one or\nmore of the constants `Regexp::EXTENDED`,\n`Regexp::IGNORECASE`, and `Regexp::MULTILINE`,\n<em>or</em>-ed together. Otherwise, if <i>options</i> is not\n`nil`, the regexp will be case insensitive.\nWhen the <i>lang</i> parameter is `n' or `N' sets the regexp no encoding.\n\n   r1 = Regexp.new('^a-z+:\\s+\w+')           #=> /^a-z+:\s+\w+/\n   r2 = Regexp.new('cat', true)               #=> /cat/i\n   r3 = Regexp.new('dog', Regexp::EXTENDED)   #=> /dog/x\n   r4 = Regexp.new(r2)                        #=> /cat/i\n
quote Regexp.quote(p1)\nEscapes any characters that would have special meaning in a regular\nexpression. Returns a new escaped string, or self if no characters are\nescaped.  For any string,\n`Regexp.new(Regexp.escape(<i>str</i>))=~<i>str</i>` will be true.\n\n   Regexp.escape('\*?{}.')   #=> \\\*\?\{\}\.\n
try_convert Regexp.try_convert(p1)\nTry to convert <i>obj</i> into a Regexp, using to_regexp method.\nReturns converted regexp or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   Regexp.try_convert(/re/)         #=> /re/\n   Regexp.try_convert("re")         #=> nil\n\n   o = Object.new\n   Regexp.try_convert(o)            #=> nil\n   def o.to_regexp() /foo/ end\n   Regexp.try_convert(o)            #=> /foo/\n
union Regexp.union(...)\nReturn a `Regexp` object that is the union of the given\n<em>pattern</em>s, i.e., will match any of its parts. The <em>pattern</em>s\ncan be Regexp objects, in which case their options will be preserved, or\nStrings. If no patterns are given, returns `/(?!)/`.\nThe behavior is unspecified if any given <em>pattern</em> contains capture.\n\n   Regexp.union                         #=> /(?!)/\n   Regexp.union("penzance")             #=> /penzance/\n   Regexp.union("a+b*c")                #=> /a\+b\*c/\n   Regexp.union("skiing", "sledding")   #=> /skiing|sledding/\n   Regexp.union(["skiing", "sledding"]) #=> /skiing|sledding/\n   Regexp.union(/dogs/, /cats/i)        #=> /(?-mix:dogs)|(?i-mx:cats)/\n
casefold? Regexp.casefold?()\nReturns the value of the case-insensitive flag.\n\n    /a/.casefold?           #=> false\n    /a/i.casefold?          #=> true\n    /(?i:a)/.casefold?      #=> false\n
encoding Regexp.encoding()\nReturns the Encoding object that represents the encoding of obj.\n
eql? Regexp.eql?(p1)\nEquality---Two regexps are equal if their patterns are identical, they have\nthe same character set code, and their `casefold?` values are the\nsame.\n\n   /abc/  == /abc/x   #=> false\n   /abc/  == /abc/i   #=> false\n   /abc/  == /abc/n   #=> false\n   /abc/u == /abc/n   #=> false\n
fixed_encoding? Regexp.fixed_encoding?()\nReturns false if rxp is applicable to\na string with any ASCII compatible encoding.\nReturns true otherwise.\n\n    r = /a/\n    r.fixed_encoding?                               #=> false\n    r =~ "\u{6666} a"                               #=> 2\n    r =~ "\xa1\xa2 a".force_encoding("euc-jp")      #=> 2\n    r =~ "abc".force_encoding("euc-jp")             #=> 0\n\n    r = /a/u\n    r.fixed_encoding?                               #=> true\n    r.encoding                                      #=> #<Encoding:UTF-8>\n    r =~ "\u{6666} a"                               #=> 2\n    r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> ArgumentError\n    r =~ "abc".force_encoding("euc-jp")             #=> 0\n\n    r = /\u{6666}/\n    r.fixed_encoding?                               #=> true\n    r.encoding                                      #=> #<Encoding:UTF-8>\n    r =~ "\u{6666} a"                               #=> 0\n    r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> ArgumentError\n    r =~ "abc".force_encoding("euc-jp")             #=> nil\n
hash Regexp.hash()\nProduce a hash based on the text and options of this regular expression.\n
inspect Regexp.inspect()\nProduce a nicely formatted string-version of _rxp_. Perhaps surprisingly,\n`#inspect` actually produces the more natural version of\nthe string than `#to_s`.\n\n     /ab+c/ix.inspect        #=> "/ab+c/ix"\n
match Regexp.match(...)\nReturns a `MatchData` object describing the match, or\n`nil` if there was no match. This is equivalent to retrieving the\nvalue of the special variable `$~` following a normal match.\nIf the second parameter is present, it specifies the position in the string\nto begin the search.\n\n   /(.)(.)(.)/.match("abc")[2]   #=> "b"\n   /(.)(.)/.match("abc", 1)[2]   #=> "c"\n\nIf a block is given, invoke the block with MatchData if match succeed, so\nthat you can write\n\n   pat.match(str) {|m| ...}\n\ninstead of\n\n   if m = pat.match(str)\n     ...\n   end\n\nThe return value is a value from block execution in this case.\n
named_captures Regexp.named_captures()\nReturns a hash representing information about named captures of <i>rxp</i>.\n\nA key of the hash is a name of the named captures.\nA value of the hash is an array which is list of indexes of corresponding\nnamed captures.\n\n   /(?<foo>.)(?<bar>.)/.named_captures\n=> {"foo"=>[1], "bar"=>[2]}\n\n   /(?<foo>.)(?<foo>.)/.named_captures\n=> {"foo"=>[1, 2]}\n\nIf there are no named captures, an empty hash is returned.\n\n   /(.)(.)/.named_captures\n=> {}\n
names Regexp.names()\nReturns a list of names of captures as an array of strings.\n\n    /(?<foo>.)(?<bar>.)(?<baz>.)/.names\n=> ["foo", "bar", "baz"]\n\n    /(?<foo>.)(?<foo>.)/.names\n=> ["foo"]\n\n    /(.)(.)/.names\n=> []\n
options Regexp.options()\nReturns the set of bits corresponding to the options used when creating this\nRegexp (see `Regexp::new` for details. Note that additional bits\nmay be set in the returned options: these are used internally by the regular\nexpression code. These extra bits are ignored if the options are passed to\n`Regexp::new`.\n\n   Regexp::IGNORECASE                  #=> 1\n   Regexp::EXTENDED                    #=> 2\n   Regexp::MULTILINE                   #=> 4\n\n   /cat/.options                       #=> 0\n   /cat/ix.options                     #=> 3\n   Regexp.new('cat', true).options     #=> 1\n   /\xa1\xa2/e.options                 #=> 16\n\n   r = /cat/ix\n   Regexp.new(r.source, r.options)     #=> /cat/ix\n
source Regexp.source()\nReturns the original string of the pattern.\n\n    /ab+c/ix.source #=> "ab+c"\n\nNote that escape sequences are retained as is.\n\n   /\x20\+/.source  #=> "\\x20\\+"\n
to_s Regexp.to_s()\nReturns a string containing the regular expression and its options (using the\n`(?opts:source)` notation. This string can be fed back in to\n`Regexp::new` to a regular expression with the same semantics as\nthe original. (However, `Regexp#==` may not return true when\ncomparing the two, as the source of the regular expression itself may\ndiffer, as the example shows).  `Regexp#inspect` produces a\ngenerally more readable version of <i>rxp</i>.\n\n    r1 = /ab+c/ix           #=> /ab+c/ix\n    s1 = r1.to_s            #=> "(?ix-m:ab+c)"\n    r2 = Regexp.new(s1)     #=> /(?ix-m:ab+c)/\n    r1 == r2                #=> false\n    r1.source               #=> "ab+c"\n    r2.source               #=> "(?ix-m:ab+c)"\n
begin MatchData.begin(p1)\nReturns the offset of the start of the <em>n</em>th element of the match\narray in the string.\n<em>n</em> can be a string or symbol to reference a named capture.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.begin(0)       #=> 1\n   m.begin(2)       #=> 2\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")\n   p m.begin(:foo)  #=> 0\n   p m.begin(:bar)  #=> 2\n
captures MatchData.captures()\nReturns the array of captures; equivalent to `mtch.to_a[1..-1]`.\n\n   f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match("THX1138.").captures\n   f1    #=> "H"\n   f2    #=> "X"\n   f3    #=> "113"\n   f4    #=> "8"\n
end MatchData.end(p1)\nReturns the offset of the character immediately following the end of the\n<em>n</em>th element of the match array in the string.\n<em>n</em> can be a string or symbol to reference a named capture.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.end(0)         #=> 7\n   m.end(2)         #=> 3\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")\n   p m.end(:foo)    #=> 1\n   p m.end(:bar)    #=> 3\n
eql? MatchData.eql?(p1)\nEquality---Two matchdata are equal if their target strings,\npatterns, and matched positions are identical.\n
hash MatchData.hash()\nProduce a hash based on the target string, regexp and matched\npositions of this matchdata.\n
inspect MatchData.inspect()\nReturns a printable version of <i>mtch</i>.\n\n    puts /.$/.match("foo").inspect\n=> #<MatchData "o">\n\n    puts /(.)(.)(.)/.match("foo").inspect\n=> #<MatchData "foo" 1:"f" 2:"o" 3:"o">\n\n    puts /(.)(.)?(.)/.match("fo").inspect\n=> #<MatchData "fo" 1:"f" 2:nil 3:"o">\n\n    puts /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge").inspect\n=> #<MatchData "hog" foo:"h" bar:"o" baz:"g">\n
length MatchData.length()\nReturns the number of elements in the match array.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.length   #=> 5\n   m.size     #=> 5\n
names MatchData.names()\nReturns a list of names of captures as an array of strings.\nIt is same as mtch.regexp.names.\n\n    /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge").names\n=> ["foo", "bar", "baz"]\n\n    m = /(?<x>.)(?<y>.)?/.match("a") #=> #<MatchData "a" x:"a" y:nil>\n    m.names                          #=> ["x", "y"]\n
offset MatchData.offset(p1)\nReturns a two-element array containing the beginning and ending offsets of\nthe <em>n</em>th match.\n<em>n</em> can be a string or symbol to reference a named capture.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.offset(0)      #=> [1, 7]\n   m.offset(4)      #=> [6, 7]\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")\n   p m.offset(:foo) #=> [0, 1]\n   p m.offset(:bar) #=> [2, 3]\n
post_match MatchData.post_match()\nReturns the portion of the original string after the current match.\nEquivalent to the special variable `$'`.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")\n   m.post_match   #=> ": The Movie"\n
pre_match MatchData.pre_match()\nReturns the portion of the original string before the current match.\nEquivalent to the special variable `$``.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.pre_match   #=> "T"\n
regexp MatchData.regexp()\nReturns the regexp.\n\n    m = /a.*b/.match("abc")\n    m.regexp #=> /a.*b/\n
size MatchData.size()\nReturns the number of elements in the match array.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.length   #=> 5\n   m.size     #=> 5\n
string MatchData.string()\nReturns a frozen copy of the string passed in to `match`.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.string   #=> "THX1138."\n
to_a MatchData.to_a()\nReturns the array of matches.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.to_a   #=> ["HX1138", "H", "X", "113", "8"]\n\nBecause `to_a` is called when expanding\n`*`<em>variable</em>, there's a useful assignment\nshortcut for extracting matched fields. This is slightly slower than\naccessing the fields directly (as an intermediate array is\ngenerated).\n\n   all,f1,f2,f3 = *(/(.)(.)(\d+)(\d)/.match("THX1138."))\n   all   #=> "HX1138"\n   f1    #=> "H"\n   f2    #=> "X"\n   f3    #=> "113"\n
to_s MatchData.to_s()\nReturns the entire matched string.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.to_s   #=> "HX1138"\n
values_at MatchData.values_at(...)\n   mtch.values_at([index]*)   -> array\n\nUses each <i>index</i> to access the matching values, returning an array of\nthe corresponding matches.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")\n   m.to_a               #=> ["HX1138", "H", "X", "113", "8"]\n   m.values_at(0, 2, -2)   #=> ["HX1138", "X", "113"]\n
list Signal.list()\nReturns a list of signal names mapped to the corresponding\nunderlying signal numbers.\n\n  Signal.list   #=> {"EXIT"=>0, "HUP"=>1, "INT"=>2, "QUIT"=>3, "ILL"=>4,\n  "TRAP"=>5, "IOT"=>6, "ABRT"=>6, "FPE"=>8, "KILL"=>9, "BUS"=>7, "SEGV"=>11,\n  "SYS"=>31, "PIPE"=>13, "ALRM"=>14, "TERM"=>15, "URG"=>23, "STOP"=>19,\n  "TSTP"=>20, "CONT"=>18, "CHLD"=>17, "CLD"=>17, "TTIN"=>21, "TTOU"=>22,\n  "IO"=>29, "XCPU"=>24, "XFSZ"=>25, "VTALRM"=>26, "PROF"=>27, "WINCH"=>28,\n  "USR1"=>10, "USR2"=>12, "PWR"=>30, "POLL"=>29}\n
new Signal.new(...)\nConstruct a new SignalException object.  +sig_name+ should be a known\nsignal name.\n
trap Signal.trap(...)\nSpecifies the handling of signals. The first parameter is a signal\nname (a string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a\nsignal number. The characters ``SIG'' may be omitted from the\nsignal name. The command or block specifies code to be run when the\nsignal is raised.\nIf the command is the string ``IGNORE'' or ``SIG_IGN'', the signal\nwill be ignored.\nIf the command is ``DEFAULT'' or ``SIG_DFL'', the Ruby's default handler\nwill be invoked.\nIf the command is ``EXIT'', the script will be terminated by the signal.\nIf the command is ``SYSTEM_DEFAULT'', the operating system's default\nhandler will be invoked.\nOtherwise, the given command or block will be run.\nThe special signal name ``EXIT'' or signal number zero will be\ninvoked just prior to program termination.\ntrap returns the previous handler for the given signal.\n\n    Signal.trap(0, proc { puts "Terminating: #{$$}" })\n    Signal.trap("CLD")  { puts "Child died" }\n    fork && Process.wait\n\nproduces:\n    Terminating: 27461\n    Child died\n    Terminating: 27460\n
signo Signal.signo()\nReturns a signal number.\n
all_symbols Symbol.all_symbols()\nReturns an array of all the symbols currently in Ruby's symbol\ntable.\n\n   Symbol.all_symbols.size    #=> 903\n   Symbol.all_symbols[1,20]   #=> [:floor, :ARGV, :Binding, :symlink,\n                                   :chown, :EOFError, :$;, :String,\n                                   :LOCK_SH, :"setuid?", :$<,\n                                   :default_proc, :compact, :extend,\n                                   :Tms, :getwd, :$=, :ThreadGroup,\n                                   :wait2, :$>]\n
capitalize Symbol.capitalize()\nSame as `sym.to_s.capitalize.intern`.\n
casecmp Symbol.casecmp(p1)\n  sym.casecmp(other)  -> -1, 0, +1 or nil\n\nCase-insensitive version of `Symbol#<=>`.\n
downcase Symbol.downcase()\nSame as `sym.to_s.downcase.intern`.\n
empty? Symbol.empty?()\nReturns that _sym_ is :"" or not.\n
encoding Symbol.encoding()\nReturns the Encoding object that represents the encoding of _sym_.\n
id2name Symbol.id2name()\nReturns the name or string corresponding to <i>sym</i>.\n\n   :fred.id2name   #=> "fred"\n
inspect Symbol.inspect()\nReturns the representation of <i>sym</i> as a symbol literal.\n\n   :fred.inspect   #=> ":fred"\n
intern Symbol.intern()\nIn general, `to_sym` returns the `Symbol` corresponding\nto an object. As <i>sym</i> is already a symbol, `self` is returned\nin this case.\n
length Symbol.length()\nSame as `sym.to_s.length`.\n
match Symbol.match(p1)\nReturns `sym.to_s =~ obj`.\n
next Symbol.next()\n  sym.succ\n\nSame as `sym.to_s.succ.intern`.\n
size Symbol.size()\nSame as `sym.to_s.length`.\n
slice Symbol.slice(...)\nReturns `sym.to_s[]`.\n
succ Symbol.succ()\n  sym.succ\n\nSame as `sym.to_s.succ.intern`.\n
swapcase Symbol.swapcase()\nSame as `sym.to_s.swapcase.intern`.\n
to_proc Symbol.to_proc()\nReturns a _Proc_ object which respond to the given method by _sym_.\n\n  (1..3).collect(&:to_s)  #=> ["1", "2", "3"]\n
to_s Symbol.to_s()\nReturns the name or string corresponding to <i>sym</i>.\n\n   :fred.id2name   #=> "fred"\n
to_sym Symbol.to_sym()\nIn general, `to_sym` returns the `Symbol` corresponding\nto an object. As <i>sym</i> is already a symbol, `self` is returned\nin this case.\n
upcase Symbol.upcase()\nSame as `sym.to_s.upcase.intern`.\n
new Struct.new(...)\nCreates a new class, named by <i>aString</i>, containing accessor\nmethods for the given symbols. If the name <i>aString</i> is\nomitted, an anonymous structure class will be created. Otherwise,\nthe name of this struct will appear as a constant in class\n`Struct`, so it must be unique for all\n`Struct`s in the system and should start with a capital\nletter. Assigning a structure class to a constant effectively gives\nthe class the name of the constant.\n\n`Struct::new` returns a new `Class` object,\nwhich can then be used to create specific instances of the new\nstructure. The number of actual parameters must be\nless than or equal to the number of attributes defined for this\nclass; unset parameters default to `nil`.  Passing too many\nparameters will raise an `ArgumentError`.\n\nThe remaining methods listed in this section (class and instance)\nare defined for this generated class.\n Create a structure with a name in Struct\n   Struct.new("Customer", :name, :address)    #=> Struct::Customer\n   Struct::Customer.new("Dave", "123 Main")   #=> #<struct Struct::Customer\n   name="Dave", address="123 Main">\n Create a structure named by its constant\n   Customer = Struct.new(:name, :address)     #=> Customer\n   Customer.new("Dave", "123 Main")           #=> #<struct Customer\n   name="Dave", address="123 Main">\n
new Struct.new(...)\n\n
each Struct.each()\nCalls <i>block</i> once for each instance variable, passing the\nvalue as a parameter.\n\nIf no block is given, an enumerator is returned instead.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.each {|x| puts(x) }\n\n<em>produces:</em>\n\n   Joe Smith\n   123 Maple, Anytown NC\n   12345\n
each_pair Struct.each_pair()\nCalls <i>block</i> once for each instance variable, passing the name\n(as a symbol) and the value as parameters.\n\nIf no block is given, an enumerator is returned instead.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.each_pair {|name, value| puts("#{name} => #{value}") }\n\n<em>produces:</em>\n\n   name => Joe Smith\n   address => 123 Maple, Anytown NC\n   zip => 12345\n
eql? Struct.eql?(p1)\ncode-seq:\n  struct.eql?(other)   -> true or false\n\nTwo structures are equal if they are the same object, or if all their\nfields are equal (using `eql?`).\n
hash Struct.hash()\nReturn a hash value based on this struct's contents.\n
inspect Struct.inspect()\nDescribe the contents of this struct in a string.\n
length Struct.length()\nReturns the number of instance variables.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.length   #=> 3\n
members Struct.members()\nReturns an array of strings representing the names of the instance\nvariables.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.members   #=> [:name, :address, :zip]\n
select Struct.select(...)\nInvokes the block passing in successive elements from\n<i>struct</i>, returning an array containing those elements\nfor which the block returns a true value (equivalent to\n`Enumerable#select`).\n\n   Lots = Struct.new(:a, :b, :c, :d, :e, :f)\n   l = Lots.new(11, 22, 33, 44, 55, 66)\n   l.select {|v| (v % 2).zero? }   #=> [22, 44, 66]\n
size Struct.size()\nReturns the number of instance variables.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.length   #=> 3\n
to_a Struct.to_a()\nReturns the values for this instance as an array.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.to_a[1]   #=> "123 Maple, Anytown NC"\n
to_s Struct.to_s()\n\n
values Struct.values()\nReturns the values for this instance as an array.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.to_a[1]   #=> "123 Maple, Anytown NC"\n
values_at Struct.values_at(...)\nReturns an array containing the elements in\n+self+ corresponding to the given selector(s). The selectors\nmay be either integer indices or ranges.\nSee also `.select`.\n\n   a = %w{ a b c d e f }\n   a.values_at(1, 3, 5)\n   a.values_at(1, 3, 5, 7)\n   a.values_at(-1, -3, -5, -7)\n   a.values_at(1..3, 2...5)\n
add ThreadGroup.add(p1)\nAdds the given <em>thread</em> to this group, removing it from any other\ngroup to which it may have previously belonged.\n\n   puts "Initial group is #{ThreadGroup::Default.list}"\n   tg = ThreadGroup.new\n   t1 = Thread.new { sleep }\n   t2 = Thread.new { sleep }\n   puts "t1 is #{t1}"\n   puts "t2 is #{t2}"\n   tg.add(t1)\n   puts "Initial group now #{ThreadGroup::Default.list}"\n   puts "tg group now #{tg.list}"\n\n<em>produces:</em>\n\n   Initial group is #<Thread:0x401bdf4c>\n   t1 is #<Thread:0x401b3c90>\n   t2 is #<Thread:0x401b3c18>\n   Initial group now #<Thread:0x401b3c18>#<Thread:0x401bdf4c>\n   tg group now #<Thread:0x401b3c90>\n
enclose ThreadGroup.enclose()\nPrevents threads from being added to or removed from the receiving\n`ThreadGroup`. New threads can still be started in an enclosed\n`ThreadGroup`.\n\n   ThreadGroup::Default.enclose        #=> #<ThreadGroup:0x4029d914>\n   thr = Thread::new { Thread.stop }   #=> #<Thread:0x402a7210 sleep>\n   tg = ThreadGroup::new               #=> #<ThreadGroup:0x402752d4>\n   tg.add thr\n\n<em>produces:</em>\n\n   ThreadError: can't move from the enclosed thread group\n
enclosed? ThreadGroup.enclosed?()\nReturns `true` if <em>thgrp</em> is enclosed. See also\nThreadGroup#enclose.\n
list ThreadGroup.list()\nReturns an array of all existing `Thread` objects that belong to\nthis group.\n\n   ThreadGroup::Default.list   #=> [#<Thread:0x401bdf4c run>]\n
new Mutex.new()\nCreates a new Mutex\n
lock Mutex.lock()\nAttempts to grab the lock and waits if it isn't available.\nRaises +ThreadError+ if +mutex+ was locked by the current thread.\n
locked? Mutex.locked?()\nReturns +true+ if this lock is currently held by some thread.\n
sleep Mutex.sleep(...)\nReleases the lock and sleeps +timeout+ seconds if it is given and\nnon-nil or forever.  Raises +ThreadError+ if +mutex+ wasn't locked by\nthe current thread.\n
try_lock Mutex.try_lock()\nAttempts to obtain the lock and returns immediately. Returns +true+ if the\nlock was granted.\n
unlock Mutex.unlock()\nReleases the lock.\nRaises +ThreadError+ if +mutex+ wasn't locked by the current thread.\n
DEBUG Thread.DEBUG()\nReturns the thread debug level.  Available only if compiled with\nTHREAD_DEBUG=-1.\n
DEBUG= Thread.DEBUG=(p1)\nSets the thread debug level.  Available only if compiled with\nTHREAD_DEBUG=-1.\n
abort_on_exception Thread.abort_on_exception()\nReturns the status of the global ``abort on exception'' condition.  The\ndefault is `false`. When set to `true`, or if the\nglobal `$DEBUG` flag is `true` (perhaps because the\ncommand line option `-d` was specified) all threads will abort\n(the process will `exit(0)`) if an exception is raised in any\nthread. See also `Thread::abort_on_exception=`.\n
abort_on_exception= Thread.abort_on_exception=(p1)\nWhen set to `true`, all threads will abort if an exception is\nraised. Returns the new state.\n\n   Thread.abort_on_exception = true\n   t1 = Thread.new do\n     puts  "In new thread"\n     raise "Exception from thread"\n   end\n   sleep(1)\n   puts "not reached"\n\n<em>produces:</em>\n\n   In new thread\n   prog.rb:4: Exception from thread (RuntimeError)\n    from prog.rb:2:in `initialize'\n    from prog.rb:2:in `new'\n    from prog.rb:2\n
current Thread.current()\nReturns the currently executing thread.\n\n   Thread.current   #=> #<Thread:0x401bdf4c run>\n
exit Thread.exit()\nTerminates the currently running thread and schedules another thread to be\nrun. If this thread is already marked to be killed, `exit`\nreturns the `Thread`. If this is the main thread, or the last\nthread, exit the process.\n
fork Thread.fork(...)\nBasically the same as `Thread::new`. However, if class\n`Thread` is subclassed, then calling `start` in that\nsubclass will not invoke the subclass's `initialize` method.\n
kill Thread.kill(p1)\nCauses the given <em>thread</em> to exit (see `Thread::exit`).\n\n   count = 0\n   a = Thread.new { loop { count += 1 } }\n   sleep(0.1)       #=> 0\n   Thread.kill(a)   #=> #<Thread:0x401b3d30 dead>\n   count            #=> 93947\n   a.alive?         #=> false\n
list Thread.list()\nReturns an array of `Thread` objects for all threads that are\neither runnable or stopped.\n\n   Thread.new { sleep(200) }\n   Thread.new { 1000000.times {|i| i*i } }\n   Thread.new { Thread.stop }\n   Thread.list.each {|t| p t}\n\n<em>produces:</em>\n<Thread:0x401b3e84 sleep>\n<Thread:0x401b3f38 run>\n<Thread:0x401b3fb0 sleep>\n<Thread:0x401bdf4c run>\n
main Thread.main()\nReturns the main thread.\n
pass Thread.pass()\nInvokes the thread scheduler to pass execution to another thread.\n\n   a = Thread.new { print "a"; Thread.pass;\n                    print "b"; Thread.pass;\n                    print "c" }\n   b = Thread.new { print "x"; Thread.pass;\n                    print "y"; Thread.pass;\n                    print "z" }\n   a.join\n   b.join\n\n<em>produces:</em>\n\n   axbycz\n
start Thread.start(...)\nBasically the same as `Thread::new`. However, if class\n`Thread` is subclassed, then calling `start` in that\nsubclass will not invoke the subclass's `initialize` method.\n
stop Thread.stop()\nStops execution of the current thread, putting it into a ``sleep'' state,\nand schedules execution of another thread.\n\n   a = Thread.new { print "a"; Thread.stop; print "c" }\n   Thread.pass\n   print "b"\n   a.run\n   a.join\n\n<em>produces:</em>\n\n   abc\n
abort_on_exception Thread.abort_on_exception()\nReturns the status of the thread-local ``abort on exception'' condition for\n<i>thr</i>. The default is `false`. See also\n`Thread::abort_on_exception=`.\n
abort_on_exception= Thread.abort_on_exception=(p1)\nWhen set to `true`, causes all threads (including the main\nprogram) to abort if an exception is raised in <i>thr</i>. The process will\neffectively `exit(0)`.\n
add_trace_func Thread.add_trace_func(p1)\nAdds _proc_ as a handler for tracing.\nSee `Thread#set_trace_func` and +set_trace_func+.\n
alive? Thread.alive?()\nReturns `true` if <i>thr</i> is running or sleeping.\n\n   thr = Thread.new { }\n   thr.join                #=> #<Thread:0x401b3fb0 dead>\n   Thread.current.alive?   #=> true\n   thr.alive?              #=> false\n
backtrace Thread.backtrace()\nReturns the current back trace of the _thr_.\n
exit Thread.exit()\nTerminates <i>thr</i> and schedules another thread to be run. If this thread\nis already marked to be killed, `exit` returns the\n`Thread`. If this is the main thread, or the last thread, exits\nthe process.\n
group Thread.group()\nReturns the `ThreadGroup` which contains <i>thr</i>, or nil if\nthe thread is not a member of any group.\n\n   Thread.main.group   #=> #<ThreadGroup:0x4029d914>\n
inspect Thread.inspect()\nDump the name, id, and status of _thr_ to a string.\n
join Thread.join(...)\nThe calling thread will suspend execution and run <i>thr</i>. Does not\nreturn until <i>thr</i> exits or until <i>limit</i> seconds have passed. If\nthe time limit expires, `nil` will be returned, otherwise\n<i>thr</i> is returned.\n\nAny threads not joined will be killed when the main program exits.  If\n<i>thr</i> had previously raised an exception and the\n`abort_on_exception` and `$DEBUG` flags are not set\n(so the exception has not yet been processed) it will be processed at this\ntime.\n\n   a = Thread.new { print "a"; sleep(10); print "b"; print "c" }\n   x = Thread.new { print "x"; Thread.pass; print "y"; print "z" }\n   x.join # Let x thread finish, a will be killed on exit.\n\n<em>produces:</em>\n\n   axyz\n\nThe following example illustrates the <i>limit</i> parameter.\n\n   y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' }}\n   puts "Waiting" until y.join(0.15)\n\n<em>produces:</em>\n\n   tick...\n   Waiting\n   tick...\n   Waitingtick...\n\n\n   tick...\n
key? Thread.key?(p1)\nReturns `true` if the given string (or symbol) exists as a\nthread-local variable.\n\n   me = Thread.current\n   me[:oliver] = "a"\n   me.key?(:oliver)    #=> true\n   me.key?(:stanley)   #=> false\n
keys Thread.keys()\nReturns an an array of the names of the thread-local variables (as Symbols).\n\n   thr = Thread.new do\n     Thread.current[:cat] = 'meow'\n     Thread.current["dog"] = 'woof'\n   end\n   thr.join   #=> #<Thread:0x401b3f10 dead>\n   thr.keys   #=> [:dog, :cat]\n
kill Thread.kill()\nTerminates <i>thr</i> and schedules another thread to be run. If this thread\nis already marked to be killed, `exit` returns the\n`Thread`. If this is the main thread, or the last thread, exits\nthe process.\n
priority Thread.priority()\nReturns the priority of <i>thr</i>. Default is inherited from the\ncurrent thread which creating the new thread, or zero for the\ninitial main thread; higher-priority thread will run more frequently\nthan lower-priority threads (but lower-priority threads can also run).\n\nThis is just hint for Ruby thread scheduler.  It may be ignored on some\nplatform.\n\n   Thread.current.priority   #=> 0\n
priority= Thread.priority=(p1)\nSets the priority of <i>thr</i> to <i>integer</i>. Higher-priority threads\nwill run more frequently than lower-priority threads (but lower-priority\nthreads can also run).\n\nThis is just hint for Ruby thread scheduler.  It may be ignored on some\nplatform.\n\n   count1 = count2 = 0\n   a = Thread.new do\n         loop { count1 += 1 }\n       end\n   a.priority = -1\n\n   b = Thread.new do\n         loop { count2 += 1 }\n       end\n   b.priority = -2\n   sleep 1   #=> 1\n   count1    #=> 622504\n   count2    #=> 5832\n
raise Thread.raise(...)\nRaises an exception (see `Kernel::raise`) from <i>thr</i>. The\ncaller does not have to be <i>thr</i>.\n\n   Thread.abort_on_exception = true\n   a = Thread.new { sleep(200) }\n   a.raise("Gotcha")\n\n<em>produces:</em>\n\n   prog.rb:3: Gotcha (RuntimeError)\n    from prog.rb:2:in `initialize'\n    from prog.rb:2:in `new'\n    from prog.rb:2\n
run Thread.run()\nWakes up <i>thr</i>, making it eligible for scheduling.\n\n   a = Thread.new { puts "a"; Thread.stop; puts "c" }\n   Thread.pass\n   puts "Got here"\n   a.run\n   a.join\n\n<em>produces:</em>\n\n   a\n   Got here\n   c\n
safe_level Thread.safe_level()\nReturns the safe level in effect for <i>thr</i>. Setting thread-local safe\nlevels can help when implementing sandboxes which run insecure code.\n\n   thr = Thread.new { $SAFE = 3; sleep }\n   Thread.current.safe_level   #=> 0\n   thr.safe_level              #=> 3\n
set_trace_func Thread.set_trace_func(p1)\nEstablishes _proc_ on _thr_ as the handler for tracing, or\ndisables tracing if the parameter is +nil+.\nSee +set_trace_func+.\n
status Thread.status()\nReturns the status of <i>thr</i>: ```sleep`'' if <i>thr</i> is\nsleeping or waiting on I/O, ```run`'' if <i>thr</i> is executing,\n```aborting`'' if <i>thr</i> is aborting, `false` if\n<i>thr</i> terminated normally, and `nil` if <i>thr</i>\nterminated with an exception.\n\n   a = Thread.new { raise("die now") }\n   b = Thread.new { Thread.stop }\n   c = Thread.new { Thread.exit }\n   d = Thread.new { sleep }\n   d.kill                  #=> #<Thread:0x401b3678 aborting>\n   a.status                #=> nil\n   b.status                #=> "sleep"\n   c.status                #=> false\n   d.status                #=> "aborting"\n   Thread.current.status   #=> "run"\n
stop? Thread.stop?()\nReturns `true` if <i>thr</i> is dead or sleeping.\n\n   a = Thread.new { Thread.stop }\n   b = Thread.current\n   a.stop?   #=> true\n   b.stop?   #=> false\n
terminate Thread.terminate()\nTerminates <i>thr</i> and schedules another thread to be run. If this thread\nis already marked to be killed, `exit` returns the\n`Thread`. If this is the main thread, or the last thread, exits\nthe process.\n
value Thread.value()\nWaits for <i>thr</i> to complete (via `Thread#join`) and returns\nits value.\n\n   a = Thread.new { 2 + 2 }\n   a.value   #=> 4\n
wakeup Thread.wakeup()\nMarks <i>thr</i> as eligible for scheduling (it may still remain blocked on\nI/O, however). Does not invoke the scheduler (see `Thread#run`).\n\n   c = Thread.new { Thread.stop; puts "hey!" }\n   c.wakeup\n\n<em>produces:</em>\n\n   hey!\n
_load Time._load(p1)\nUnmarshal a dumped +Time+ object.\n
at Time.at(...)\nCreates a new time object with the value given by <i>time</i>,\nthe given number of <i>seconds_with_frac</i>, or\n<i>seconds</i> and <i>microseconds_with_frac</i> from the Epoch.\n<i>seconds_with_frac</i> and <i>microseconds_with_frac</i>\ncan be Integer, Float, Rational, or other Numeric.\nnon-portable feature allows the offset to be negative on some systems.\n\n   Time.at(0)            #=> 1969-12-31 18:00:00 -0600\n   Time.at(Time.at(0))   #=> 1969-12-31 18:00:00 -0600\n   Time.at(946702800)    #=> 1999-12-31 23:00:00 -0600\n   Time.at(-284061600)   #=> 1960-12-31 00:00:00 -0600\n   Time.at(946684800.2).usec #=> 200000\n   Time.at(946684800, 123456.789).nsec #=> 123456789\n
gm Time.gm(...)\nCreates a time based on given values, interpreted as UTC (GMT). The\nyear must be specified. Other values default to the minimum value\nfor that field (and may be `nil` or omitted). Months may\nbe specified by numbers from 1 to 12, or by the three-letter English\nmonth names. Hours are specified on a 24-hour clock (0..23). Raises\nan `ArgumentError` if any values are out of range. Will\nalso accept ten arguments in the order output by\n`Time#to_a`.\n<i>sec_with_frac</i> and <i>usec_with_frac</i> can have a fractional part.\n\n   Time.utc(2000,"jan",1,20,15,1)  #=> 2000-01-01 20:15:01 UTC\n   Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n
local Time.local(...)\nSame as `Time::gm`, but interprets the values in the\nlocal time zone.\n\n   Time.local(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 -0600\n
mktime Time.mktime(...)\nSame as `Time::gm`, but interprets the values in the\nlocal time zone.\n\n   Time.local(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 -0600\n
new Time.new(...)\nReturns a `Time` object.\n\nIt is initialized to the current system time if no argument.\n<b>Note:</b> The object created will be created using the\nresolution available on your system clock, and so may include\nfractional seconds.\n\nIf one or more arguments specified, the time is initialized\nto the specified time.\n_sec_ may have fraction if it is a rational.\n\n_utc_offset_ is the offset from UTC.\nIt is a string such as "+09:00" or a number of seconds such as 32400.\n\n   a = Time.new      #=> 2007-11-19 07:50:02 -0600\n   b = Time.new      #=> 2007-11-19 07:50:02 -0600\n   a == b            #=> false\n   "%.6f" % a.to_f   #=> "1195480202.282373"\n   "%.6f" % b.to_f   #=> "1195480202.283415"\n\n   Time.new(2008,6,21, 13,30,0, "+09:00") #=> 2008-06-21 13:30:00 +0900\n A trip for RubyConf 2007\n   t1 = Time.new(2007,11,1,15,25,0, "+09:00") # JST (Narita)\n   t2 = Time.new(2007,11,1,12, 5,0, "-05:00") # CDT (Minneapolis)\n   t3 = Time.new(2007,11,1,13,25,0, "-05:00") # CDT (Minneapolis)\n   t4 = Time.new(2007,11,1,16,53,0, "-04:00") # EDT (Charlotte)\n   t5 = Time.new(2007,11,5, 9,24,0, "-05:00") # EST (Charlotte)\n   t6 = Time.new(2007,11,5,11,21,0, "-05:00") # EST (Detroit)\n   t7 = Time.new(2007,11,5,13,45,0, "-05:00") # EST (Detroit)\n   t8 = Time.new(2007,11,6,17,10,0, "+09:00") # JST (Narita)\n   p((t2-t1)/3600.0)                          #=> 10.666666666666666\n   p((t4-t3)/3600.0)                          #=> 2.466666666666667\n   p((t6-t5)/3600.0)                          #=> 1.95\n   p((t8-t7)/3600.0)                          #=> 13.416666666666666\n
now Time.now()\nSynonym for `Time.new`. Returns a +Time+ object\ninitialized to the current system time.\n
utc Time.utc(...)\nCreates a time based on given values, interpreted as UTC (GMT). The\nyear must be specified. Other values default to the minimum value\nfor that field (and may be `nil` or omitted). Months may\nbe specified by numbers from 1 to 12, or by the three-letter English\nmonth names. Hours are specified on a 24-hour clock (0..23). Raises\nan `ArgumentError` if any values are out of range. Will\nalso accept ten arguments in the order output by\n`Time#to_a`.\n<i>sec_with_frac</i> and <i>usec_with_frac</i> can have a fractional part.\n\n   Time.utc(2000,"jan",1,20,15,1)  #=> 2000-01-01 20:15:01 UTC\n   Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n
_dump Time._dump(...)\nDump _time_ for marshaling.\n
asctime Time.asctime()\nReturns a canonical string representation of <i>time</i>.\n\n   Time.now.asctime   #=> "Wed Apr  9 08:56:03 2003"\n
ctime Time.ctime()\nReturns a canonical string representation of <i>time</i>.\n\n   Time.now.asctime   #=> "Wed Apr  9 08:56:03 2003"\n
day Time.day()\nReturns the day of the month (1..n) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:27:03 -0600\n   t.day          #=> 19\n   t.mday         #=> 19\n
dst? Time.dst?()\nReturns `true` if <i>time</i> occurs during Daylight\nSaving Time in its time zone.\n CST6CDT:\n   Time.local(2000, 1, 1).zone    #=> "CST"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> "CDT"\n   Time.local(2000, 7, 1).isdst   #=> true\n   Time.local(2000, 7, 1).dst?    #=> true\n Asia/Tokyo:\n   Time.local(2000, 1, 1).zone    #=> "JST"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> "JST"\n   Time.local(2000, 7, 1).isdst   #=> false\n   Time.local(2000, 7, 1).dst?    #=> false\n
eql? Time.eql?(p1)\nReturn `true` if <i>time</i> and <i>other_time</i> are\nboth `Time` objects with the same seconds and fractional\nseconds.\n
friday? Time.friday?()\nReturns `true` if <i>time</i> represents Friday.\n\n   t = Time.local(1987, 12, 18)     #=> 1987-12-18 00:00:00 -0600\n   t.friday?                        #=> true\n
getgm Time.getgm()\nReturns a new `new_time` object representing <i>time</i> in\nUTC.\n\n   t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600\n   t.gmt?                             #=> false\n   y = t.getgm                        #=> 2000-01-02 02:15:01 UTC\n   y.gmt?                             #=> true\n   t == y                             #=> true\n
getlocal Time.getlocal(...)\nReturns a new `new_time` object representing <i>time</i> in\nlocal time (using the local time zone in effect for this process).\n\nIf _utc_offset_ is given, it is used instead of the local time.\n\n   t = Time.utc(2000,1,1,20,15,1)  #=> 2000-01-01 20:15:01 UTC\n   t.utc?                          #=> true\n\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.utc?                          #=> false\n   t == l                          #=> true\n\n   j = t.getlocal("+09:00")        #=> 2000-01-02 05:15:01 +0900\n   j.utc?                          #=> false\n   t == j                          #=> true\n
getutc Time.getutc()\nReturns a new `new_time` object representing <i>time</i> in\nUTC.\n\n   t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600\n   t.gmt?                             #=> false\n   y = t.getgm                        #=> 2000-01-02 02:15:01 UTC\n   y.gmt?                             #=> true\n   t == y                             #=> true\n
gmt? Time.gmt?()\nReturns `true` if <i>time</i> represents a time in UTC\n(GMT).\n\n   t = Time.now                        #=> 2007-11-19 08:15:23 -0600\n   t.utc?                              #=> false\n   t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.utc?                              #=> true\n\n   t = Time.now                        #=> 2007-11-19 08:16:03 -0600\n   t.gmt?                              #=> false\n   t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC\n   t.gmt?                              #=> true\n
gmt_offset Time.gmt_offset()\nReturns the offset in seconds between the timezone of <i>time</i>\nand UTC.\n\n   t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.gmt_offset                    #=> 0\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.gmt_offset                    #=> -21600\n
gmtime Time.gmtime()\nConverts <i>time</i> to UTC (GMT), modifying the receiver.\n\n   t = Time.now   #=> 2007-11-19 08:18:31 -0600\n   t.gmt?         #=> false\n   t.gmtime       #=> 2007-11-19 14:18:31 UTC\n   t.gmt?         #=> true\n\n   t = Time.now   #=> 2007-11-19 08:18:51 -0600\n   t.utc?         #=> false\n   t.utc          #=> 2007-11-19 14:18:51 UTC\n   t.utc?         #=> true\n
gmtoff Time.gmtoff()\nReturns the offset in seconds between the timezone of <i>time</i>\nand UTC.\n\n   t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.gmt_offset                    #=> 0\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.gmt_offset                    #=> -21600\n
hash Time.hash()\nReturn a hash code for this time object.\n
hour Time.hour()\nReturns the hour of the day (0..23) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:26:20 -0600\n   t.hour         #=> 8\n
inspect Time.inspect()\nReturns a string representing <i>time</i>. Equivalent to calling\n`Time#strftime` with a format string of\n```%Y-%m-%d` `%H:%M:%S` `%z`''\nfor a local time and\n```%Y-%m-%d` `%H:%M:%S` `UTC`''\nfor a UTC time.\n\n   Time.now.to_s       #=> "2007-10-05 16:09:51 +0900"\n   Time.now.utc.to_s   #=> "2007-10-05 07:09:51 UTC"\n
isdst Time.isdst()\nReturns `true` if <i>time</i> occurs during Daylight\nSaving Time in its time zone.\n CST6CDT:\n   Time.local(2000, 1, 1).zone    #=> "CST"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> "CDT"\n   Time.local(2000, 7, 1).isdst   #=> true\n   Time.local(2000, 7, 1).dst?    #=> true\n Asia/Tokyo:\n   Time.local(2000, 1, 1).zone    #=> "JST"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> "JST"\n   Time.local(2000, 7, 1).isdst   #=> false\n   Time.local(2000, 7, 1).dst?    #=> false\n
localtime Time.localtime(...)\nConverts <i>time</i> to local time (using the local time zone in\neffect for this process) modifying the receiver.\n\nIf _utc_offset_ is given, it is used instead of the local time.\n\n   t = Time.utc(2000, "jan", 1, 20, 15, 1) #=> 2000-01-01 20:15:01 UTC\n   t.utc?                                  #=> true\n\n   t.localtime                             #=> 2000-01-01 14:15:01 -0600\n   t.utc?                                  #=> false\n\n   t.localtime("+09:00")                   #=> 2000-01-02 05:15:01 +0900\n   t.utc?                                  #=> false\n
marshal_dump Time.marshal_dump()\nundocumented\n
marshal_load Time.marshal_load(p1)\nundocumented\n
mday Time.mday()\nReturns the day of the month (1..n) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:27:03 -0600\n   t.day          #=> 19\n   t.mday         #=> 19\n
min Time.min()\nReturns the minute of the hour (0..59) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:25:51 -0600\n   t.min          #=> 25\n
mon Time.mon()\nReturns the month of the year (1..12) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:27:30 -0600\n   t.mon          #=> 11\n   t.month        #=> 11\n
monday? Time.monday?()\nReturns `true` if <i>time</i> represents Monday.\n\n   t = Time.local(2003, 8, 4)       #=> 2003-08-04 00:00:00 -0500\n   p t.monday?                      #=> true\n
month Time.month()\nReturns the month of the year (1..12) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:27:30 -0600\n   t.mon          #=> 11\n   t.month        #=> 11\n
nsec Time.nsec()\nReturns just the number of nanoseconds for <i>time</i>.\n\n   t = Time.now        #=> 2007-11-17 15:18:03 +0900\n   "%10.9f" % t.to_f   #=> "1195280283.536151409"\n   t.nsec              #=> 536151406\n\nThe lowest digit of to_f and nsec is different because\nIEEE 754 double is not accurate enough to represent\nnanoseconds from the Epoch.\nThe accurate value is returned by nsec.\n
round Time.round(...)\nRounds sub seconds to a given precision in decimal digits (0 digits by\ndefault).\nIt returns a new time object.\n_ndigits_ should be zero or positive integer.\n\n    require 'time'\n\n    t = Time.utc(2010,3,30, 5,43,"25.123456789".to_r)\n    p t.iso8601(10)           #=> "2010-03-30T05:43:25.1234567890Z"\n    p t.round.iso8601(10)     #=> "2010-03-30T05:43:25.0000000000Z"\n    p t.round(0).iso8601(10)  #=> "2010-03-30T05:43:25.0000000000Z"\n    p t.round(1).iso8601(10)  #=> "2010-03-30T05:43:25.1000000000Z"\n    p t.round(2).iso8601(10)  #=> "2010-03-30T05:43:25.1200000000Z"\n    p t.round(3).iso8601(10)  #=> "2010-03-30T05:43:25.1230000000Z"\n    p t.round(4).iso8601(10)  #=> "2010-03-30T05:43:25.1235000000Z"\n    p t.round(5).iso8601(10)  #=> "2010-03-30T05:43:25.1234600000Z"\n    p t.round(6).iso8601(10)  #=> "2010-03-30T05:43:25.1234570000Z"\n    p t.round(7).iso8601(10)  #=> "2010-03-30T05:43:25.1234568000Z"\n    p t.round(8).iso8601(10)  #=> "2010-03-30T05:43:25.1234567900Z"\n    p t.round(9).iso8601(10)  #=> "2010-03-30T05:43:25.1234567890Z"\n    p t.round(10).iso8601(10) #=> "2010-03-30T05:43:25.1234567890Z"\n\n    t = Time.utc(1999,12,31, 23,59,59)\n    p((t + 0.4).round.iso8601(3))    #=> "1999-12-31T23:59:59.000Z"\n    p((t + 0.49).round.iso8601(3))   #=> "1999-12-31T23:59:59.000Z"\n    p((t + 0.5).round.iso8601(3))    #=> "2000-01-01T00:00:00.000Z"\n    p((t + 1.4).round.iso8601(3))    #=> "2000-01-01T00:00:00.000Z"\n    p((t + 1.49).round.iso8601(3))   #=> "2000-01-01T00:00:00.000Z"\n    p((t + 1.5).round.iso8601(3))    #=> "2000-01-01T00:00:01.000Z"\n\n    t = Time.utc(1999,12,31, 23,59,59)\n    p (t + 0.123456789).round(4).iso8601(6)  #=> "1999-12-31T23:59:59.123500Z"\n
saturday? Time.saturday?()\nReturns `true` if <i>time</i> represents Saturday.\n\n   t = Time.local(2006, 6, 10)      #=> 2006-06-10 00:00:00 -0500\n   t.saturday?                      #=> true\n
sec Time.sec()\nReturns the second of the minute (0..60)<em>[Yes, seconds really can\nrange from zero to 60. This allows the system to inject leap seconds\nevery now and then to correct for the fact that years are not really\na convenient number of hours long.]</em> for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:25:02 -0600\n   t.sec          #=> 2\n
strftime Time.strftime(p1)\nFormats <i>time</i> according to the directives in the given format\nstring. Any text not listed as a directive will be passed through\nto the output string.\n\nFormat meaning:\n  %a - The abbreviated weekday name (``Sun'')\n  %A - The  full  weekday  name (``Sunday'')\n  %b - The abbreviated month name (``Jan'')\n  %B - The  full  month  name (``January'')\n  %c - The preferred local date and time representation\n  %C - Century (20 in 2009)\n  %d - Day of the month (01..31)\n  %D - Date (%m/%d/%y)\n  %e - Day of the month, blank-padded ( 1..31)\n  %F - Equivalent to %Y-%m-%d (the ISO 8601 date format)\n  %h - Equivalent to %b\n  %H - Hour of the day, 24-hour clock (00..23)\n  %I - Hour of the day, 12-hour clock (01..12)\n  %j - Day of the year (001..366)\n  %k - hour, 24-hour clock, blank-padded ( 0..23)\n  %l - hour, 12-hour clock, blank-padded ( 0..12)\n  %L - Millisecond of the second (000..999)\n  %m - Month of the year (01..12)\n  %M - Minute of the hour (00..59)\n  %n - Newline (\\n)\n  %N - Fractional seconds digits, default is 9 digits (nanosecond)\n          %3N  millisecond (3 digits)\n          %6N  microsecond (6 digits)\n          %9N  nanosecond (9 digits)\n  %p - Meridian indicator (``AM''  or  ``PM'')\n  %P - Meridian indicator (``am''  or  ``pm'')\n  %r - time, 12-hour (same as %I:%M:%S %p)\n  %R - time, 24-hour (%H:%M)\n  %s - Number of seconds since 1970-01-01 00:00:00 UTC.\n  %S - Second of the minute (00..60)\n  %t - Tab character (\t)\n  %T - time, 24-hour (%H:%M:%S)\n  %u - Day of the week as a decimal, Monday being 1. (1..7)\n  %U - Week  number  of the current year,\n          starting with the first Sunday as the first\n          day of the first week (00..53)\n  %v - VMS date (%e-%b-%Y)\n  %V - Week number of year according to ISO 8601 (01..53)\n  %W - Week  number  of the current year,\n          starting with the first Monday as the first\n          day of the first week (00..53)\n  %w - Day of the week (Sunday is 0, 0..6)\n  %x - Preferred representation for the date alone, no time\n  %X - Preferred representation for the time alone, no date\n  %y - Year without a century (00..99)\n  %Y - Year with century\n  %z - Time zone as  hour offset from UTC (e.g. +0900)\n  %Z - Time zone name\n  %% - Literal ``%'' character\n\n   t = Time.now                        #=> 2007-11-19 08:37:48 -0600\n   t.strftime("Printed on %m/%d/%Y")   #=> "Printed on 11/19/2007"\n   t.strftime("at %I:%M%p")            #=> "at 08:37AM"\n
subsec Time.subsec()\nReturns just the fraction for <i>time</i>.\n\nThe result is possibly rational.\n\n   t = Time.now        #=> 2009-03-26 22:33:12 +0900\n   "%10.9f" % t.to_f   #=> "1238074392.940563917"\n   t.subsec            #=> (94056401/100000000)\n\nThe lowest digit of to_f and subsec is different because\nIEEE 754 double is not accurate enough to represent\nthe rational.\nThe accurate value is returned by subsec.\n
succ Time.succ()\nReturn a new time object, one second later than `time`.\nTime#succ is obsolete since 1.9.2 for time is not a discrete value.\n\n    t = Time.now       #=> 2007-11-19 08:23:57 -0600\n    t.succ             #=> 2007-11-19 08:23:58 -0600\n
sunday? Time.sunday?()\nReturns `true` if <i>time</i> represents Sunday.\n\n   t = Time.local(1990, 4, 1)       #=> 1990-04-01 00:00:00 -0600\n   t.sunday?                        #=> true\n
thursday? Time.thursday?()\nReturns `true` if <i>time</i> represents Thursday.\n\n   t = Time.local(1995, 12, 21)     #=> 1995-12-21 00:00:00 -0600\n   p t.thursday?                    #=> true\n
to_a Time.to_a()\nReturns a ten-element <i>array</i> of values for <i>time</i>:\n{`[ sec, min, hour, day, month, year, wday, yday, isdst, zone\n]`}. See the individual methods for an explanation of the\nvalid ranges of each value. The ten elements can be passed directly\nto `Time::utc` or `Time::local` to create a\nnew `Time`.\n\n   t = Time.now     #=> 2007-11-19 08:36:01 -0600\n   now = t.to_a     #=> [1, 36, 8, 19, 11, 2007, 1, 323, false, "CST"]\n
to_f Time.to_f()\nReturns the value of <i>time</i> as a floating point number of\nseconds since the Epoch.\n\n   t = Time.now\n   "%10.5f" % t.to_f   #=> "1270968744.77658"\n   t.to_i              #=> 1270968744\n\nNote that IEEE 754 double is not accurate enough to represent\nnumber of nanoseconds from the Epoch.\n
to_i Time.to_i()\nReturns the value of <i>time</i> as an integer number of seconds\nsince the Epoch.\n\n   t = Time.now\n   "%10.5f" % t.to_f   #=> "1270968656.89607"\n   t.to_i              #=> 1270968656\n
to_r Time.to_r()\nReturns the value of <i>time</i> as a rational number of seconds\nsince the Epoch.\n\n   t = Time.now\n   p t.to_r            #=> (1270968792716287611/1000000000)\n\nThis methods is intended to be used to get an accurate value\nrepresenting nanoseconds from the Epoch.  You can use this\nto convert time to another Epoch.\n
to_s Time.to_s()\nReturns a string representing <i>time</i>. Equivalent to calling\n`Time#strftime` with a format string of\n```%Y-%m-%d` `%H:%M:%S` `%z`''\nfor a local time and\n```%Y-%m-%d` `%H:%M:%S` `UTC`''\nfor a UTC time.\n\n   Time.now.to_s       #=> "2007-10-05 16:09:51 +0900"\n   Time.now.utc.to_s   #=> "2007-10-05 07:09:51 UTC"\n
tuesday? Time.tuesday?()\nReturns `true` if <i>time</i> represents Tuesday.\n\n   t = Time.local(1991, 2, 19)      #=> 1991-02-19 00:00:00 -0600\n   p t.tuesday?                     #=> true\n
tv_nsec Time.tv_nsec()\nReturns just the number of nanoseconds for <i>time</i>.\n\n   t = Time.now        #=> 2007-11-17 15:18:03 +0900\n   "%10.9f" % t.to_f   #=> "1195280283.536151409"\n   t.nsec              #=> 536151406\n\nThe lowest digit of to_f and nsec is different because\nIEEE 754 double is not accurate enough to represent\nnanoseconds from the Epoch.\nThe accurate value is returned by nsec.\n
tv_sec Time.tv_sec()\nReturns the value of <i>time</i> as an integer number of seconds\nsince the Epoch.\n\n   t = Time.now\n   "%10.5f" % t.to_f   #=> "1270968656.89607"\n   t.to_i              #=> 1270968656\n
tv_usec Time.tv_usec()\nReturns just the number of microseconds for <i>time</i>.\n\n   t = Time.now        #=> 2007-11-19 08:03:26 -0600\n   "%10.6f" % t.to_f   #=> "1195481006.775195"\n   t.usec              #=> 775195\n
usec Time.usec()\nReturns just the number of microseconds for <i>time</i>.\n\n   t = Time.now        #=> 2007-11-19 08:03:26 -0600\n   "%10.6f" % t.to_f   #=> "1195481006.775195"\n   t.usec              #=> 775195\n
utc Time.utc()\nConverts <i>time</i> to UTC (GMT), modifying the receiver.\n\n   t = Time.now   #=> 2007-11-19 08:18:31 -0600\n   t.gmt?         #=> false\n   t.gmtime       #=> 2007-11-19 14:18:31 UTC\n   t.gmt?         #=> true\n\n   t = Time.now   #=> 2007-11-19 08:18:51 -0600\n   t.utc?         #=> false\n   t.utc          #=> 2007-11-19 14:18:51 UTC\n   t.utc?         #=> true\n
utc? Time.utc?()\nReturns `true` if <i>time</i> represents a time in UTC\n(GMT).\n\n   t = Time.now                        #=> 2007-11-19 08:15:23 -0600\n   t.utc?                              #=> false\n   t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.utc?                              #=> true\n\n   t = Time.now                        #=> 2007-11-19 08:16:03 -0600\n   t.gmt?                              #=> false\n   t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC\n   t.gmt?                              #=> true\n
utc_offset Time.utc_offset()\nReturns the offset in seconds between the timezone of <i>time</i>\nand UTC.\n\n   t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.gmt_offset                    #=> 0\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.gmt_offset                    #=> -21600\n
wday Time.wday()\nReturns an integer representing the day of the week, 0..6, with\nSunday == 0.\n\n   t = Time.now   #=> 2007-11-20 02:35:35 -0600\n   t.wday         #=> 2\n   t.sunday?      #=> false\n   t.monday?      #=> false\n   t.tuesday?     #=> true\n   t.wednesday?   #=> false\n   t.thursday?    #=> false\n   t.friday?      #=> false\n   t.saturday?    #=> false\n
wednesday? Time.wednesday?()\nReturns `true` if <i>time</i> represents Wednesday.\n\n   t = Time.local(1993, 2, 24)      #=> 1993-02-24 00:00:00 -0600\n   p t.wednesday?                   #=> true\n
yday Time.yday()\nReturns an integer representing the day of the year, 1..366.\n\n   t = Time.now   #=> 2007-11-19 08:32:31 -0600\n   t.yday         #=> 323\n
year Time.year()\nReturns the year for <i>time</i> (including the century).\n\n   t = Time.now   #=> 2007-11-19 08:27:51 -0600\n   t.year         #=> 2007\n
zone Time.zone()\nReturns the name of the time zone used for <i>time</i>. As of Ruby\n1.8, returns ``UTC'' rather than ``GMT'' for UTC times.\n\n   t = Time.gm(2000, "jan", 1, 20, 15, 1)\n   t.zone   #=> "UTC"\n   t = Time.local(2000, "jan", 1, 20, 15, 1)\n   t.zone   #=> "CST"\n
destination_encoding Encoding::UndefinedConversionError.destination_encoding()\nReturns the destination encoding as an encoding object.\n
destination_encoding_name Encoding::UndefinedConversionError.destination_encoding_name()\nReturns the destination encoding name as a string.\n
error_char Encoding::UndefinedConversionError.error_char()\nReturns the one-character string which cause\nEncoding::UndefinedConversionError.\n\n ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP")\n begin\n   ec.convert("\xa0")\n rescue Encoding::UndefinedConversionError\n   puts $!.error_char.dump   #=> "\xC2\xA0"\n   p $!.error_char.encoding  #=> #<Encoding:UTF-8>\n end\n
source_encoding Encoding::UndefinedConversionError.source_encoding()\nReturns the source encoding as an encoding object.\n\nNote that the result may not be equal to the source encoding of\nthe encoding converter if the conversion has multiple steps.\n\n ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8\n -> EUC-JP\n begin\n   ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not\n   in EUC-JP.\n rescue Encoding::UndefinedConversionError\n   p $!.source_encoding              #=> #<Encoding:UTF-8>\n   p $!.destination_encoding         #=> #<Encoding:EUC-JP>\n   p $!.source_encoding_name         #=> "UTF-8"\n   p $!.destination_encoding_name    #=> "EUC-JP"\n end\n
source_encoding_name Encoding::UndefinedConversionError.source_encoding_name()\nReturns the source encoding name as a string.\n
destination_encoding Encoding::InvalidByteSequenceError.destination_encoding()\nReturns the destination encoding as an encoding object.\n
destination_encoding_name Encoding::InvalidByteSequenceError.destination_encoding_name()\nReturns the destination encoding name as a string.\n
error_bytes Encoding::InvalidByteSequenceError.error_bytes()\nReturns the discarded bytes when Encoding::InvalidByteSequenceError occurs.\n\n ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n begin\n   ec.convert("abc\xA1\xFFdef")\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by\n   "\xFF" on EUC-JP>\n   puts $!.error_bytes.dump          #=> "\xA1"\n   puts $!.readagain_bytes.dump      #=> "\xFF"\n end\n
incomplete_input? Encoding::InvalidByteSequenceError.incomplete_input?()\nReturns true if the invalid byte sequence error is caused by\npremature end of string.\n\n ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n\n begin\n   ec.convert("abc\xA1z")\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by\n   "z" on EUC-JP>\n   p $!.incomplete_input?    #=> false\n end\n\n begin\n   ec.convert("abc\xA1")\n   ec.finish\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: incomplete "\xA1"\n   on EUC-JP>\n   p $!.incomplete_input?    #=> true\n end\n
readagain_bytes Encoding::InvalidByteSequenceError.readagain_bytes()\nReturns the bytes to be read again when Encoding::InvalidByteSequenceError\noccurs.\n
source_encoding Encoding::InvalidByteSequenceError.source_encoding()\nReturns the source encoding as an encoding object.\n\nNote that the result may not be equal to the source encoding of\nthe encoding converter if the conversion has multiple steps.\n\n ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8\n -> EUC-JP\n begin\n   ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not\n   in EUC-JP.\n rescue Encoding::UndefinedConversionError\n   p $!.source_encoding              #=> #<Encoding:UTF-8>\n   p $!.destination_encoding         #=> #<Encoding:EUC-JP>\n   p $!.source_encoding_name         #=> "UTF-8"\n   p $!.destination_encoding_name    #=> "EUC-JP"\n end\n
source_encoding_name Encoding::InvalidByteSequenceError.source_encoding_name()\nReturns the source encoding name as a string.\n
asciicompat_encoding Encoding::Converter.asciicompat_encoding(p1)\nReturns the corresponding ASCII compatible encoding.\n\nReturns nil if the argument is an ASCII compatible encoding.\n\n"corresponding ASCII compatible encoding" is a ASCII compatible encoding which\ncan represents exactly the same characters as the given ASCII incompatible\nencoding.\nSo, no conversion undefined error occurs when converting between the two\nencodings.\n\n  Encoding::Converter.asciicompat_encoding("ISO-2022-JP") #=>\n  #<Encoding:stateless-ISO-2022-JP>\n  Encoding::Converter.asciicompat_encoding("UTF-16BE") #=> #<Encoding:UTF-8>\n  Encoding::Converter.asciicompat_encoding("UTF-8") #=> nil\n
new Encoding::Converter.new(...)\npossible options elements:\n  hash form:\n    :invalid => nil            # raise error on invalid byte sequence (default)\n    :invalid => :replace       # replace invalid byte sequence\n    :undef => nil              # raise error on undefined conversion (default)\n    :undef => :replace         # replace undefined conversion\n    :replace => string         # replacement string ("?" or "\uFFFD" if\n    not specified)\n    :universal_newline => true # decorator for converting CRLF and CR to LF\n    :crlf_newline => true      # decorator for converting LF to CRLF\n    :cr_newline => true        # decorator for converting LF to CR\n    :xml => :text              # escape as XML CharData.\n    :xml => :attr              # escape as XML AttValue\n  integer form:\n    Encoding::Converter::INVALID_REPLACE\n    Encoding::Converter::UNDEF_REPLACE\n    Encoding::Converter::UNDEF_HEX_CHARREF\n    Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR\n    Encoding::Converter::CRLF_NEWLINE_DECORATOR\n    Encoding::Converter::CR_NEWLINE_DECORATOR\n    Encoding::Converter::XML_TEXT_DECORATOR\n    Encoding::Converter::XML_ATTR_CONTENT_DECORATOR\n    Encoding::Converter::XML_ATTR_QUOTE_DECORATOR\n\nEncoding::Converter.new creates an instance of Encoding::Converter.\n\nSource_encoding and destination_encoding should be a string or\nEncoding object.\n\nopt should be nil, a hash or an integer.\n\nconvpath should be an array.\nconvpath may contain\n- two-element arrays which contain encodings or encoding names, or\n- strings representing decorator names.\n\nEncoding::Converter.new optionally takes an option.\nThe option should be a hash or an integer.\nThe option hash can contain :invalid => nil, etc.\nThe option integer should be logical-or of constants such as\nEncoding::Converter::INVALID_REPLACE, etc.\n\n[:invalid => nil]\n  Raise error on invalid byte sequence.  This is a default behavior.\n[:invalid => :replace]\n  Replace invalid byte sequence by replacement string.\n[:undef => nil]\n  Raise an error if a character in source_encoding is not defined in\n  destination_encoding.\n  This is a default behavior.\n[:undef => :replace]\n  Replace undefined character in destination_encoding with replacement string.\n[:replace => string]\n  Specify the replacement string.\n  If not specified, "\uFFFD" is used for Unicode encodings and "?" for others.\n[:universal_newline => true]\n  Convert CRLF and CR to LF.\n[:crlf_newline => true]\n  Convert LF to CRLF.\n[:cr_newline => true]\n  Convert LF to CR.\n[:xml => :text]\n  Escape as XML CharData.\n  This form can be used as a HTML 4.0 #PCDATA.\n  - '&' -> '&amp;'\n  - '<' -> '&lt;'\n  - '>' -> '&gt;'\n  - undefined characters in destination_encoding -> hexadecimal CharRef such\n  as &#xHH;\n[:xml => :attr]\n  Escape as XML AttValue.\n  The converted result is quoted as "...".\n  This form can be used as a HTML 4.0 attribute value.\n  - '&' -> '&amp;'\n  - '<' -> '&lt;'\n  - '>' -> '&gt;'\n  - '"' -> '&quot;'\n  - undefined characters in destination_encoding -> hexadecimal CharRef such\n  as &#xHH;\n\nExamples:\n UTF-16BE to UTF-8\n  ec = Encoding::Converter.new("UTF-16BE", "UTF-8")\n Usually, decorators such as newline conversion are inserted last.\n  ec = Encoding::Converter.new("UTF-16BE", "UTF-8", :universal_newline => true)\n  p ec.convpath #=> [[#<Encoding:UTF-16BE>, #<Encoding:UTF-8>],\n    "universal_newline"]\n But, if the last encoding is ASCII incompatible,\n decorators are inserted before the last conversion.\n  ec = Encoding::Converter.new("UTF-8", "UTF-16BE", :crlf_newline => true)\n  p ec.convpath #=> ["crlf_newline",\n    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]\n Conversion path can be specified directly.\n  ec = Encoding::Converter.new(["universal_newline", ["EUC-JP", "UTF-8"],\n  ["UTF-8", "UTF-16BE"]])\n  p ec.convpath #=> ["universal_newline",\n    [#<Encoding:EUC-JP>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]\n
search_convpath Encoding::Converter.search_convpath(...)\nReturns a conversion path.\n\n p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP")\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>]]\n\n p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP",\n universal_newline: true)\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],\n    "universal_newline"]\n\n p Encoding::Converter.search_convpath("ISO-8859-1", "UTF-32BE",\n universal_newline: true)\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    "universal_newline",\n    [#<Encoding:UTF-8>, #<Encoding:UTF-32BE>]]\n
convert Encoding::Converter.convert(p1)\nConvert source_string and return destination_string.\n\nsource_string is assumed as a part of source.\ni.e.  :partial_input=>true is specified internally.\nfinish method should be used last.\n\n  ec = Encoding::Converter.new("utf-8", "euc-jp")\n  puts ec.convert("\u3042").dump     #=> "\xA4\xA2"\n  puts ec.finish.dump                #=> ""\n\n  ec = Encoding::Converter.new("euc-jp", "utf-8")\n  puts ec.convert("\xA4").dump       #=> ""\n  puts ec.convert("\xA2").dump       #=> "\xE3\x81\x82"\n  puts ec.finish.dump                #=> ""\n\n  ec = Encoding::Converter.new("utf-8", "iso-2022-jp")\n  puts ec.convert("\xE3").dump       #=> "".force_encoding("ISO-2022-JP")\n  puts ec.convert("\x81").dump       #=> "".force_encoding("ISO-2022-JP")\n  puts ec.convert("\x82").dump       #=>\n  "\e$B$\"".force_encoding("ISO-2022-JP")\n  puts ec.finish.dump                #=> "\e(B".force_encoding("ISO-2022-JP")\n\nIf a conversion error occur,\nEncoding::UndefinedConversionError or\nEncoding::InvalidByteSequenceError is raised.\nEncoding::Converter#convert doesn't supply methods to recover or restart\nfrom these exceptions.\nWhen you want to handle these conversion errors,\nuse Encoding::Converter#primitive_convert.\n
convpath Encoding::Converter.convpath()\nReturns the conversion path of ec.\n\nThe result is an array of conversions.\n\n  ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP", crlf_newline: true)\n  p ec.convpath\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],\n    "crlf_newline"]\n\nEach element of the array is a pair of encodings or a string.\nA pair means an encoding conversion.\nA string means a decorator.\n\nIn the above example, [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>] means\na converter from ISO-8859-1 to UTF-8.\n"crlf_newline" means newline converter from LF to CRLF.\n
destination_encoding Encoding::Converter.destination_encoding()\nReturns the destination encoding as an Encoding object.\n
finish Encoding::Converter.finish()\nFinishes the converter.\nIt returns the last part of the converted string.\n\n  ec = Encoding::Converter.new("utf-8", "iso-2022-jp")\n  p ec.convert("\u3042")     #=> "\e$B$\""\n  p ec.finish                #=> "\e(B"\n
insert_output Encoding::Converter.insert_output(p1)\nInserts string into the encoding converter.\nThe string will be converted to the destination encoding and\noutput on later conversions.\n\nIf the destination encoding is stateful,\nstring is converted according to the state and the state is updated.\n\nThis method should be used only when a conversion error occurs.\n\n ec = Encoding::Converter.new("utf-8", "iso-8859-1")\n src = "HIRAGANA LETTER A is \u{3042}."\n dst = ""\n p ec.primitive_convert(src, dst)    #=> :undefined_conversion\n puts "[#{dst.dump}, #{src.dump}]"   #=> ["HIRAGANA LETTER A is ", "."]\n ec.insert_output("<err>")\n p ec.primitive_convert(src, dst)    #=> :finished\n puts "[#{dst.dump}, #{src.dump}]"   #=> ["HIRAGANA LETTER A is <err>.", ""]\n\n ec = Encoding::Converter.new("utf-8", "iso-2022-jp")\n src = "\u{306F 3041 3068 2661 3002}" # U+2661 is not representable in\n iso-2022-jp\n dst = ""\n p ec.primitive_convert(src, dst)    #=> :undefined_conversion\n puts "[#{dst.dump}, #{src.dump}]"   #=>\n ["\e$B$O$!$H".force_encoding("ISO-2022-JP"), "\xE3\x80\x82"]\n ec.insert_output "?"                # state change required to output "?".\n p ec.primitive_convert(src, dst)    #=> :finished\n puts "[#{dst.dump}, #{src.dump}]"   #=>\n ["\e$B$O$!$H\e(B?\e$B!#\e(B".force_encoding("ISO-2022-JP"), ""]\n
inspect Encoding::Converter.inspect()\nReturns a printable version of <i>ec</i>\n\n  ec = Encoding::Converter.new("iso-8859-1", "utf-8")\n  puts ec.inspect    #=> #<Encoding::Converter: ISO-8859-1 to UTF-8>\n
last_error Encoding::Converter.last_error()\nReturns an exception object for the last conversion.\nReturns nil if the last conversion did not produce an error.\n\n"error" means that\nEncoding::InvalidByteSequenceError and Encoding::UndefinedConversionError for\nEncoding::Converter#convert and\n:invalid_byte_sequence, :incomplete_input and :undefined_conversion for\nEncoding::Converter#primitive_convert.\n\n ec = Encoding::Converter.new("utf-8", "iso-8859-1")\n p ec.primitive_convert(src="\xf1abcd", dst="")       #=>\n :invalid_byte_sequence\n p ec.last_error      #=> #<Encoding::InvalidByteSequenceError: "\xF1"\n followed by "a" on UTF-8>\n p ec.primitive_convert(src, dst, nil, 1)             #=>\n :destination_buffer_full\n p ec.last_error      #=> nil\n
primitive_convert Encoding::Converter.primitive_convert(...)\npossible opt elements:\n  hash form:\n    :partial_input => true           # source buffer may be part of larger\n    source\n    :after_output => true            # stop conversion after output before\n    input\n  integer form:\n    Encoding::Converter::PARTIAL_INPUT\n    Encoding::Converter::AFTER_OUTPUT\n\npossible results:\n   :invalid_byte_sequence\n   :incomplete_input\n   :undefined_conversion\n   :after_output\n   :destination_buffer_full\n   :source_buffer_empty\n   :finished\n\nprimitive_convert converts source_buffer into destination_buffer.\n\nsource_buffer should be a string or nil.\nnil means a empty string.\n\ndestination_buffer should be a string.\n\ndestination_byteoffset should be an integer or nil.\nnil means the end of destination_buffer.\nIf it is omitted, nil is assumed.\n\ndestination_bytesize should be an integer or nil.\nnil means unlimited.\nIf it is omitted, nil is assumed.\n\nopt should be nil, a hash or an integer.\nnil means no flags.\nIf it is omitted, nil is assumed.\n\nprimitive_convert converts the content of source_buffer from beginning\nand store the result into destination_buffer.\n\ndestination_byteoffset and destination_bytesize specify the region which\nthe converted result is stored.\ndestination_byteoffset specifies the start position in destination_buffer\nin bytes.\nIf destination_byteoffset is nil,\ndestination_buffer.bytesize is used for appending the result.\ndestination_bytesize specifies maximum number of bytes.\nIf destination_bytesize is nil,\ndestination size is unlimited.\nAfter conversion, destination_buffer is resized to\ndestination_byteoffset + actually produced number of bytes.\nAlso destination_buffer's encoding is set to destination_encoding.\n\nprimitive_convert drops the converted part of source_buffer.\nthe dropped part is converted in destination_buffer or\nbuffered in Encoding::Converter object.\n\nprimitive_convert stops conversion when one of following condition met.\n- invalid byte sequence found in source buffer (:invalid_byte_sequence)\n- unexpected end of source buffer (:incomplete_input)\n  this occur only when :partial_input is not specified.\n- character not representable in output encoding (:undefined_conversion)\n- after some output is generated, before input is done (:after_output)\n  this occur only when :after_output is specified.\n- destination buffer is full (:destination_buffer_full)\n  this occur only when destination_bytesize is non-nil.\n- source buffer is empty (:source_buffer_empty)\n  this occur only when :partial_input is specified.\n- conversion is finished (:finished)\n\nexample:\n  ec = Encoding::Converter.new("UTF-8", "UTF-16BE")\n  ret = ec.primitive_convert(src="pi", dst="", nil, 100)\n  p [ret, src, dst] #=> [:finished, "", "\x00p\x00i"]\n\n  ec = Encoding::Converter.new("UTF-8", "UTF-16BE")\n  ret = ec.primitive_convert(src="pi", dst="", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, "i", "\x00"]\n  ret = ec.primitive_convert(src, dst="", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, "", "p"]\n  ret = ec.primitive_convert(src, dst="", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, "", "\x00"]\n  ret = ec.primitive_convert(src, dst="", nil, 1)\n  p [ret, src, dst] #=> [:finished, "", "i"]\n
primitive_errinfo Encoding::Converter.primitive_errinfo()\nprimitive_errinfo returns important information regarding the last error\nas a 5-element array:\n\n  [result, enc1, enc2, error_bytes, readagain_bytes]\n\nresult is the last result of primitive_convert.\n\nOther elements are only meaningful when result is\n:invalid_byte_sequence, :incomplete_input or :undefined_conversion.\n\nenc1 and enc2 indicate a conversion step as a pair of strings.\nFor example, a converter from EUC-JP to ISO-8859-1 converts\na string as follows: EUC-JP -> UTF-8 -> ISO-8859-1.\nSo [enc1, enc2] is either ["EUC-JP", "UTF-8"] or ["UTF-8", "ISO-8859-1"].\n\nerror_bytes and readagain_bytes indicate the byte sequences which caused\nthe error.\nerror_bytes is discarded portion.\nreadagain_bytes is buffered portion which is read again on next conversion.\n\nExample:\n \xff is invalid as EUC-JP.\n  ec = Encoding::Converter.new("EUC-JP", "Shift_JIS")\n  ec.primitive_convert(src="\xff", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:invalid_byte_sequence, "EUC-JP", "UTF-8", "\xFF", ""]\n HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.\n Since this error is occur in UTF-8 to ISO-8859-1 conversion,\n error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).\n  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n  ec.primitive_convert(src="\xa4\xa2", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:undefined_conversion, "UTF-8", "ISO-8859-1", "\xE3\x81\x82", ""]\n partial character is invalid\n  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n  ec.primitive_convert(src="\xa4", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:incomplete_input, "EUC-JP", "UTF-8", "\xA4", ""]\n Encoding::Converter::PARTIAL_INPUT prevents invalid errors by\n partial characters.\n  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n  ec.primitive_convert(src="\xa4", dst="", nil, 10,\n  Encoding::Converter::PARTIAL_INPUT)\n  p ec.primitive_errinfo\n=> [:source_buffer_empty, nil, nil, nil, nil]\n \xd8\x00\x00@ is invalid as UTF-16BE because\n no low surrogate after high surrogate (\xd8\x00).\n It is detected by 3rd byte (\00) which is part of next character.\n So the high surrogate (\xd8\x00) is discarded and\n the 3rd byte is read again later.\n Since the byte is buffered in ec, it is dropped from src.\n  ec = Encoding::Converter.new("UTF-16BE", "UTF-8")\n  ec.primitive_convert(src="\xd8\x00\x00@", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:invalid_byte_sequence, "UTF-16BE", "UTF-8", "\xD8\x00", "\x00"]\n  p src\n=> "@"\n Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.\n The problem is detected by 4th byte.\n  ec = Encoding::Converter.new("UTF-16LE", "UTF-8")\n  ec.primitive_convert(src="\x00\xd8@\x00", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8", "\x00\xD8", "@\x00"]\n  p src\n=> ""\n
putback Encoding::Converter.putback(...)\ncall-seq\n  ec.putback                    -> string\n  ec.putback(max_numbytes)      -> string\n\nPut back the bytes which will be converted.\n\nThe bytes are caused by invalid_byte_sequence error.\nWhen invalid_byte_sequence error, some bytes are discarded and\nsome bytes are buffered to be converted later.\nThe latter bytes can be put back.\nIt can be observed by\nEncoding::InvalidByteSequenceError#readagain_bytes and\nEncoding::Converter#primitive_errinfo.\n\n  ec = Encoding::Converter.new("utf-16le", "iso-8859-1")\n  src = "\x00\xd8\x61\x00"\n  dst = ""\n  p ec.primitive_convert(src, dst)   #=> :invalid_byte_sequence\n  p ec.primitive_errinfo     #=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8",\n  "\x00\xD8", "a\x00"]\n  p ec.putback               #=> "a\x00"\n  p ec.putback               #=> ""          # no more bytes to put back\n
replacement Encoding::Converter.replacement()\nReturns the replacement string.\n\n ec = Encoding::Converter.new("euc-jp", "us-ascii")\n p ec.replacement    #=> "?"\n\n ec = Encoding::Converter.new("euc-jp", "utf-8")\n p ec.replacement    #=> "\uFFFD"\n
replacement= Encoding::Converter.replacement=(p1)\nSets the replacement string.\n\n ec = Encoding::Converter.new("utf-8", "us-ascii", :undef => :replace)\n ec.replacement = "<undef>"\n p ec.convert("a \u3042 b")      #=> "a <undef> b"\n
source_encoding Encoding::Converter.source_encoding()\nReturns the source encoding as an Encoding object.\n
between? Comparable.between?(p1, p2)\nReturns `false` if <i>obj</i> `<=>`\n<i>min</i> is less than zero or if <i>anObject</i> `<=>`\n<i>max</i> is greater than zero, `true` otherwise.\n\n   3.between?(1, 5)               #=> true\n   6.between?(1, 5)               #=> false\n   'cat'.between?('ant', 'dog')   #=> true\n   'gnu'.between?('ant', 'dog')   #=> false\n
Array Kernel.Array(p1)\nReturns <i>arg</i> as an `Array`. First tries to call\n<i>arg</i>`.to_ary`, then <i>arg</i>`.to_a`.\n\n   Array(1..5)   #=> [1, 2, 3, 4, 5]\n
Complex Kernel.Complex(...)\nReturns x+i*y;\n
Float Kernel.Float(p1)\nReturns <i>arg</i> converted to a float. Numeric types are converted\ndirectly, the rest are converted using <i>arg</i>.to_f. As of Ruby\n1.8, converting `nil` generates a `TypeError`.\n\n   Float(1)           #=> 1.0\n   Float("123.456")   #=> 123.456\n
Integer Kernel.Integer(...)\nConverts <i>arg</i> to a `Fixnum` or `Bignum`.\nNumeric types are converted directly (with floating point numbers\nbeing truncated).    <i>base</i> (0, or between 2 and 36) is a base for\ninteger string representation.  If <i>arg</i> is a `String`,\nwhen <i>base</i> is omitted or equals to zero, radix indicators\n(`0`, `0b`, and `0x`) are honored.\nIn any case, strings should be strictly conformed to numeric\nrepresentation. This behavior is different from that of\n`String#to_i`.  Non string values will be converted using\n`to_int`, and `to_i`.\n\n   Integer(123.999)    #=> 123\n   Integer("0x1a")     #=> 26\n   Integer(Time.new)   #=> 1204973019\n
Rational Kernel.Rational(...)\nReturns x/y;\n
String Kernel.String(p1)\nConverts <i>arg</i> to a `String` by calling its\n`to_s` method.\n\n   String(self)        #=> "main"\n   String(self.class)  #=> "Object"\n   String(123456)      #=> "123456"\n
__callee__ Kernel.__callee__()\nReturns the name of the current method as a Symbol.\nIf called outside of a method, it returns `nil`.\n
__method__ Kernel.__method__()\nReturns the name of the current method as a Symbol.\nIf called outside of a method, it returns `nil`.\n
abort Kernel.abort(...)\nTerminate execution immediately, effectively by calling\n`Kernel.exit(false)`. If _msg_ is given, it is written\nto STDERR prior to terminating.\n
at_exit Kernel.at_exit()\nConverts _block_ to a +Proc+ object (and therefore\nbinds it at the point of call) and registers it for execution when\nthe program exits. If multiple handlers are registered, they are\nexecuted in reverse order of registration.\n\n   def do_at_exit(str1)\n     at_exit { print str1 }\n   end\n   at_exit { puts "cruel world" }\n   do_at_exit("goodbye ")\n   exit\n\n<em>produces:</em>\n\n   goodbye cruel world\n
autoload Kernel.autoload(p1, p2)\nRegisters _filename_ to be loaded (using `Kernel::require`)\nthe first time that _module_ (which may be a `String` or\na symbol) is accessed.\n\n   autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")\n
autoload? Kernel.autoload?(p1)\nReturns _filename_ to be loaded if _name_ is registered as\n+autoload+.\n\n   autoload(:B, "b")\n   autoload?(:B)            #=> "b"\n
binding Kernel.binding()\nReturns a +Binding+ object, describing the variable and\nmethod bindings at the point of call. This object can be used when\ncalling +eval+ to execute the evaluated command in this\nenvironment. Also see the description of class +Binding+.\n\n   def getBinding(param)\n     return binding\n   end\n   b = getBinding("hello")\n   eval("param", b)   #=> "hello"\n
block_given? Kernel.block_given?()\nReturns `true` if `yield` would execute a\nblock in the current context. The `iterator?` form\nis mildly deprecated.\n\n   def try\n     if block_given?\n       yield\n     else\n       "no block"\n     end\n   end\n   try                  #=> "no block"\n   try { "hello" }      #=> "hello"\n   try do "hello" end   #=> "hello"\n
callcc Kernel.callcc()\nGenerates a `Continuation` object, which it passes to the\nassociated block. Performing a <em>cont</em>`.call` will\ncause the `callcc` to return (as will falling through the\nend of the block). The value returned by the `callcc` is\nthe value of the block, or the value passed to\n<em>cont</em>`.call`. See class `Continuation`\nfor more details. Also see `Kernel::throw` for\nan alternative mechanism for unwinding a call stack.\n
caller Kernel.caller(...)\nReturns the current execution stack---an array containing strings in\nthe form ``<em>file:line</em>'' or ``<em>file:line: in\n`method'</em>''. The optional _start_ parameter\ndetermines the number of initial stack entries to omit from the\nresult.\n\nReturns +nil+ if _start_ is greater than the size of\ncurrent execution stack.\n\n   def a(skip)\n     caller(skip)\n   end\n   def b(skip)\n     a(skip)\n   end\n   def c(skip)\n     b(skip)\n   end\n   c(0)   #=> ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in\n   `<main>'"]\n   c(1)   #=> ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `<main>'"]\n   c(2)   #=> ["prog:8:in `c'", "prog:12:in `<main>'"]\n   c(3)   #=> ["prog:13:in `<main>'"]\n   c(4)   #=> []\n   c(5)   #=> nil\n
catch Kernel.catch(...)\n+catch+ executes its block. If a +throw+ is\nexecuted, Ruby searches up its stack for a +catch+ block\nwith a tag corresponding to the +throw+'s\n_tag_. If found, that block is terminated, and\n+catch+ returns the value given to +throw+. If\n+throw+ is not called, the block terminates normally, and\nthe value of +catch+ is the value of the last expression\nevaluated. +catch+ expressions may be nested, and the\n+throw+ call need not be in lexical scope.\n\n   def routine(n)\n     puts n\n     throw :done if n <= 0\n     routine(n-1)\n   end\n\n\n   catch(:done) { routine(3) }\n\n<em>produces:</em>\n\n   3\n   2\n   1\n   0\n\nwhen _arg_ is given, +catch+ yields it as is, or when no\n_arg_ is given, +catch+ assigns a new unique object to\n+throw+.  this is useful for nested +catch+.  _arg_ can\nbe an arbitrary object, not only Symbol.\n
chomp Kernel.chomp(...)\nEquivalent to `$_ = $_.chomp(<em>string</em>)`. See\n`String#chomp`.\nAvailable only when -p/-n command line option specified.\n
chop Kernel.chop()\nEquivalent to `($_.dup).chop!`, except `nil`\nis never returned. See `String#chop!`.\nAvailable only when -p/-n command line option specified.\n
eval Kernel.eval(...)\nEvaluates the Ruby expression(s) in <em>string</em>. If\n<em>binding</em> is given, which must be a `Binding`\nobject, the evaluation is performed in its context. If the\noptional <em>filename</em> and <em>lineno</em> parameters are\npresent, they will be used when reporting syntax errors.\n\n   def getBinding(str)\n     return binding\n   end\n   str = "hello"\n   eval "str + ' Fred'"                      #=> "hello Fred"\n   eval "str + ' Fred'", getBinding("bye")   #=> "bye Fred"\n
exec Kernel.exec(...)\nReplaces the current process by running the given external _command_.\n_command..._ is one of following forms.\n\n  commandline                 : command line string which is passed to the\n  standard shell\n  cmdname, arg1, ...          : command name and one or more arguments\n  (no shell)\n  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more\n  arguments (no shell)\n\nIf single string is given as the command,\nit is taken as a command line that is subject to shell expansion before\nbeing executed.\n\nThe standard shell means always `"/bin/sh"` on Unix-like systems,\n`ENV["RUBYSHELL"]` or `ENV["COMSPEC"]` on Windows NT series, and\nsimilar.\n\nIf two or more +string+ given,\nthe first is taken as a command name and\nthe rest are passed as parameters to command with no shell expansion.\n\nIf a two-element array at the beginning of the command,\nthe first element is the command to be executed,\nand the second argument is used as the `argv[0]` value,\nwhich may show up in process listings.\n\nIn order to execute the command, one of the `exec(2)`\nsystem calls is used, so the running command may inherit some of the\nenvironment\nof the original program (including open file descriptors).\nThis behavior is modified by env and options.\nSee `spawn` for details.\n\nRaises SystemCallError if the command couldn't execute (typically\n`Errno::ENOENT` when it was not found).\n\n   exec "echo *"       # echoes list of files in current directory\n never get here\n\n\n   exec "echo", "*"    # echoes an asterisk\n never get here\n
exit Kernel.exit(...)\nInitiates the termination of the Ruby script by raising the\n`SystemExit` exception. This exception may be caught. The\noptional parameter is used to return a status code to the invoking\nenvironment.\n+true+ and +FALSE+ of _status_ means success and failure\nrespectively.  The interpretation of other integer values are\nsystem dependent.\n\n   begin\n     exit\n     puts "never get here"\n   rescue SystemExit\n     puts "rescued a SystemExit exception"\n   end\n   puts "after begin block"\n\n<em>produces:</em>\n\n   rescued a SystemExit exception\n   after begin block\n\nJust prior to termination, Ruby executes any `at_exit` functions\n(see Kernel::at_exit) and runs any object finalizers (see\nObjectSpace::define_finalizer).\n\n   at_exit { puts "at_exit function" }\n   ObjectSpace.define_finalizer("string",  proc { puts "in finalizer" })\n   exit\n\n<em>produces:</em>\n\n   at_exit function\n   in finalizer\n
exit! Kernel.exit!(...)\nExits the process immediately. No exit handlers are\nrun. <em>status</em> is returned to the underlying system as the\nexit status.\n\n   Process.exit!(true)\n
fail Kernel.fail(...)\nWith no arguments, raises the exception in `$!` or raises\na `RuntimeError` if `$!` is +nil+.\nWith a single +String+ argument, raises a\n+RuntimeError+ with the string as a message. Otherwise,\nthe first parameter should be the name of an +Exception+\nclass (or an object that returns an +Exception+ object when sent\nan +exception+ message). The optional second parameter sets the\nmessage associated with the exception, and the third parameter is an\narray of callback information. Exceptions are caught by the\n+rescue+ clause of `begin...end` blocks.\n\n   raise "Failed to create socket"\n   raise ArgumentError, "No parameters", caller\n
fork Kernel.fork()\nCreates a subprocess. If a block is specified, that block is run\nin the subprocess, and the subprocess terminates with a status of\nzero. Otherwise, the +fork+ call returns twice, once in\nthe parent, returning the process ID of the child, and once in\nthe child, returning _nil_. The child process can exit using\n`Kernel.exit!` to avoid running any\n`at_exit` functions. The parent process should\nuse `Process.wait` to collect the termination statuses\nof its children or use `Process.detach` to register\ndisinterest in their status; otherwise, the operating system\nmay accumulate zombie processes.\n\nThe thread calling fork is the only thread in the created child process.\nfork doesn't copy other threads.\n\nIf fork is not usable, Process.respond_to?(:fork) returns false.\n
format Kernel.format(...)\nReturns the string resulting from applying <i>format_string</i> to\nany additional arguments.  Within the format string, any characters\nother than format sequences are copied to the result.\n\nThe syntax of a format sequence is follows.\n\n  %[flags][width][.precision]type\n\nA format\nsequence consists of a percent sign, followed by optional flags,\nwidth, and precision indicators, then terminated with a field type\ncharacter.  The field type controls how the corresponding\n`sprintf` argument is to be interpreted, while the flags\nmodify that interpretation.\n\nThe field type characters are:\n\n    Field |  Integer Format\n    ------+--------------------------------------------------------------\n      b   | Convert argument as a binary number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..1'.\n      B   | Equivalent to `b', but uses an uppercase 0B for prefix\n          | in the alternative format by #.\n      d   | Convert argument as a decimal number.\n      i   | Identical to `d'.\n      o   | Convert argument as an octal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..7'.\n      u   | Identical to `d'.\n      x   | Convert argument as a hexadecimal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..f' (representing an infinite string of\n          | leading 'ff's).\n      X   | Equivalent to `x', but uses uppercase letters.\n\n    Field |  Float Format\n    ------+--------------------------------------------------------------\n      e   | Convert floating point argument into exponential notation\n          | with one digit before the decimal point as [-]d.dddddde[+-]dd.\n          | The precision specifies the number of digits after the decimal\n          | point (defaulting to six).\n      E   | Equivalent to `e', but uses an uppercase E to indicate\n          | the exponent.\n      f   | Convert floating point argument as [-]ddd.dddddd,\n          | where the precision specifies the number of digits after\n          | the decimal point.\n      g   | Convert a floating point number using exponential form\n          | if the exponent is less than -4 or greater than or\n          | equal to the precision, or in dd.dddd form otherwise.\n          | The precision specifies the number of significant digits.\n      G   | Equivalent to `g', but use an uppercase `E' in exponent form.\n      a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,\n          | which is consisted from optional sign, "0x", fraction part\n          | as hexadecimal, "p", and exponential part as decimal.\n      A   | Equivalent to `a', but use uppercase `X' and `P'.\n\n    Field |  Other Format\n    ------+--------------------------------------------------------------\n      c   | Argument is the numeric code for a single character or\n          | a single character string itself.\n      p   | The valuing of argument.inspect.\n      s   | Argument is a string to be substituted.  If the format\n          | sequence contains a precision, at most that many characters\n          | will be copied.\n      %   | A percent sign itself will be displayed.  No argument taken.\n\nThe flags modifies the behavior of the formats.\nThe flag characters are:\n\n  Flag     | Applies to    | Meaning\n  ---------+---------------+-----------------------------------------\n  space    | bBdiouxX      | Leave a space at the start of\n           | aAeEfgG       | non-negative numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  (digit)$ | all           | Specifies the absolute argument number\n           |               | for this field.  Absolute and relative\n           |               | argument numbers cannot be mixed in a\n           |               | sprintf string.\n  ---------+---------------+-----------------------------------------\n       | bBoxX         | Use an alternative format.\n           | aAeEfgG       | For the conversions `o', increase the precision\n           |               | until the first digit will be `0' if\n           |               | it is not formatted as complements.\n           |               | For the conversions `x', `X', `b' and `B'\n           |               | on non-zero, prefix the result with ``0x'',\n           |               | ``0X'', ``0b'' and ``0B'', respectively.\n           |               | For `a', `A', `e', `E', `f', `g', and 'G',\n           |               | force a decimal point to be added,\n           |               | even if no digits follow.\n           |               | For `g' and 'G', do not remove trailing zeros.\n  ---------+---------------+-----------------------------------------\n  +        | bBdiouxX      | Add a leading plus sign to non-negative\n           | aAeEfgG       | numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  -        | all           | Left-justify the result of this conversion.\n  ---------+---------------+-----------------------------------------\n  0 (zero) | bBdiouxX      | Pad with zeros, not spaces.\n           | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1\n           | (numeric fmt) | is used for negative numbers formatted as\n           |               | complements.\n  ---------+---------------+-----------------------------------------\n  *        | all           | Use the next argument as the field width.\n           |               | If negative, left-justify the result. If the\n           |               | asterisk is followed by a number and a dollar\n           |               | sign, use the indicated argument as the width.\n\nExamples of flags:\n `+' and space flag specifies the sign of non-negative numbers.\n sprintf("%d", 123)  #=> "123"\n sprintf("%+d", 123) #=> "+123"\n sprintf("% d", 123) #=> " 123"\n `#' flag for `o' increases number of digits to show `0'.\n `+' and space flag changes format of negative numbers.\n sprintf("%o", 123)   #=> "173"\n sprintf("%#o", 123)  #=> "0173"\n sprintf("%+o", -123) #=> "-173"\n sprintf("%o", -123)  #=> "..7605"\n sprintf("%#o", -123) #=> "..7605"\n `#' flag for `x' add a prefix `0x' for non-zero numbers.\n `+' and space flag disables complements for negative numbers.\n sprintf("%x", 123)   #=> "7b"\n sprintf("%#x", 123)  #=> "0x7b"\n sprintf("%+x", -123) #=> "-7b"\n sprintf("%x", -123)  #=> "..f85"\n sprintf("%#x", -123) #=> "0x..f85"\n sprintf("%#x", 0)    #=> "0"\n `#' for `X' uses the prefix `0X'.\n sprintf("%X", 123)  #=> "7B"\n sprintf("%#X", 123) #=> "0X7B"\n `#' flag for `b' add a prefix `0b' for non-zero numbers.\n `+' and space flag disables complements for negative numbers.\n sprintf("%b", 123)   #=> "1111011"\n sprintf("%#b", 123)  #=> "0b1111011"\n sprintf("%+b", -123) #=> "-1111011"\n sprintf("%b", -123)  #=> "..10000101"\n sprintf("%#b", -123) #=> "0b..10000101"\n sprintf("%#b", 0)    #=> "0"\n `#' for `B' uses the prefix `0B'.\n sprintf("%B", 123)  #=> "1111011"\n sprintf("%#B", 123) #=> "0B1111011"\n `#' for `e' forces to show the decimal point.\n sprintf("%.0e", 1)  #=> "1e+00"\n sprintf("%#.0e", 1) #=> "1.e+00"\n `#' for `f' forces to show the decimal point.\n sprintf("%.0f", 1234)  #=> "1234"\n sprintf("%#.0f", 1234) #=> "1234."\n `#' for `g' forces to show the decimal point.\n It also disables stripping lowest zeros.\n sprintf("%g", 123.4)   #=> "123.4"\n sprintf("%#g", 123.4)  #=> "123.400"\n sprintf("%g", 123456)  #=> "123456"\n sprintf("%#g", 123456) #=> "123456."\n\nThe field width is an optional integer, followed optionally by a\nperiod and a precision.  The width specifies the minimum number of\ncharacters that will be written to the result for this field.\n\nExamples of width:\n padding is done by spaces,       width=20\n 0 or radix-1.             <------------------>\n sprintf("%20d", 123)   #=> "                 123"\n sprintf("%+20d", 123)  #=> "                +123"\n sprintf("%020d", 123)  #=> "00000000000000000123"\n sprintf("%+020d", 123) #=> "+0000000000000000123"\n sprintf("% 020d", 123) #=> " 0000000000000000123"\n sprintf("%-20d", 123)  #=> "123                 "\n sprintf("%-+20d", 123) #=> "+123                "\n sprintf("%- 20d", 123) #=> " 123                "\n sprintf("%020x", -123) #=> "..ffffffffffffffff85"\n\nFor\nnumeric fields, the precision controls the number of decimal places\ndisplayed.  For string fields, the precision determines the maximum\nnumber of characters to be copied from the string.  (Thus, the format\nsequence `%10.10s` will always contribute exactly ten\ncharacters to the result.)\n\nExamples of precisions:\n precision for `d', 'o', 'x' and 'b' is\n minimum number of digits               <------>\n sprintf("%20.8d", 123)  #=> "            00000123"\n sprintf("%20.8o", 123)  #=> "            00000173"\n sprintf("%20.8x", 123)  #=> "            0000007b"\n sprintf("%20.8b", 123)  #=> "            01111011"\n sprintf("%20.8d", -123) #=> "           -00000123"\n sprintf("%20.8o", -123) #=> "            ..777605"\n sprintf("%20.8x", -123) #=> "            ..ffff85"\n sprintf("%20.8b", -11)  #=> "            ..110101"\n "0x" and "0b" for `#x' and `#b' is not counted for\n precision but "0" for `#o' is counted.  <------>\n sprintf("%#20.8d", 123)  #=> "            00000123"\n sprintf("%#20.8o", 123)  #=> "            00000173"\n sprintf("%#20.8x", 123)  #=> "          0x0000007b"\n sprintf("%#20.8b", 123)  #=> "          0b01111011"\n sprintf("%#20.8d", -123) #=> "           -00000123"\n sprintf("%#20.8o", -123) #=> "            ..777605"\n sprintf("%#20.8x", -123) #=> "          0x..ffff85"\n sprintf("%#20.8b", -11)  #=> "          0b..110101"\n precision for `e' is number of\n digits after the decimal point           <------>\n sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"\n precision for `f' is number of\n digits after the decimal point               <------>\n sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"\n precision for `g' is number of\n significant digits                          <------->\n sprintf("%20.8g", 1234.56789) #=> "           1234.5679"\n                                         <------->\n sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"\n precision for `s' is\n maximum number of characters                    <------>\n sprintf("%20.8s", "string test") #=> "            string t"\n\nExamples:\n\n   sprintf("%d %04x", 123, 123)               #=> "123 007b"\n   sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"\n   sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"\n   sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"\n   sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"\n   sprintf("%u", -123)                        #=> "-123"\n\nFor more complex formatting, Ruby supports a reference by name.\n%<name>s style uses format style, but %{name} style doesn't.\n\nExapmles:\n  sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })\n=> 1 : 2.000000\n  sprintf("%{foo}f", { :foo => 1 })\n => "1f"\n
gets Kernel.gets(...)\nReturns (and assigns to `$_`) the next line from the list\nof files in +ARGV+ (or `$*`), or from standard input if\nno files are present on the command line. Returns +nil+ at end of\nfile. The optional argument specifies the record separator. The\nseparator is included with the contents of each record. A separator\nof +nil+ reads the entire contents, and a zero-length separator\nreads the input one paragraph at a time, where paragraphs are\ndivided by two consecutive newlines.  If the first argument is an\ninteger, or optional second argument is given, the returning string\nwould not be longer than the given value in bytes.  If multiple\nfilenames are present in +ARGV+, +gets(nil)+ will read the contents\none file at a time.\n\n   ARGV << "testfile"\n   print while gets\n\n<em>produces:</em>\n\n   This is line one\n   This is line two\n   This is line three\n   And so on...\n\nThe style of programming using `$_` as an implicit\nparameter is gradually losing favor in the Ruby community.\n
global_variables Kernel.global_variables()\nReturns an array of the names of global variables.\n\n   global_variables.grep /std/   #=> [:$stdin, :$stdout, :$stderr]\n
gsub Kernel.gsub(...)\nEquivalent to `$_.gsub...`, except that `$_`\nreceives the modified result.\nAvailable only when -p/-n command line option specified.\n
iterator? Kernel.iterator?()\nReturns `true` if `yield` would execute a\nblock in the current context. The `iterator?` form\nis mildly deprecated.\n\n   def try\n     if block_given?\n       yield\n     else\n       "no block"\n     end\n   end\n   try                  #=> "no block"\n   try { "hello" }      #=> "hello"\n   try do "hello" end   #=> "hello"\n
lambda Kernel.lambda()\nEquivalent to `Proc.new`, except the resulting Proc objects\ncheck the number of parameters passed when called.\n
load Kernel.load(...)\nLoads and executes the Ruby\nprogram in the file _filename_. If the filename does not\nresolve to an absolute path, the file is searched for in the library\ndirectories listed in `$:`. If the optional _wrap_\nparameter is +true+, the loaded script will be executed\nunder an anonymous module, protecting the calling program's global\nnamespace. In no circumstance will any local variables in the loaded\nfile be propagated to the loading environment.\n
local_variables Kernel.local_variables()\nReturns the names of the current local variables.\n\n   fred = 1\n   for i in 1..10\n ...\n   end\n   local_variables   #=> [:fred, :i]\n
loop Kernel.loop()\nRepeatedly executes the block.\n\nIf no block is given, an enumerator is returned instead.\n\n   loop do\n     print "Input: "\n     line = gets\n     break if !line or line =~ /^qQ/\n ...\n   end\n\nStopIteration raised in the block breaks the loop.\n
open Kernel.open(...)\nCreates an `IO` object connected to the given stream,\nfile, or subprocess.\n\nIf <i>path</i> does not start with a pipe character\n(```|`''), treat it as the name of a file to open using\nthe specified mode (defaulting to ```r`'').\n\nThe mode_enc is\neither a string or an integer.  If it is an integer, it must be\nbitwise-or of open(2) flags, such as File::RDWR or File::EXCL.\nIf it is a string, it is either "mode", "mode:ext_enc", or\n"mode:ext_enc:int_enc".\nThe mode is one of the following:\n\n r: read (default)\n w: write\n a: append\n\nThe mode can be followed by "b" (means binary-mode), or "+"\n(means both reading and writing allowed) or both.\nIf ext_enc (external encoding) is specified,\nread string will be tagged by the encoding in reading,\nand output string will be converted\nto the specified encoding in writing.\nIf ext_enc starts with 'BOM|', check whether the input has a BOM. If\nthere is a BOM, strip it and set external encoding as\nwhat the BOM tells. If there is no BOM, use ext_enc without 'BOM|'.\nIf two encoding names,\next_enc and int_enc (external encoding and internal encoding),\nare specified, the read string is converted from ext_enc\nto int_enc then tagged with the int_enc in read mode,\nand in write mode, the output string will be\nconverted from int_enc to ext_enc before writing.\n\nIf a file is being created, its initial permissions may be\nset using the integer third parameter.\n\nIf a block is specified, it will be invoked with the\n`File` object as a parameter, and the file will be\nautomatically closed when the block terminates. The call\nreturns the value of the block.\n\nIf <i>path</i> starts with a pipe character, a subprocess is\ncreated, connected to the caller by a pair of pipes. The returned\n`IO` object may be used to write to the standard input\nand read from the standard output of this subprocess. If the command\nfollowing the ```|`'' is a single minus sign, Ruby forks,\nand this subprocess is connected to the parent. In the subprocess,\nthe `open` call returns `nil`. If the command\nis not ```-`'', the subprocess runs the command. If a\nblock is associated with an `open("|-")` call, that block\nwill be run twice---once in the parent and once in the child. The\nblock parameter will be an `IO` object in the parent and\n`nil` in the child. The parent's `IO` object\nwill be connected to the child's `$stdin` and\n`$stdout`. The subprocess will be terminated at the end\nof the block.\n\n   open("testfile") do |f|\n     print f.gets\n   end\n\n<em>produces:</em>\n\n   This is line one\n\nOpen a subprocess and read its output:\n\n   cmd = open("|date")\n   print cmd.gets\n   cmd.close\n\n<em>produces:</em>\n\n   Wed Apr  9 08:56:31 CDT 2003\n\nOpen a subprocess running the same Ruby program:\n\n   f = open("|-", "w+")\n   if f == nil\n     puts "in Child"\n     exit\n   else\n     puts "Got: #{f.gets}"\n   end\n\n<em>produces:</em>\n\n   Got: in Child\n\nOpen a subprocess using a block to receive the I/O object:\n\n   open("|-") do |f|\n     if f == nil\n       puts "in Child"\n     else\n       puts "Got: #{f.gets}"\n     end\n   end\n\n<em>produces:</em>\n\n   Got: in Child\n
p Kernel.p(...)\nFor each object, directly writes\n_obj_.+inspect+ followed by the current output\nrecord separator to the program's standard output.\n\n   S = Struct.new(:name, :state)\n   s = S['dave', 'TX']\n   p s\n\n<em>produces:</em>\n<S name="dave", state="TX">\n
print Kernel.print(...)\nPrints each object in turn to `$stdout`. If the output\nfield separator (`$,`) is not +nil+, its\ncontents will appear between each field. If the output record\nseparator (`$\\`) is not +nil+, it will be\nappended to the output. If no arguments are given, prints\n`$_`. Objects that aren't strings will be converted by\ncalling their `to_s` method.\n\n   print "cat", [1,2,3], 99, "\\n"\n   $, = ", "\n   $\ = "\\n"\n   print "cat", [1,2,3], 99\n\n<em>produces:</em>\n\n   cat12399\n   cat, 1, 2, 3, 99\n
printf Kernel.printf(...)\nEquivalent to:\n   io.write(sprintf(string, obj, ...)\nor\n   $stdout.write(sprintf(string, obj, ...)\n
proc Kernel.proc()\nEquivalent to `Proc.new`.\n
putc Kernel.putc(p1)\n\n Equivalent to:\n\n   $stdout.putc(int)\n\nRefer to the documentation for IO#putc for important information regarding\nmulti-byte characters.\n
puts Kernel.puts(...)\nEquivalent to\n\n    $stdout.puts(obj, ...)\n
raise Kernel.raise(...)\nWith no arguments, raises the exception in `$!` or raises\na `RuntimeError` if `$!` is +nil+.\nWith a single +String+ argument, raises a\n+RuntimeError+ with the string as a message. Otherwise,\nthe first parameter should be the name of an +Exception+\nclass (or an object that returns an +Exception+ object when sent\nan +exception+ message). The optional second parameter sets the\nmessage associated with the exception, and the third parameter is an\narray of callback information. Exceptions are caught by the\n+rescue+ clause of `begin...end` blocks.\n\n   raise "Failed to create socket"\n   raise ArgumentError, "No parameters", caller\n
rand Kernel.rand(...)\nConverts <i>max</i> to an integer using max1 =\nmax`.to_i.abs`. If _max_ is +nil+ the result is zero, returns a\npseudorandom floating point number greater than or equal to 0.0 and\nless than 1.0. Otherwise, returns a pseudorandom integer greater\nthan or equal to zero and less than max1. `Kernel::srand`\nmay be used to ensure repeatable sequences of random numbers between\ndifferent runs of the program. Ruby currently uses a modified\nMersenne Twister with a period of 2**19937-1.\n\n   srand 1234                 #=> 0\n   [ rand,  rand ]            #=> [0.191519450163469, 0.49766366626136]\n   [ rand(10), rand(1000) ]   #=> [6, 817]\n   srand 1234                 #=> 1234\n   [ rand,  rand ]            #=> [0.191519450163469, 0.49766366626136]\n
readline Kernel.readline(...)\nEquivalent to `Kernel::gets`, except\n+readline+ raises +EOFError+ at end of file.\n
readlines Kernel.readlines(...)\nReturns an array containing the lines returned by calling\n`Kernel.gets(<i>sep</i>)` until the end of file.\n
require Kernel.require(p1)\nRuby tries to load the library named _string_, returning\n+true+ if successful. If the filename does not resolve to\nan absolute path, it will be searched for in the directories listed\nin `$:`. If the file has the extension ``.rb'', it is\nloaded as a source file; if the extension is ``.so'', ``.o'', or\n``.dll'', or whatever the default shared library extension is on\nthe current platform, Ruby loads the shared library as a Ruby\nextension. Otherwise, Ruby tries adding ``.rb'', ``.so'', and so on\nto the name. The name of the loaded feature is added to the array in\n`$"`. A feature will not be loaded if its name already\nappears in `$"`. The file name is converted to an absolute\npath, so ```require 'a'; require './a'`'' will not load\n`a.rb` twice.\n\n   require "my-library.rb"\n   require "db-driver"\n
select Kernel.select(...)\nSee `Kernel#select`.\n
set_trace_func Kernel.set_trace_func(p1)\nEstablishes _proc_ as the handler for tracing, or disables\ntracing if the parameter is +nil+. _proc_ takes up\nto six parameters: an event name, a filename, a line number, an\nobject id, a binding, and the name of a class. _proc_ is\ninvoked whenever an event occurs. Events are: `c-call`\n(call a C-language routine), `c-return` (return from a\nC-language routine), `call` (call a Ruby method),\n`class` (start a class or module definition),\n`end` (finish a class or module definition),\n`line` (execute code on a new line), `raise`\n(raise an exception), and `return` (return from a Ruby\nmethod). Tracing is disabled within the context of _proc_.\n\n    class Test\n    def test\n      a = 1\n      b = 2\n    end\n    end\n\n    set_trace_func proc { |event, file, line, id, binding, classname|\n       printf "%8s %s:%-2d %10s %8s\\n", event, file, line, id, classname\n    }\n    t = Test.new\n    t.test\n\n      line prog.rb:11               false\n    c-call prog.rb:11        new    Class\n    c-call prog.rb:11 initialize   Object\n  c-return prog.rb:11 initialize   Object\n  c-return prog.rb:11        new    Class\n      line prog.rb:12               false\n      call prog.rb:2        test     Test\n      line prog.rb:3        test     Test\n      line prog.rb:4        test     Test\n    return prog.rb:4        test     Test\n
sleep Kernel.sleep(...)\nSuspends the current thread for _duration_ seconds (which may be any number,\nincluding a +Float+ with fractional seconds). Returns the actual number of\nseconds slept (rounded), which may be less than that asked for if another\nthread calls `Thread#run`. Called without an argument, sleep()\nwill sleep forever.\n\n   Time.new    #=> 2008-03-08 19:56:19 +0900\n   sleep 1.2   #=> 1\n   Time.new    #=> 2008-03-08 19:56:20 +0900\n   sleep 1.9   #=> 2\n   Time.new    #=> 2008-03-08 19:56:22 +0900\n
spawn Kernel.spawn(...)\nspawn executes specified command and return its pid.\n\nThis method doesn't wait for end of the command.\nThe parent process should\nuse `Process.wait` to collect\nthe termination status of its child or\nuse `Process.detach` to register\ndisinterest in their status;\notherwise, the operating system may accumulate zombie processes.\n\nspawn has bunch of options to specify process attributes:\n\n  env: hash\n    name => val : set the environment variable\n    name => nil : unset the environment variable\n  command...:\n    commandline                 : command line string which is passed to\n    the standard shell\n    cmdname, arg1, ...          : command name and one or more arguments\n    (no shell)\n    [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more\n    arguments (no shell)\n  options: hash\n    clearing environment variables:\n      :unsetenv_others => true   : clear environment variables except\n      specified by env\n      :unsetenv_others => false  : don't clear (default)\n    process group:\n      :pgroup => true or 0 : make a new process group\n      :pgroup => pgid      : join to specified process group\n      :pgroup => nil       : don't change the process group (default)\n    resource limit: resourcename is core, cpu, data, etc.  See\n    Process.setrlimit.\n      :rlimit_resourcename => limit\n      :rlimit_resourcename => [cur_limit, max_limit]\n    current directory:\n      :chdir => str\n    umask:\n      :umask => int\n    redirection:\n      key:\n        FD              : single file descriptor in child process\n        [FD, FD, ...]   : multiple file descriptor in child process\n      value:\n        FD                        : redirect to the file descriptor in\n        parent process\n        string                    : redirect to file with open(string,\n        "r" or "w")\n        [string]                  : redirect to file with open(string,\n        File::RDONLY)\n        [string, open_mode]       : redirect to file with open(string,\n        open_mode, 0644)\n        [string, open_mode, perm] : redirect to file with open(string,\n        open_mode, perm)\n        [:child, FD]              : redirect to the redirected file descriptor\n        :close                    : close the file descriptor in child process\n      FD is one of follows\n        :in     : the file descriptor 0 which is the standard input\n        :out    : the file descriptor 1 which is the standard output\n        :err    : the file descriptor 2 which is the standard error\n        integer : the file descriptor of specified the integer\n        io      : the file descriptor specified as io.fileno\n    file descriptor inheritance: close non-redirected non-standard fds (3,\n    4, 5, ...) or not\n      :close_others => false : inherit fds (default for system and exec)\n      :close_others => true  : don't inherit (default for spawn and IO.popen)\n\nIf a hash is given as +env+, the environment is\nupdated by +env+ before `exec(2)` in the child process.\nIf a pair in +env+ has nil as the value, the variable is deleted.\n set FOO as BAR and unset BAZ.\n  pid = spawn({"FOO"=>"BAR", "BAZ"=>nil}, command)\n\nIf a hash is given as +options+,\nit specifies\nprocess group,\nresource limit,\ncurrent directory,\numask and\nredirects for the child process.\nAlso, it can be specified to clear environment variables.\n\nThe `:unsetenv_others` key in +options+ specifies\nto clear environment variables, other than specified by +env+.\n\n  pid = spawn(command, :unsetenv_others=>true) # no environment variable\n  pid = spawn({"FOO"=>"BAR"}, command, :unsetenv_others=>true) # FOO only\n\nThe `:pgroup` key in +options+ specifies a process group.\nThe corresponding value should be true, zero or positive integer.\ntrue and zero means the process should be a process leader of a new\nprocess group.\nOther values specifies a process group to be belongs.\n\n  pid = spawn(command, :pgroup=>true) # process leader\n  pid = spawn(command, :pgroup=>10) # belongs to the process group 10\n\nThe `:rlimit_`<em>foo</em> key specifies a resource limit.\n<em>foo</em> should be one of resource types such as `core`.\nThe corresponding value should be an integer or an array which have one or\ntwo integers: same as cur_limit and max_limit arguments for\nProcess.setrlimit.\n\n  cur, max = Process.getrlimit(:CORE)\n  pid = spawn(command, :rlimit_core=>[0,max]) # disable core temporary.\n  pid = spawn(command, :rlimit_core=>max) # enable core dump\n  pid = spawn(command, :rlimit_core=>0) # never dump core.\n\nThe `:chdir` key in +options+ specifies the current directory.\n\n  pid = spawn(command, :chdir=>"/var/tmp")\n\nThe `:umask` key in +options+ specifies the umask.\n\n  pid = spawn(command, :umask=>077)\n\nThe :in, :out, :err, a fixnum, an IO and an array key specifies a redirection.\nThe redirection maps a file descriptor in the child process.\n\nFor example, stderr can be merged into stdout as follows:\n\n  pid = spawn(command, :err=>:out)\n  pid = spawn(command, 2=>1)\n  pid = spawn(command, STDERR=>:out)\n  pid = spawn(command, STDERR=>STDOUT)\n\nThe hash keys specifies a file descriptor\nin the child process started by `spawn`.\n:err, 2 and STDERR specifies the standard error stream (stderr).\n\nThe hash values specifies a file descriptor\nin the parent process which invokes `spawn`.\n:out, 1 and STDOUT specifies the standard output stream (stdout).\n\nIn the above example,\nthe standard output in the child process is not specified.\nSo it is inherited from the parent process.\n\nThe standard input stream (stdin) can be specified by :in, 0 and STDIN.\n\nA filename can be specified as a hash value.\n\n  pid = spawn(command, :in=>"/dev/null") # read mode\n  pid = spawn(command, :out=>"/dev/null") # write mode\n  pid = spawn(command, :err=>"log") # write mode\n  pid = spawn(command, 3=>"/dev/null") # read mode\n\nFor stdout and stderr,\nit is opened in write mode.\nOtherwise read mode is used.\n\nFor specifying flags and permission of file creation explicitly,\nan array is used instead.\n\n  pid = spawn(command, :in=>["file"]) # read mode is assumed\n  pid = spawn(command, :in=>["file", "r"])\n  pid = spawn(command, :out=>["log", "w"]) # 0644 assumed\n  pid = spawn(command, :out=>["log", "w", 0600])\n  pid = spawn(command, :out=>["log", File::WRONLY|File::EXCL|File::CREAT,\n  0600])\n\nThe array specifies a filename, flags and permission.\nThe flags can be a string or an integer.\nIf the flags is omitted or nil, File::RDONLY is assumed.\nThe permission should be an integer.\nIf the permission is omitted or nil, 0644 is assumed.\n\nIf an array of IOs and integers are specified as a hash key,\nall the elements are redirected.\n stdout and stderr is redirected to log file.\n The file "log" is opened just once.\n  pid = spawn(command, [:out, :err]=>["log", "w"])\n\nAnother way to merge multiple file descriptors is [:child, fd].\n\[:child, fd] means the file descriptor in the child process.\nThis is different from fd.\nFor example, :err=>:out means redirecting child stderr to parent stdout.\nBut :err=>[:child, :out] means redirecting child stderr to child stdout.\nThey differs if stdout is redirected in the child process as follows.\n stdout and stderr is redirected to log file.\n The file "log" is opened just once.\n  pid = spawn(command, :out=>["log", "w"], :err=>[:child, :out])\n\n\[:child, :out] can be used to merge stderr into stdout in IO.popen.\nIn this case, IO.popen redirects stdout to a pipe in the child process\nand [:child, :out] refers the redirected stdout.\n\n  io = IO.popen(["sh", "-c", "echo out; echo err >&2", :err=>[:child, :out]])\n  p io.read #=> "out\\nerr\\n"\n\nspawn closes all non-standard unspecified descriptors by default.\nThe "standard" descriptors are 0, 1 and 2.\nThis behavior is specified by :close_others option.\n:close_others doesn't affect the standard descriptors which are\nclosed only if :close is specified explicitly.\n\n  pid = spawn(command, :close_others=>true)  # close 3,4,5,... (default)\n  pid = spawn(command, :close_others=>false) # don't close 3,4,5,...\n\n:close_others is true by default for spawn and IO.popen.\n\nSo IO.pipe and spawn can be used as IO.popen.\n similar to r = IO.popen(command)\n  r, w = IO.pipe\n  pid = spawn(command, :out=>w)   # r, w is closed in the child process.\n  w.close\n\n:close is specified as a hash value to close a fd individually.\n\n  f = open(foo)\n  system(command, f=>:close)        # don't inherit f.\n\nIf a file descriptor need to be inherited,\nio=>io can be used.\n valgrind has --log-fd option for log destination.\n log_w=>log_w indicates log_w.fileno inherits to child process.\n  log_r, log_w = IO.pipe\n  pid = spawn("valgrind", "--log-fd=#{log_w.fileno}", "echo", "a",\n  log_w=>log_w)\n  log_w.close\n  p log_r.read\n\nIt is also possible to exchange file descriptors.\n\n  pid = spawn(command, :out=>:err, :err=>:out)\n\nThe hash keys specify file descriptors in the child process.\nThe hash values specifies file descriptors in the parent process.\nSo the above specifies exchanging stdout and stderr.\nInternally, +spawn+ uses an extra file descriptor to resolve such cyclic\nfile descriptor mapping.\n\nSee `Kernel.exec` for the standard shell.\n
sprintf Kernel.sprintf(...)\nReturns the string resulting from applying <i>format_string</i> to\nany additional arguments.  Within the format string, any characters\nother than format sequences are copied to the result.\n\nThe syntax of a format sequence is follows.\n\n  %[flags][width][.precision]type\n\nA format\nsequence consists of a percent sign, followed by optional flags,\nwidth, and precision indicators, then terminated with a field type\ncharacter.  The field type controls how the corresponding\n`sprintf` argument is to be interpreted, while the flags\nmodify that interpretation.\n\nThe field type characters are:\n\n    Field |  Integer Format\n    ------+--------------------------------------------------------------\n      b   | Convert argument as a binary number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..1'.\n      B   | Equivalent to `b', but uses an uppercase 0B for prefix\n          | in the alternative format by #.\n      d   | Convert argument as a decimal number.\n      i   | Identical to `d'.\n      o   | Convert argument as an octal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..7'.\n      u   | Identical to `d'.\n      x   | Convert argument as a hexadecimal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..f' (representing an infinite string of\n          | leading 'ff's).\n      X   | Equivalent to `x', but uses uppercase letters.\n\n    Field |  Float Format\n    ------+--------------------------------------------------------------\n      e   | Convert floating point argument into exponential notation\n          | with one digit before the decimal point as [-]d.dddddde[+-]dd.\n          | The precision specifies the number of digits after the decimal\n          | point (defaulting to six).\n      E   | Equivalent to `e', but uses an uppercase E to indicate\n          | the exponent.\n      f   | Convert floating point argument as [-]ddd.dddddd,\n          | where the precision specifies the number of digits after\n          | the decimal point.\n      g   | Convert a floating point number using exponential form\n          | if the exponent is less than -4 or greater than or\n          | equal to the precision, or in dd.dddd form otherwise.\n          | The precision specifies the number of significant digits.\n      G   | Equivalent to `g', but use an uppercase `E' in exponent form.\n      a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,\n          | which is consisted from optional sign, "0x", fraction part\n          | as hexadecimal, "p", and exponential part as decimal.\n      A   | Equivalent to `a', but use uppercase `X' and `P'.\n\n    Field |  Other Format\n    ------+--------------------------------------------------------------\n      c   | Argument is the numeric code for a single character or\n          | a single character string itself.\n      p   | The valuing of argument.inspect.\n      s   | Argument is a string to be substituted.  If the format\n          | sequence contains a precision, at most that many characters\n          | will be copied.\n      %   | A percent sign itself will be displayed.  No argument taken.\n\nThe flags modifies the behavior of the formats.\nThe flag characters are:\n\n  Flag     | Applies to    | Meaning\n  ---------+---------------+-----------------------------------------\n  space    | bBdiouxX      | Leave a space at the start of\n           | aAeEfgG       | non-negative numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  (digit)$ | all           | Specifies the absolute argument number\n           |               | for this field.  Absolute and relative\n           |               | argument numbers cannot be mixed in a\n           |               | sprintf string.\n  ---------+---------------+-----------------------------------------\n       | bBoxX         | Use an alternative format.\n           | aAeEfgG       | For the conversions `o', increase the precision\n           |               | until the first digit will be `0' if\n           |               | it is not formatted as complements.\n           |               | For the conversions `x', `X', `b' and `B'\n           |               | on non-zero, prefix the result with ``0x'',\n           |               | ``0X'', ``0b'' and ``0B'', respectively.\n           |               | For `a', `A', `e', `E', `f', `g', and 'G',\n           |               | force a decimal point to be added,\n           |               | even if no digits follow.\n           |               | For `g' and 'G', do not remove trailing zeros.\n  ---------+---------------+-----------------------------------------\n  +        | bBdiouxX      | Add a leading plus sign to non-negative\n           | aAeEfgG       | numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  -        | all           | Left-justify the result of this conversion.\n  ---------+---------------+-----------------------------------------\n  0 (zero) | bBdiouxX      | Pad with zeros, not spaces.\n           | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1\n           | (numeric fmt) | is used for negative numbers formatted as\n           |               | complements.\n  ---------+---------------+-----------------------------------------\n  *        | all           | Use the next argument as the field width.\n           |               | If negative, left-justify the result. If the\n           |               | asterisk is followed by a number and a dollar\n           |               | sign, use the indicated argument as the width.\n\nExamples of flags:\n `+' and space flag specifies the sign of non-negative numbers.\n sprintf("%d", 123)  #=> "123"\n sprintf("%+d", 123) #=> "+123"\n sprintf("% d", 123) #=> " 123"\n `#' flag for `o' increases number of digits to show `0'.\n `+' and space flag changes format of negative numbers.\n sprintf("%o", 123)   #=> "173"\n sprintf("%#o", 123)  #=> "0173"\n sprintf("%+o", -123) #=> "-173"\n sprintf("%o", -123)  #=> "..7605"\n sprintf("%#o", -123) #=> "..7605"\n `#' flag for `x' add a prefix `0x' for non-zero numbers.\n `+' and space flag disables complements for negative numbers.\n sprintf("%x", 123)   #=> "7b"\n sprintf("%#x", 123)  #=> "0x7b"\n sprintf("%+x", -123) #=> "-7b"\n sprintf("%x", -123)  #=> "..f85"\n sprintf("%#x", -123) #=> "0x..f85"\n sprintf("%#x", 0)    #=> "0"\n `#' for `X' uses the prefix `0X'.\n sprintf("%X", 123)  #=> "7B"\n sprintf("%#X", 123) #=> "0X7B"\n `#' flag for `b' add a prefix `0b' for non-zero numbers.\n `+' and space flag disables complements for negative numbers.\n sprintf("%b", 123)   #=> "1111011"\n sprintf("%#b", 123)  #=> "0b1111011"\n sprintf("%+b", -123) #=> "-1111011"\n sprintf("%b", -123)  #=> "..10000101"\n sprintf("%#b", -123) #=> "0b..10000101"\n sprintf("%#b", 0)    #=> "0"\n `#' for `B' uses the prefix `0B'.\n sprintf("%B", 123)  #=> "1111011"\n sprintf("%#B", 123) #=> "0B1111011"\n `#' for `e' forces to show the decimal point.\n sprintf("%.0e", 1)  #=> "1e+00"\n sprintf("%#.0e", 1) #=> "1.e+00"\n `#' for `f' forces to show the decimal point.\n sprintf("%.0f", 1234)  #=> "1234"\n sprintf("%#.0f", 1234) #=> "1234."\n `#' for `g' forces to show the decimal point.\n It also disables stripping lowest zeros.\n sprintf("%g", 123.4)   #=> "123.4"\n sprintf("%#g", 123.4)  #=> "123.400"\n sprintf("%g", 123456)  #=> "123456"\n sprintf("%#g", 123456) #=> "123456."\n\nThe field width is an optional integer, followed optionally by a\nperiod and a precision.  The width specifies the minimum number of\ncharacters that will be written to the result for this field.\n\nExamples of width:\n padding is done by spaces,       width=20\n 0 or radix-1.             <------------------>\n sprintf("%20d", 123)   #=> "                 123"\n sprintf("%+20d", 123)  #=> "                +123"\n sprintf("%020d", 123)  #=> "00000000000000000123"\n sprintf("%+020d", 123) #=> "+0000000000000000123"\n sprintf("% 020d", 123) #=> " 0000000000000000123"\n sprintf("%-20d", 123)  #=> "123                 "\n sprintf("%-+20d", 123) #=> "+123                "\n sprintf("%- 20d", 123) #=> " 123                "\n sprintf("%020x", -123) #=> "..ffffffffffffffff85"\n\nFor\nnumeric fields, the precision controls the number of decimal places\ndisplayed.  For string fields, the precision determines the maximum\nnumber of characters to be copied from the string.  (Thus, the format\nsequence `%10.10s` will always contribute exactly ten\ncharacters to the result.)\n\nExamples of precisions:\n precision for `d', 'o', 'x' and 'b' is\n minimum number of digits               <------>\n sprintf("%20.8d", 123)  #=> "            00000123"\n sprintf("%20.8o", 123)  #=> "            00000173"\n sprintf("%20.8x", 123)  #=> "            0000007b"\n sprintf("%20.8b", 123)  #=> "            01111011"\n sprintf("%20.8d", -123) #=> "           -00000123"\n sprintf("%20.8o", -123) #=> "            ..777605"\n sprintf("%20.8x", -123) #=> "            ..ffff85"\n sprintf("%20.8b", -11)  #=> "            ..110101"\n "0x" and "0b" for `#x' and `#b' is not counted for\n precision but "0" for `#o' is counted.  <------>\n sprintf("%#20.8d", 123)  #=> "            00000123"\n sprintf("%#20.8o", 123)  #=> "            00000173"\n sprintf("%#20.8x", 123)  #=> "          0x0000007b"\n sprintf("%#20.8b", 123)  #=> "          0b01111011"\n sprintf("%#20.8d", -123) #=> "           -00000123"\n sprintf("%#20.8o", -123) #=> "            ..777605"\n sprintf("%#20.8x", -123) #=> "          0x..ffff85"\n sprintf("%#20.8b", -11)  #=> "          0b..110101"\n precision for `e' is number of\n digits after the decimal point           <------>\n sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"\n precision for `f' is number of\n digits after the decimal point               <------>\n sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"\n precision for `g' is number of\n significant digits                          <------->\n sprintf("%20.8g", 1234.56789) #=> "           1234.5679"\n                                         <------->\n sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"\n precision for `s' is\n maximum number of characters                    <------>\n sprintf("%20.8s", "string test") #=> "            string t"\n\nExamples:\n\n   sprintf("%d %04x", 123, 123)               #=> "123 007b"\n   sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"\n   sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"\n   sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"\n   sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"\n   sprintf("%u", -123)                        #=> "-123"\n\nFor more complex formatting, Ruby supports a reference by name.\n%<name>s style uses format style, but %{name} style doesn't.\n\nExapmles:\n  sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })\n=> 1 : 2.000000\n  sprintf("%{foo}f", { :foo => 1 })\n => "1f"\n
srand Kernel.srand(...)\nSeeds the pseudorandom number generator to the value of\n<i>number</i>. If <i>number</i> is omitted\nor zero, seeds the generator using a combination of the time, the\nprocess id, and a sequence number. (This is also the behavior if\n`Kernel::rand` is called without previously calling\n`srand`, but without the sequence.) By setting the seed\nto a known value, scripts can be made deterministic during testing.\nThe previous seed value is returned. Also see `Kernel::rand`.\n
sub Kernel.sub(...)\nEquivalent to `$_.sub(<i>args</i>)`, except that\n`$_` will be updated if substitution occurs.\nAvailable only when -p/-n command line option specified.\n
syscall Kernel.syscall(...)\nCalls the operating system function identified by _fixnum_,\npassing in the arguments, which must be either +String+\nobjects, or +Integer+ objects that ultimately fit within\na native +long+. Up to nine parameters may be passed (14\non the Atari-ST). The function identified by _fixnum_ is system\ndependent. On some Unix systems, the numbers may be obtained from a\nheader file called `syscall.h`.\n\n   syscall 4, 1, "hello\\n", 6   # '4' is write(2) on our box\n\n<em>produces:</em>\n\n   hello\n
system Kernel.system(...)\nExecutes _command..._ in a subshell.\n_command..._ is one of following forms.\n\n  commandline                 : command line string which is passed to the\n  standard shell\n  cmdname, arg1, ...          : command name and one or more arguments\n  (no shell)\n  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more\n  arguments (no shell)\n\nsystem returns +true+ if the command gives zero exit status,\n+false+ for non zero exit status.\nReturns +nil+ if command execution fails.\nAn error status is available in `$?`.\nThe arguments are processed in the same way as\nfor `Kernel.spawn`.\n\nThe hash arguments, env and options, are same as\n`exec` and `spawn`.\nSee `Kernel.spawn` for details.\n\n   system("echo *")\n   system("echo", "*")\n\n<em>produces:</em>\n\n   config.h main.rb\n   *\n\nSee `Kernel.exec` for the standard shell.\n
test Kernel.test(...)\n\n Uses the integer <i>aCmd</i> to perform various tests on\n <i>file1</i> (first table below) or on <i>file1</i> and\n <i>file2</i> (second table).\n\n File tests on a single file:\n\n   Test   Returns   Meaning\n   "A"  | Time    | Last access time for file1\n   "b"  | boolean | True if file1 is a block device\n   "c"  | boolean | True if file1 is a character device\n   "C"  | Time    | Last change time for file1\n   "d"  | boolean | True if file1 exists and is a directory\n   "e"  | boolean | True if file1 exists\n   "f"  | boolean | True if file1 exists and is a regular file\n   "g"  | boolean | True if file1 has the \CF{setgid} bit\n        |         | set (false under NT)\n   "G"  | boolean | True if file1 exists and has a group\n        |         | ownership equal to the caller's group\n   "k"  | boolean | True if file1 exists and has the sticky bit set\n   "l"  | boolean | True if file1 exists and is a symbolic link\n   "M"  | Time    | Last modification time for file1\n   "o"  | boolean | True if file1 exists and is owned by\n        |         | the caller's effective uid\n   "O"  | boolean | True if file1 exists and is owned by\n        |         | the caller's real uid\n   "p"  | boolean | True if file1 exists and is a fifo\n   "r"  | boolean | True if file1 is readable by the effective\n        |         | uid/gid of the caller\n   "R"  | boolean | True if file is readable by the real\n        |         | uid/gid of the caller\n   "s"  | int/nil | If file1 has nonzero size, return the size,\n        |         | otherwise return nil\n   "S"  | boolean | True if file1 exists and is a socket\n   "u"  | boolean | True if file1 has the setuid bit set\n   "w"  | boolean | True if file1 exists and is writable by\n        |         | the effective uid/gid\n   "W"  | boolean | True if file1 exists and is writable by\n        |         | the real uid/gid\n   "x"  | boolean | True if file1 exists and is executable by\n        |         | the effective uid/gid\n   "X"  | boolean | True if file1 exists and is executable by\n        |         | the real uid/gid\n   "z"  | boolean | True if file1 exists and has a zero length\n\nTests that take two files:\n\n   "-"  | boolean | True if file1 and file2 are identical\n   "="  | boolean | True if the modification times of file1\n        |         | and file2 are equal\n   "<"  | boolean | True if the modification time of file1\n        |         | is prior to that of file2\n   ">"  | boolean | True if the modification time of file1\n        |         | is after that of file2\n
throw Kernel.throw(...)\nTransfers control to the end of the active +catch+ block\nwaiting for _tag_. Raises +ArgumentError+ if there\nis no +catch+ block for the _tag_. The optional second\nparameter supplies a return value for the +catch+ block,\nwhich otherwise defaults to +nil+. For examples, see\n`Kernel::catch`.\n
trace_var Kernel.trace_var(...)\nControls tracing of assignments to global variables. The parameter\n+symbol_ identifies the variable (as either a string name or a\nsymbol identifier). _cmd_ (which may be a string or a\n+Proc+ object) or block is executed whenever the variable\nis assigned. The block or +Proc+ object receives the\nvariable's new value as a parameter. Also see\n`Kernel::untrace_var`.\n\n   trace_var :$_, proc {|v| puts "$_ is now '#{v}'" }\n   $_ = "hello"\n   $_ = ' there'\n\n<em>produces:</em>\n\n   $_ is now 'hello'\n   $_ is now ' there'\n
trap Kernel.trap(...)\nSpecifies the handling of signals. The first parameter is a signal\nname (a string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a\nsignal number. The characters ``SIG'' may be omitted from the\nsignal name. The command or block specifies code to be run when the\nsignal is raised.\nIf the command is the string ``IGNORE'' or ``SIG_IGN'', the signal\nwill be ignored.\nIf the command is ``DEFAULT'' or ``SIG_DFL'', the Ruby's default handler\nwill be invoked.\nIf the command is ``EXIT'', the script will be terminated by the signal.\nIf the command is ``SYSTEM_DEFAULT'', the operating system's default\nhandler will be invoked.\nOtherwise, the given command or block will be run.\nThe special signal name ``EXIT'' or signal number zero will be\ninvoked just prior to program termination.\ntrap returns the previous handler for the given signal.\n\n    Signal.trap(0, proc { puts "Terminating: #{$$}" })\n    Signal.trap("CLD")  { puts "Child died" }\n    fork && Process.wait\n\nproduces:\n    Terminating: 27461\n    Child died\n    Terminating: 27460\n
untrace_var Kernel.untrace_var(...)\nRemoves tracing for the specified command on the given global\nvariable and returns +nil+. If no command is specified,\nremoves all tracing for that variable and returns an array\ncontaining the commands actually removed.\n
warn Kernel.warn(p1)\nDisplay the given message (followed by a newline) on STDERR unless\nwarnings are disabled (for example with the `-W0` flag).\n
all? Enumerable.all?()\nPasses each element of the collection to the given block. The method\nreturns `true` if the block never returns\n`false` or `nil`. If the block is not given,\nRuby adds an implicit block of `{|obj| obj}` (that is\n`all?` will return `true` only if none of the\ncollection members are `false` or `nil`.)\n\n   %w{ant bear cat}.all? {|word| word.length >= 3}   #=> true\n   %w{ant bear cat}.all? {|word| word.length >= 4}   #=> false\n   [ nil, true, 99 ].all?                            #=> false\n
any? Enumerable.any?()\nPasses each element of the collection to the given block. The method\nreturns `true` if the block ever returns a value other\nthan `false` or `nil`. If the block is not\ngiven, Ruby adds an implicit block of `{|obj| obj}` (that\nis `any?` will return `true` if at least one\nof the collection members is not `false` or\n`nil`.\n\n   %w{ant bear cat}.any? {|word| word.length >= 3}   #=> true\n   %w{ant bear cat}.any? {|word| word.length >= 4}   #=> true\n   [ nil, true, 99 ].any?                            #=> true\n
chunk Enumerable.chunk(...)\nCreates an enumerator for each chunked elements.\nThe consecutive elements which have same block value are chunked.\n\nThe result enumerator yields the block value and an array of chunked elements.\nSo "each" method can be called as follows.\n\n  enum.chunk {|elt| key }.each {|key, ary| ... }\n  enum.chunk(initial_state) {|elt, state| key }.each {|key, ary| ... }\n\nFor example, consecutive even numbers and odd numbers can be\nsplitted as follows.\n\n  [3,1,4,1,5,9,2,6,5,3,5].chunk {|n|\n    n.even?\n  }.each {|even, ary|\n    p [even, ary]\n  }\n=> [false, [3, 1]]\n   [true, [4]]\n   [false, [1, 5, 9]]\n   [true, [2, 6]]\n   [false, [5, 3, 5]]\n\nThis method is especially useful for sorted series of elements.\nThe following example counts words for each initial letter.\n\n  open("/usr/share/dict/words", "r:iso-8859-1") {|f|\n    f.chunk {|line| line.ord }.each {|ch, lines| p [ch.chr, lines.length] }\n  }\n=> ["\\n", 1]\n   ["A", 1327]\n   ["B", 1372]\n   ["C", 1507]\n   ["D", 791]\n   ...\n\nThe following key values has special meaning:\n- nil and :_separator specifies that the elements are dropped.\n- :_alone specifies that the element should be chunked as a singleton.\nOther symbols which begins an underscore are reserved.\n\nnil and :_separator can be used to ignore some elements.\nFor example, the sequence of hyphens in svn log can be eliminated as follows.\n\n  sep = "-"*72 + "\\n"\n  IO.popen("svn log README") {|f|\n    f.chunk {|line|\n      line != sep || nil\n    }.each {|_, lines|\n      pp lines\n    }\n  }\n=> ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\\n",\n    "\\n",\n    "* README, README.ja: Update the portability section.\\n",\n    "\\n"]\n   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\\n",\n    "\\n",\n    "* README, README.ja: Add a note about default C flags.\\n",\n    "\\n"]\n   ...\n\nparagraphs separated by empty lines can be parsed as follows.\n\n  File.foreach("README").chunk {|line|\n    /\A\s*\z/ !~ line || nil\n  }.each {|_, lines|\n    pp lines\n  }\n\n:_alone can be used to pass through bunch of elements.\nFor example, sort consecutive lines formed as Foo#bar and\npass other lines, chunk can be used as follows.\n\n  pat = /\A[A-Z][A-Za-z0-9_]+\#/\n  open(filename) {|f|\n    f.chunk {|line| pat =~ line ? $& : :_alone }.each {|key, lines|\n      if key != :_alone\n        print lines.sort.join('')\n      else\n        print lines.join('')\n      end\n    }\n  }\n\nIf the block needs to maintain state over multiple elements,\n_initial_state_ argument can be used.\nIf non-nil value is given,\nit is duplicated for each "each" method invocation of the enumerator.\nThe duplicated object is passed to 2nd argument of the block for "chunk"\nmethod.\n
collect Enumerable.collect()\nReturns a new array with the results of running <em>block</em> once\nfor every element in <i>enum</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..4).collect {|i| i*i }   #=> [1, 4, 9, 16]\n   (1..4).collect { "cat"  }   #=> ["cat", "cat", "cat", "cat"]\n
collect_concat Enumerable.collect_concat()\nReturns a new array with the concatenated results of running\n<em>block</em> once for every element in <i>enum</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   [[1,2],[3,4]].flat_map {|i| i }   #=> [1, 2, 3, 4]\n
count Enumerable.count(...)\nReturns the number of items in <i>enum</i>, where #size is called\nif it responds to it, otherwise the items are counted through\nenumeration.  If an argument is given, counts the number of items\nin <i>enum</i>, for which equals to <i>item</i>.  If a block is\ngiven, counts the number of elements yielding a true value.\n\n   ary = [1, 2, 4, 2]\n   ary.count             #=> 4\n   ary.count(2)          #=> 2\n   ary.count{|x|x%2==0}  #=> 3\n
cycle Enumerable.cycle(...)\nCalls <i>block</i> for each element of <i>enum</i> repeatedly _n_\ntimes or forever if none or +nil+ is given.  If a non-positive\nnumber is given or the collection is empty, does nothing.  Returns\n+nil+ if the loop has finished without getting interrupted.\n\nEnumerable#cycle saves elements in an internal array so changes\nto <i>enum</i> after the first pass have no effect.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = ["a", "b", "c"]\n   a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.\n   a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.\n
detect Enumerable.detect(...)\nPasses each entry in <i>enum</i> to <em>block</em>. Returns the\nfirst for which <em>block</em> is not false.  If no\nobject matches, calls <i>ifnone</i> and returns its result when it\nis specified, or returns `nil` otherwise.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=> nil\n   (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=> 35\n
drop Enumerable.drop(p1)\nDrops first n elements from <i>enum</i>, and returns rest elements\nin an array.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.drop(3)             #=> [4, 5, 0]\n
drop_while Enumerable.drop_while()\nDrops elements up to, but not including, the first element for\nwhich the block returns +nil+ or +false+ and returns an array\ncontaining the remaining elements.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.drop_while {|i| i < 3 }   #=> [3, 4, 5, 0]\n
each_cons Enumerable.each_cons(p1)\nIterates the given block for each array of consecutive <n>\nelements.  If no block is given, returns an enumerator.\n\ne.g.:\n    (1..10).each_cons(3) {|a| p a}\n outputs below\n    [1, 2, 3]\n    [2, 3, 4]\n    [3, 4, 5]\n    [4, 5, 6]\n    [5, 6, 7]\n    [6, 7, 8]\n    [7, 8, 9]\n    [8, 9, 10]\n
each_entry Enumerable.each_entry(...)\nCalls <i>block</i> once for each element in +self+, passing that\nelement as a parameter, converting multiple values from yield to an\narray.\n\nIf no block is given, an enumerator is returned instead.\n\n   class Foo\n     include Enumerable\n     def each\n       yield 1\n       yield 1,2\n     end\n   end\n   Foo.new.each_entry{|o| print o, " -- "}\n\nproduces:\n\n   1 -- [1, 2] --\n
each_slice Enumerable.each_slice(p1)\nIterates the given block for each slice of <n> elements.  If no\nblock is given, returns an enumerator.\n\ne.g.:\n    (1..10).each_slice(3) {|a| p a}\n outputs below\n    [1, 2, 3]\n    [4, 5, 6]\n    [7, 8, 9]\n    [10]\n
each_with_index Enumerable.each_with_index(...)\nCalls <em>block</em> with two arguments, the item and its index,\nfor each item in <i>enum</i>.  Given arguments are passed through\nto #each().\n\nIf no block is given, an enumerator is returned instead.\n\n   hash = Hash.new\n   %w(cat dog wombat).each_with_index {|item, index|\n     hash[item] = index\n   }\n   hash   #=> {"cat"=>0, "dog"=>1, "wombat"=>2}\n
each_with_object Enumerable.each_with_object(p1)\nIterates the given block for each element with an arbitrary\nobject given, and returns the initially given object.\n\nIf no block is given, returns an enumerator.\n\ne.g.:\n    evens = (1..10).each_with_object([]) {|i, a| a << i*2 }\n=> [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n
entries Enumerable.entries(...)\nReturns an array containing the items in <i>enum</i>.\n\n   (1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]\n   { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [["a", 1], ["b", 2], ["c", 3]]\n
find Enumerable.find(...)\nPasses each entry in <i>enum</i> to <em>block</em>. Returns the\nfirst for which <em>block</em> is not false.  If no\nobject matches, calls <i>ifnone</i> and returns its result when it\nis specified, or returns `nil` otherwise.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=> nil\n   (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=> 35\n
find_all Enumerable.find_all()\nReturns an array containing all elements of <i>enum</i> for which\n<em>block</em> is not `false` (see also\n`Enumerable#reject`).\n\nIf no block is given, an enumerator is returned instead.\n\n\n   (1..10).find_all {|i|  i % 3 == 0 }   #=> [3, 6, 9]\n
find_index Enumerable.find_index(...)\nCompares each entry in <i>enum</i> with <em>value</em> or passes\nto <em>block</em>.  Returns the index for the first for which the\nevaluated value is non-false.  If no object matches, returns\n`nil`\n\nIf neither block nor argument is given, an enumerator is returned instead.\n\n   (1..10).find_index  {|i| i % 5 == 0 and i % 7 == 0 }   #=> nil\n   (1..100).find_index {|i| i % 5 == 0 and i % 7 == 0 }   #=> 34\n   (1..100).find_index(50)                                #=> 49\n
first Enumerable.first(...)\nReturns the first element, or the first +n+ elements, of the enumerable.\nIf the enumerable is empty, the first form returns `nil`, and the\nsecond form returns an empty array.\n
flat_map Enumerable.flat_map()\nReturns a new array with the concatenated results of running\n<em>block</em> once for every element in <i>enum</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   [[1,2],[3,4]].flat_map {|i| i }   #=> [1, 2, 3, 4]\n
grep Enumerable.grep(p1)\nReturns an array of every element in <i>enum</i> for which\n`Pattern === element`. If the optional <em>block</em> is\nsupplied, each matching element is passed to it, and the block's\nresult is stored in the output array.\n\n   (1..100).grep 38..44   #=> [38, 39, 40, 41, 42, 43, 44]\n   c = IO.constants\n   c.grep(/SEEK/)         #=> [:SEEK_SET, :SEEK_CUR, :SEEK_END]\n   res = c.grep(/SEEK/) {|v| IO.const_get(v) }\n   res                    #=> [0, 1, 2]\n
group_by Enumerable.group_by()\nReturns a hash, which keys are evaluated result from the\nblock, and values are arrays of elements in <i>enum</i>\ncorresponding to the key.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..6).group_by {|i| i%3}   #=> {0=>[3, 6], 1=>[1, 4], 2=>[2, 5]}\n
include? Enumerable.include?(p1)\nReturns `true` if any member of <i>enum</i> equals\n<i>obj</i>. Equality is tested using `==`.\n\n   IO.constants.include? :SEEK_SET          #=> true\n   IO.constants.include? :SEEK_NO_FURTHER   #=> false\n
inject Enumerable.inject(...)\n   enum.reduce(initial, sym) -> obj\n   enum.reduce(sym)          -> obj\n   enum.reduce(initial) {| memo, obj | block }  -> obj\n   enum.reduce          {| memo, obj | block }  -> obj\n\nCombines all elements of <i>enum</i> by applying a binary\noperation, specified by a block or a symbol that names a\nmethod or operator.\n\nIf you specify a block, then for each element in <i>enum</i>\nthe block is passed an accumulator value (<i>memo</i>) and the element.\nIf you specify a symbol instead, then each element in the collection\nwill be passed to the named method of <i>memo</i>.\nIn either case, the result becomes the new value for <i>memo</i>.\nAt the end of the iteration, the final value of <i>memo</i> is the\nreturn value fo the method.\n\nIf you do not explicitly specify an <i>initial</i> value for <i>memo</i>,\nthen uses the first element of collection is used as the initial value\nof <i>memo</i>.\n\nExamples:\n Sum some numbers\n   (5..10).reduce(:+)                            #=> 45\n Same using a block and inject\n   (5..10).inject {|sum, n| sum + n }            #=> 45\n Multiply some numbers\n   (5..10).reduce(1, :*)                         #=> 151200\n Same using a block\n   (5..10).inject(1) {|product, n| product * n } #=> 151200\n find the longest word\n   longest = %w{ cat sheep bear }.inject do |memo,word|\n      memo.length > word.length ? memo : word\n   end\n   longest                                       #=> "sheep"\n
map Enumerable.map()\nReturns a new array with the results of running <em>block</em> once\nfor every element in <i>enum</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..4).collect {|i| i*i }   #=> [1, 4, 9, 16]\n   (1..4).collect { "cat"  }   #=> ["cat", "cat", "cat", "cat"]\n
max Enumerable.max()\nReturns the object in _enum_ with the maximum value. The\nfirst form assumes all objects implement `Comparable`;\nthe second uses the block to return <em>a <=> b</em>.\n\n   a = %w(albatross dog horse)\n   a.max                                  #=> "horse"\n   a.max {|a,b| a.length <=> b.length }   #=> "albatross"\n
max_by Enumerable.max_by()\nReturns the object in <i>enum</i> that gives the maximum\nvalue from the given block.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = %w(albatross dog horse)\n   a.max_by {|x| x.length }   #=> "albatross"\n
member? Enumerable.member?(p1)\nReturns `true` if any member of <i>enum</i> equals\n<i>obj</i>. Equality is tested using `==`.\n\n   IO.constants.include? :SEEK_SET          #=> true\n   IO.constants.include? :SEEK_NO_FURTHER   #=> false\n
min Enumerable.min()\nReturns the object in <i>enum</i> with the minimum value. The\nfirst form assumes all objects implement `Comparable`;\nthe second uses the block to return <em>a <=> b</em>.\n\n   a = %w(albatross dog horse)\n   a.min                                  #=> "albatross"\n   a.min {|a,b| a.length <=> b.length }   #=> "dog"\n
min_by Enumerable.min_by()\nReturns the object in <i>enum</i> that gives the minimum\nvalue from the given block.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = %w(albatross dog horse)\n   a.min_by {|x| x.length }   #=> "dog"\n
minmax Enumerable.minmax()\nReturns two elements array which contains the minimum and the\nmaximum value in the enumerable.  The first form assumes all\nobjects implement `Comparable`; the second uses the\nblock to return <em>a <=> b</em>.\n\n   a = %w(albatross dog horse)\n   a.minmax                                  #=> ["albatross", "horse"]\n   a.minmax {|a,b| a.length <=> b.length }   #=> ["dog", "albatross"]\n
minmax_by Enumerable.minmax_by()\nReturns two elements array array containing the objects in\n<i>enum</i> that gives the minimum and maximum values respectively\nfrom the given block.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = %w(albatross dog horse)\n   a.minmax_by {|x| x.length }   #=> ["dog", "albatross"]\n
none? Enumerable.none?()\nPasses each element of the collection to the given block. The method\nreturns `true` if the block never returns `true`\nfor all elements. If the block is not given, `none?` will return\n`true` only if none of the collection members is true.\n\n   %w{ant bear cat}.none? {|word| word.length == 5}  #=> true\n   %w{ant bear cat}.none? {|word| word.length >= 4}  #=> false\n   [].none?                                          #=> true\n   [nil].none?                                       #=> true\n   [nil,false].none?                                 #=> true\n
one? Enumerable.one?()\nPasses each element of the collection to the given block. The method\nreturns `true` if the block returns `true`\nexactly once. If the block is not given, `one?` will return\n`true` only if exactly one of the collection members is\ntrue.\n\n   %w{ant bear cat}.one? {|word| word.length == 4}   #=> true\n   %w{ant bear cat}.one? {|word| word.length > 4}    #=> false\n   %w{ant bear cat}.one? {|word| word.length < 4}    #=> false\n   [ nil, true, 99 ].one?                            #=> false\n   [ nil, true, false ].one?                         #=> true\n
partition Enumerable.partition()\nReturns two arrays, the first containing the elements of\n<i>enum</i> for which the block evaluates to true, the second\ncontaining the rest.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..6).partition {|i| (i&1).zero?}   #=> [[2, 4, 6], [1, 3, 5]]\n
reduce Enumerable.reduce(...)\n   enum.reduce(initial, sym) -> obj\n   enum.reduce(sym)          -> obj\n   enum.reduce(initial) {| memo, obj | block }  -> obj\n   enum.reduce          {| memo, obj | block }  -> obj\n\nCombines all elements of <i>enum</i> by applying a binary\noperation, specified by a block or a symbol that names a\nmethod or operator.\n\nIf you specify a block, then for each element in <i>enum</i>\nthe block is passed an accumulator value (<i>memo</i>) and the element.\nIf you specify a symbol instead, then each element in the collection\nwill be passed to the named method of <i>memo</i>.\nIn either case, the result becomes the new value for <i>memo</i>.\nAt the end of the iteration, the final value of <i>memo</i> is the\nreturn value fo the method.\n\nIf you do not explicitly specify an <i>initial</i> value for <i>memo</i>,\nthen uses the first element of collection is used as the initial value\nof <i>memo</i>.\n\nExamples:\n Sum some numbers\n   (5..10).reduce(:+)                            #=> 45\n Same using a block and inject\n   (5..10).inject {|sum, n| sum + n }            #=> 45\n Multiply some numbers\n   (5..10).reduce(1, :*)                         #=> 151200\n Same using a block\n   (5..10).inject(1) {|product, n| product * n } #=> 151200\n find the longest word\n   longest = %w{ cat sheep bear }.inject do |memo,word|\n      memo.length > word.length ? memo : word\n   end\n   longest                                       #=> "sheep"\n
reject Enumerable.reject()\nReturns an array for all elements of <i>enum</i> for which\n<em>block</em> is false (see also `Enumerable#find_all`).\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..10).reject {|i|  i % 3 == 0 }   #=> [1, 2, 4, 5, 7, 8, 10]\n
reverse_each Enumerable.reverse_each(...)\nBuilds a temporary array and traverses that array in reverse order.\n\nIf no block is given, an enumerator is returned instead.\n
select Enumerable.select()\nReturns an array containing all elements of <i>enum</i> for which\n<em>block</em> is not `false` (see also\n`Enumerable#reject`).\n\nIf no block is given, an enumerator is returned instead.\n\n\n   (1..10).find_all {|i|  i % 3 == 0 }   #=> [3, 6, 9]\n
slice_before Enumerable.slice_before(...)\n\n Creates an enumerator for each chunked elements.\n The beginnings of chunks are defined by _pattern_ and the block.\n If _pattern_ === _elt_ returns true or\n the block returns true for the element,\n the element is beginning of a chunk.\n\n The === and block is called from the first element to the last element\n of _enum_.\n The result for the first element is ignored.\n\n The result enumerator yields the chunked elements as an array for +each+\n method.\n +each+ method can be called as follows.\n\n   enum.slice_before(pattern).each {|ary| ... }\n   enum.slice_before {|elt| bool }.each {|ary| ... }\n   enum.slice_before(initial_state) {|elt, state| bool }.each {|ary| ... }\n\n Other methods of Enumerator class and Enumerable module,\n such as map, etc., are also usable.\n\n For example, iteration over ChangeLog entries can be implemented as\n follows.\n iterate over ChangeLog entries.\n   open("ChangeLog") {|f|\n     f.slice_before(/\A\S/).each {|e| pp e}\n   }\n same as above.  block is used instead of pattern argument.\n   open("ChangeLog") {|f|\n     f.slice_before {|line| /\A\S/ === line }.each {|e| pp e}\n   }\n\n"svn proplist -R" produces multiline output for each file.\nThey can be chunked as follows:\n\n   IO.popen([{"LC_ALL"=>"C"}, "svn", "proplist", "-R"]) {|f|\n     f.lines.slice_before(/\AProp/).each {|lines| p lines }\n   }\n=> ["Properties on '.':\\n", "  svn:ignore\\n", "  svk:merge\\n"]\n   ["Properties on 'goruby.c':\\n", "  svn:eol-style\\n"]\n   ["Properties on 'complex.c':\\n", "  svn:mime-type\\n", "\n   svn:eol-style\\n"]\n   ["Properties on 'regparse.c':\\n", "  svn:eol-style\\n"]\n   ...\n\n If the block needs to maintain state over multiple elements,\n local variables can be used.\n For example, three or more consecutive increasing numbers can be squashed\n as follows:\n\n   a = [0,2,3,4,6,7,9]\n   prev = a[0]\n   p a.slice_before {|e|\n     prev, prev2 = e, prev\n     prev2 + 1 != e\n   }.map {|es|\n     es.length <= 2 ? es.join(",") : "#{es.first}-#{es.last}"\n   }.join(",")\n=> "0,2-4,6,7,9"\n\n However local variables are not appropriate to maintain state\n if the result enumerator is used twice or more.\n In such case, the last state of the 1st +each+ is used in 2nd +each+.\n _initial_state_ argument can be used to avoid this problem.\n If non-nil value is given as _initial_state_,\n it is duplicated for each "each" method invocation of the enumerator.\n The duplicated object is passed to 2nd argument of the block for\n +slice_before+ method.\n word wrapping.\n this assumes all characters have same width.\n   def wordwrap(words, maxwidth)\n if cols is a local variable, 2nd "each" may start with non-zero cols.\n     words.slice_before(cols: 0) {|w, h|\n       h[:cols] += 1 if h[:cols] != 0\n       h[:cols] += w.length\n       if maxwidth < h[:cols]\n         h[:cols] = w.length\n         true\n       else\n         false\n       end\n     }\n   end\n   text = (1..20).to_a.join(" ")\n   enum = wordwrap(text.split(/\s+/), 10)\n   puts "-"*10\n   enum.each {|ws| puts ws.join(" ") }\n   puts "-"*10\n=> ----------\n   1 2 3 4 5\n   6 7 8 9 10\n   11 12 13\n   14 15 16\n   17 18 19\n   20\n   ----------\n\nmbox contains series of mails which start with Unix From line.\nSo each mail can be extracted by slice before Unix From line.\n parse mbox\n   open("mbox") {|f|\n     f.slice_before {|line|\n       line.start_with? "From "\n     }.each {|mail|\n       unix_from = mail.shift\n       i = mail.index("\\n")\n       header = mail[0...i]\n       body = mail[(i+1)..-1]\n       body.pop if body.last == "\\n"\n       fields = header.slice_before {|line| !" \t".include?(line[0]) }.to_a\n       p unix_from\n       pp fields\n       pp body\n     }\n   }\n split mails in mbox (slice before Unix From line after an empty line)\n   open("mbox") {|f|\n     f.slice_before(emp: true) {|line,h|\n       prevemp = h[:emp]\n       h[:emp] = line == "\\n"\n       prevemp && line.start_with?("From ")\n     }.each {|mail|\n       mail.pop if mail.last == "\\n"\n       pp mail\n     }\n   }\n
sort Enumerable.sort()\nReturns an array containing the items in <i>enum</i> sorted,\neither according to their own `<=>` method, or by using\nthe results of the supplied block. The block should return -1, 0, or\n+1 depending on the comparison between <i>a</i> and <i>b</i>. As of\nRuby 1.8, the method `Enumerable#sort_by` implements a\nbuilt-in Schwartzian Transform, useful when key computation or\ncomparison is expensive.\n\n   %w(rhea kea flea).sort         #=> ["flea", "kea", "rhea"]\n   (1..10).sort {|a,b| b <=> a}   #=> [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n
sort_by Enumerable.sort_by()\nSorts <i>enum</i> using a set of keys generated by mapping the\nvalues in <i>enum</i> through the given block.\n\nIf no block is given, an enumerator is returned instead.\n\n   %w{ apple pear fig }.sort_by {|word| word.length}\n=> ["fig", "pear", "apple"]\n\nThe current implementation of `sort_by` generates an\narray of tuples containing the original collection element and the\nmapped value. This makes `sort_by` fairly expensive when\nthe keysets are simple\n\n   require 'benchmark'\n\n   a = (1..100000).map {rand(100000)}\n\n   Benchmark.bm(10) do |b|\n     b.report("Sort")    { a.sort }\n     b.report("Sort by") { a.sort_by {|a| a} }\n   end\n\n<em>produces:</em>\n\n   user     system      total        real\n   Sort        0.180000   0.000000   0.180000 (  0.175469)\n   Sort by     1.980000   0.040000   2.020000 (  2.013586)\n\nHowever, consider the case where comparing the keys is a non-trivial\noperation. The following code sorts some files on modification time\nusing the basic `sort` method.\n\n   files = Dir["*"]\n   sorted = files.sort {|a,b| File.new(a).mtime <=> File.new(b).mtime}\n   sorted   #=> ["mon", "tues", "wed", "thurs"]\n\nThis sort is inefficient: it generates two new `File`\nobjects during every comparison. A slightly better technique is to\nuse the `Kernel#test` method to generate the modification\ntimes directly.\n\n   files = Dir["*"]\n   sorted = files.sort { |a,b|\n     test(?M, a) <=> test(?M, b)\n   }\n   sorted   #=> ["mon", "tues", "wed", "thurs"]\n\nThis still generates many unnecessary `Time` objects. A\nmore efficient technique is to cache the sort keys (modification\ntimes in this case) before the sort. Perl users often call this\napproach a Schwartzian Transform, after Randal Schwartz. We\nconstruct a temporary array, where each element is an array\ncontaining our sort key along with the filename. We sort this array,\nand then extract the filename from the result.\n\n   sorted = Dir["*"].collect { |f|\n      [test(?M, f), f]\n   }.sort.collect { |f| f[1] }\n   sorted   #=> ["mon", "tues", "wed", "thurs"]\n\nThis is exactly what `sort_by` does internally.\n\n   sorted = Dir["*"].sort_by {|f| test(?M, f)}\n   sorted   #=> ["mon", "tues", "wed", "thurs"]\n
take Enumerable.take(p1)\nReturns first n elements from <i>enum</i>.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.take(3)             #=> [1, 2, 3]\n
take_while Enumerable.take_while()\nPasses elements to the block until the block returns +nil+ or +false+,\nthen stops iterating and returns an array of all prior elements.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.take_while {|i| i < 3 }   #=> [1, 2]\n
to_a Enumerable.to_a(...)\nReturns an array containing the items in <i>enum</i>.\n\n   (1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]\n   { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [["a", 1], ["b", 2], ["c", 3]]\n
zip Enumerable.zip(...)\nTakes one element from <i>enum</i> and merges corresponding\nelements from each <i>args</i>.  This generates a sequence of\n<em>n</em>-element arrays, where <em>n</em> is one more than the\ncount of arguments.  The length of the resulting sequence will be\n`enum#size`.  If the size of any argument is less than\n`enum#size`, `nil` values are supplied. If\na block is given, it is invoked for each output array, otherwise\nan array of arrays is returned.\n\n   a = [ 4, 5, 6 ]\n   b = [ 7, 8, 9 ]\n\n   [1,2,3].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n   [1,2].zip(a,b)         #=> [[1, 4, 7], [2, 5, 8]]\n   a.zip([1,2],[8])       #=> [[4, 1, 8], [5, 2, nil], [6, nil, nil]]\n
blockdev? FileTest.blockdev?(p1)\nReturns `true` if the named file is a block device.\n
chardev? FileTest.chardev?(p1)\nReturns `true` if the named file is a character device.\n
directory? FileTest.directory?(p1)\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
executable? FileTest.executable?(p1)\nReturns `true` if the named file is executable by the effective\nuser id of this process.\n
executable_real? FileTest.executable_real?(p1)\nReturns `true` if the named file is executable by the real\nuser id of this process.\n
exist? FileTest.exist?(p1)\nReturns `true` if the named file is a directory,\n`false` otherwise.\n
exists? FileTest.exists?(p1)\nReturn `true` if the named file exists.\n
file? FileTest.file?(p1)\nReturns `true` if the named file exists and is a\nregular file.\n
grpowned? FileTest.grpowned?(p1)\nReturns `true` if the named file exists and the\neffective group id of the calling process is the owner of\nthe file. Returns `false` on Windows.\n
identical? FileTest.identical?(p1, p2)\nReturns `true` if the named files are identical.\n\n    open("a", "w") {}\n    p File.identical?("a", "a")      #=> true\n    p File.identical?("a", "./a")    #=> true\n    File.link("a", "b")\n    p File.identical?("a", "b")      #=> true\n    File.symlink("a", "c")\n    p File.identical?("a", "c")      #=> true\n    open("d", "w") {}\n    p File.identical?("a", "d")      #=> false\n
owned? FileTest.owned?(p1)\nReturns `true` if the named file exists and the\neffective used id of the calling process is the owner of\nthe file.\n
pipe? FileTest.pipe?(p1)\nReturns `true` if the named file is a pipe.\n
readable? FileTest.readable?(p1)\nReturns `true` if the named file is readable by the effective\nuser id of this process.\n
readable_real? FileTest.readable_real?(p1)\nReturns `true` if the named file is readable by the real\nuser id of this process.\n
setgid? FileTest.setgid?(p1)\nReturns `true` if the named file has the setgid bit set.\n
setuid? FileTest.setuid?(p1)\nReturns `true` if the named file has the setuid bit set.\n
size FileTest.size(p1)\nReturns the size of `file_name`.\n
size? FileTest.size?(p1)\nReturns +nil+ if +file_name+ doesn't exist or has zero size, the size of the\nfile otherwise.\n
socket? FileTest.socket?(p1)\nReturns `true` if the named file is a socket.\n
sticky? FileTest.sticky?(p1)\nReturns `true` if the named file has the sticky bit set.\n
symlink? FileTest.symlink?(p1)\nReturns `true` if the named file is a symbolic link.\n
world_readable? FileTest.world_readable?(p1)\nIf <i>file_name</i> is readable by others, returns an integer\nrepresenting the file permission bits of <i>file_name</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   File.world_readable?("/etc/passwd")           #=> 420\n   m = File.world_readable?("/etc/passwd")\n   sprintf("%o", m)                              #=> "644"\n
world_writable? FileTest.world_writable?(p1)\nIf <i>file_name</i> is writable by others, returns an integer\nrepresenting the file permission bits of <i>file_name</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   File.world_writable?("/tmp")                  #=> 511\n   m = File.world_writable?("/tmp")\n   sprintf("%o", m)                              #=> "777"\n
writable? FileTest.writable?(p1)\nReturns `true` if the named file is writable by the effective\nuser id of this process.\n
writable_real? FileTest.writable_real?(p1)\nReturns `true` if the named file is writable by the real\nuser id of this process.\n
zero? FileTest.zero?(p1)\nReturns `true` if the named file exists and has\na zero size.\n
count GC.count()\nThe number of times GC occurred.\n\nIt returns the number of times GC occurred since the process started.\n
disable GC.disable()\nDisables garbage collection, returning `true` if garbage\ncollection was already disabled.\n\n   GC.disable   #=> false\n   GC.disable   #=> true\n
enable GC.enable()\nEnables garbage collection, returning `true` if garbage\ncollection was previously disabled.\n\n   GC.disable   #=> false\n   GC.enable    #=> true\n   GC.enable    #=> false\n
malloc_allocated_size GC.malloc_allocated_size()\nThe allocated size by malloc().\n\nIt returns the allocated size by malloc().\n
malloc_allocations GC.malloc_allocations()\nThe number of allocated memory object by malloc().\n\nIt returns the number of allocated memory object by malloc().\n
start GC.start()\nInitiates garbage collection, unless manually disabled.\n
stress GC.stress()\nreturns current status of GC stress mode.\n
stress= GC.stress=(p1)\nupdates GC stress mode.\n\nWhen GC.stress = true, GC is invoked for all GC opportunity:\nall memory and object allocation.\n\nSince it makes Ruby very slow, it is only for debugging.\n
garbage_collect GC.garbage_collect()\nInitiates garbage collection, unless manually disabled.\n
clear GC::Profiler.clear()\nclear before profile data.\n
disable GC::Profiler.disable()\nupdates GC profile mode.\nstop profiler for GC.\n
enable GC::Profiler.enable()\nupdates GC profile mode.\nstart profiler for GC.\n
enabled? GC::Profiler.enabled?()\nreturns current status of GC profile mode.\n
report GC::Profiler.report(...)\nGC::Profiler.result display\n
result GC::Profiler.result()\nReport profile data to string.\n\nIt returns a string as:\n GC 1 invokes.\n Index    Invoke Time(sec)       Use Size(byte)     Total Size(byte)\n Total Object                    GC time(ms)\n     1               0.012               159240               212940\n     10647         0.00000000000001530000\n
total_time GC::Profiler.total_time()\nreturn total time that GC used. (msec)\n
_id2ref ObjectSpace._id2ref(p1)\nConverts an object id to a reference to the object. May not be\ncalled on an object id passed as a parameter to a finalizer.\n\n   s = "I am a string"                    #=> "I am a string"\n   r = ObjectSpace._id2ref(s.object_id)   #=> "I am a string"\n   r == s                                 #=> true\n
count_objects ObjectSpace.count_objects(...)\nCounts objects for each type.\n\nIt returns a hash as:\n{:TOTAL=>10000, :FREE=>3011, :T_OBJECT=>6, :T_CLASS=>404, ...}\n\nIf the optional argument, result_hash, is given,\nit is overwritten and returned.\nThis is intended to avoid probe effect.\n\nThe contents of the returned hash is implementation defined.\nIt may be changed in future.\n\nThis method is not expected to work except C Ruby.\n
define_finalizer ObjectSpace.define_finalizer(...)\nAdds <i>aProc</i> as a finalizer, to be called after <i>obj</i>\nwas destroyed.\n
each_object ObjectSpace.each_object(...)\nCalls the block once for each living, nonimmediate object in this\nRuby process. If <i>module</i> is specified, calls the block\nfor only those classes or modules that match (or are a subclass of)\n<i>module</i>. Returns the number of objects found. Immediate\nobjects (`Fixnum`s, `Symbol`s\n`true`, `false`, and `nil`) are\nnever returned. In the example below, `each_object`\nreturns both the numbers we defined and several constants defined in\nthe `Math` module.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = 102.7\n   b = 95       # Won't be returned\n   c = 12345678987654321\n   count = ObjectSpace.each_object(Numeric) {|x| p x }\n   puts "Total count: #{count}"\n\n<em>produces:</em>\n\n   12345678987654321\n   102.7\n   2.71828182845905\n   3.14159265358979\n   2.22044604925031e-16\n   1.7976931348623157e+308\n   2.2250738585072e-308\n   Total count: 7\n
garbage_collect ObjectSpace.garbage_collect()\nInitiates garbage collection, unless manually disabled.\n
undefine_finalizer ObjectSpace.undefine_finalizer(p1)\nRemoves all finalizers for <i>obj</i>.\n
clear GC::Profiler.clear()\nclear before profile data.\n
disable GC::Profiler.disable()\nupdates GC profile mode.\nstop profiler for GC.\n
enable GC::Profiler.enable()\nupdates GC profile mode.\nstart profiler for GC.\n
enabled? GC::Profiler.enabled?()\nreturns current status of GC profile mode.\n
report GC::Profiler.report(...)\nGC::Profiler.result display\n
result GC::Profiler.result()\nReport profile data to string.\n\nIt returns a string as:\n GC 1 invokes.\n Index    Invoke Time(sec)       Use Size(byte)     Total Size(byte)\n Total Object                    GC time(ms)\n     1               0.012               159240               212940\n     10647         0.00000000000001530000\n
total_time GC::Profiler.total_time()\nreturn total time that GC used. (msec)\n
dump Marshal.dump(...)\nSerializes obj and all descendant objects. If anIO is\nspecified, the serialized data will be written to it, otherwise the\ndata will be returned as a String. If limit is specified, the\ntraversal of subobjects will be limited to that depth. If limit is\nnegative, no checking of depth will be performed.\n\n    class Klass\n      def initialize(str)\n        @str = str\n      end\n      def sayHello\n        @str\n      end\n    end\n\n(produces no output)\n\n    o = Klass.new("hello\\n")\n    data = Marshal.dump(o)\n    obj = Marshal.load(data)\n    obj.sayHello   #=> "hello\\n"\n\nMarshal can't dump following objects:\n* anonymous Class/Module.\n* objects which related to its system (ex: Dir, File::Stat, IO, File, Socket\n  and so on)\n* an instance of MatchData, Data, Method, UnboundMethod, Proc, Thread,\n  ThreadGroup, Continuation\n* objects which defines singleton methods\n
load Marshal.load(...)\nReturns the result of converting the serialized data in source into a\nRuby object (possibly with associated subordinate objects). source\nmay be either an instance of IO or an object that responds to\nto_str. If proc is specified, it will be passed each object as it\nis deserialized.\n
restore Marshal.restore(...)\nReturns the result of converting the serialized data in source into a\nRuby object (possibly with associated subordinate objects). source\nmay be either an instance of IO or an object that responds to\nto_str. If proc is specified, it will be passed each object as it\nis deserialized.\n
acos Math.acos(p1)\nComputes the arc cosine of <i>x</i>. Returns 0..PI.\n
acosh Math.acosh(p1)\nComputes the inverse hyperbolic cosine of <i>x</i>.\n
asin Math.asin(p1)\nComputes the arc sine of <i>x</i>. Returns -{PI/2} .. {PI/2}.\n
asinh Math.asinh(p1)\nComputes the inverse hyperbolic sine of <i>x</i>.\n
atan Math.atan(p1)\nComputes the arc tangent of <i>x</i>. Returns -{PI/2} .. {PI/2}.\n
atan2 Math.atan2(p1, p2)\nComputes the arc tangent given <i>y</i> and <i>x</i>. Returns\n-PI..PI.\n\n  Math.atan2(-0.0, -1.0) #=> -3.141592653589793\n  Math.atan2(-1.0, -1.0) #=> -2.356194490192345\n  Math.atan2(-1.0, 0.0)  #=> -1.5707963267948966\n  Math.atan2(-1.0, 1.0)  #=> -0.7853981633974483\n  Math.atan2(-0.0, 1.0)  #=> -0.0\n  Math.atan2(0.0, 1.0)   #=> 0.0\n  Math.atan2(1.0, 1.0)   #=> 0.7853981633974483\n  Math.atan2(1.0, 0.0)   #=> 1.5707963267948966\n  Math.atan2(1.0, -1.0)  #=> 2.356194490192345\n  Math.atan2(0.0, -1.0)  #=> 3.141592653589793\n
atanh Math.atanh(p1)\nComputes the inverse hyperbolic tangent of <i>x</i>.\n
cbrt Math.cbrt(p1)\nReturns the cube root of <i>numeric</i>.\n\n  -9.upto(9) {|x|\n    p [x, Math.cbrt(x), Math.cbrt(x)**3]\n  }\n=>\n  [-9, -2.0800838230519, -9.0]\n  [-8, -2.0, -8.0]\n  [-7, -1.91293118277239, -7.0]\n  [-6, -1.81712059283214, -6.0]\n  [-5, -1.7099759466767, -5.0]\n  [-4, -1.5874010519682, -4.0]\n  [-3, -1.44224957030741, -3.0]\n  [-2, -1.25992104989487, -2.0]\n  [-1, -1.0, -1.0]\n  [0, 0.0, 0.0]\n  [1, 1.0, 1.0]\n  [2, 1.25992104989487, 2.0]\n  [3, 1.44224957030741, 3.0]\n  [4, 1.5874010519682, 4.0]\n  [5, 1.7099759466767, 5.0]\n  [6, 1.81712059283214, 6.0]\n  [7, 1.91293118277239, 7.0]\n  [8, 2.0, 8.0]\n  [9, 2.0800838230519, 9.0]\n
cos Math.cos(p1)\nComputes the cosine of <i>x</i> (expressed in radians). Returns\n-1..1.\n
cosh Math.cosh(p1)\nComputes the hyperbolic cosine of <i>x</i> (expressed in radians).\n
erf Math.erf(p1)\nCalculates the error function of x.\n
erfc Math.erfc(p1)\nCalculates the complementary error function of x.\n
exp Math.exp(p1)\nReturns e**x.\n\n  Math.exp(0)       #=> 1.0\n  Math.exp(1)       #=> 2.718281828459045\n  Math.exp(1.5)     #=> 4.4816890703380645\n
frexp Math.frexp(p1)\nReturns a two-element array containing the normalized fraction (a\n`Float`) and exponent (a `Fixnum`) of\n<i>numeric</i>.\n\n   fraction, exponent = Math.frexp(1234)   #=> [0.6025390625, 11]\n   fraction * 2**exponent                  #=> 1234.0\n
gamma Math.gamma(p1)\nCalculates the gamma function of x.\n\nNote that gamma(n) is same as fact(n-1) for integer n > 0.\nHowever gamma(n) returns float and can be an approximation.\n\n def fact(n) (1..n).inject(1) {|r,i| r*i } end\n 1.upto(26) {|i| p [i, Math.gamma(i), fact(i-1)] }\n=> [1, 1.0, 1]\n   [2, 1.0, 1]\n   [3, 2.0, 2]\n   [4, 6.0, 6]\n   [5, 24.0, 24]\n   [6, 120.0, 120]\n   [7, 720.0, 720]\n   [8, 5040.0, 5040]\n   [9, 40320.0, 40320]\n   [10, 362880.0, 362880]\n   [11, 3628800.0, 3628800]\n   [12, 39916800.0, 39916800]\n   [13, 479001600.0, 479001600]\n   [14, 6227020800.0, 6227020800]\n   [15, 87178291200.0, 87178291200]\n   [16, 1307674368000.0, 1307674368000]\n   [17, 20922789888000.0, 20922789888000]\n   [18, 355687428096000.0, 355687428096000]\n   [19, 6.402373705728e+15, 6402373705728000]\n   [20, 1.21645100408832e+17, 121645100408832000]\n   [21, 2.43290200817664e+18, 2432902008176640000]\n   [22, 5.109094217170944e+19, 51090942171709440000]\n   [23, 1.1240007277776077e+21, 1124000727777607680000]\n   [24, 2.5852016738885062e+22, 25852016738884976640000]\n   [25, 6.204484017332391e+23, 620448401733239439360000]\n   [26, 1.5511210043330954e+25, 15511210043330985984000000]\n
hypot Math.hypot(p1, p2)\nReturns sqrt(x**2 + y**2), the hypotenuse of a right-angled triangle\nwith sides <i>x</i> and <i>y</i>.\n\n   Math.hypot(3, 4)   #=> 5.0\n
ldexp Math.ldexp(p1, p2)\nReturns the value of <i>flt</i>*(2**<i>int</i>).\n\n   fraction, exponent = Math.frexp(1234)\n   Math.ldexp(fraction, exponent)   #=> 1234.0\n
lgamma Math.lgamma(p1)\nCalculates the logarithmic gamma of x and\nthe sign of gamma of x.\n\nMath.lgamma(x) is same as\n [Math.log(Math.gamma(x).abs), Math.gamma(x) < 0 ? -1 : 1]\nbut avoid overflow by Math.gamma(x) for large x.\n
log Math.log(...)\nReturns the natural logarithm of <i>numeric</i>.\nIf additional second argument is given, it will be the base\nof logarithm.\n\n  Math.log(1)          #=> 0.0\n  Math.log(Math::E)    #=> 1.0\n  Math.log(Math::E**3) #=> 3.0\n  Math.log(12,3)       #=> 2.2618595071429146\n
log10 Math.log10(p1)\nReturns the base 10 logarithm of <i>numeric</i>.\n\n  Math.log10(1)       #=> 0.0\n  Math.log10(10)      #=> 1.0\n  Math.log10(10**100) #=> 100.0\n
log2 Math.log2(p1)\nReturns the base 2 logarithm of <i>numeric</i>.\n\n  Math.log2(1)      #=> 0.0\n  Math.log2(2)      #=> 1.0\n  Math.log2(32768)  #=> 15.0\n  Math.log2(65536)  #=> 16.0\n
sin Math.sin(p1)\nComputes the sine of <i>x</i> (expressed in radians). Returns\n-1..1.\n
sinh Math.sinh(p1)\nComputes the hyperbolic sine of <i>x</i> (expressed in\nradians).\n
sqrt Math.sqrt(p1)\nReturns the non-negative square root of <i>numeric</i>.\n\n  0.upto(10) {|x|\n    p [x, Math.sqrt(x), Math.sqrt(x)**2]\n  }\n=>\n  [0, 0.0, 0.0]\n  [1, 1.0, 1.0]\n  [2, 1.4142135623731, 2.0]\n  [3, 1.73205080756888, 3.0]\n  [4, 2.0, 4.0]\n  [5, 2.23606797749979, 5.0]\n  [6, 2.44948974278318, 6.0]\n  [7, 2.64575131106459, 7.0]\n  [8, 2.82842712474619, 8.0]\n  [9, 3.0, 9.0]\n  [10, 3.16227766016838, 10.0]\n
tan Math.tan(p1)\nReturns the tangent of <i>x</i> (expressed in radians).\n
tanh Math.tanh(p1)\nComputes the hyperbolic tangent of <i>x</i> (expressed in\nradians).\n
abort Process.abort(...)\nTerminate execution immediately, effectively by calling\n`Kernel.exit(false)`. If _msg_ is given, it is written\nto STDERR prior to terminating.\n
daemon Process.daemon(...)\nDetach the process from controlling terminal and run in\nthe background as system daemon.  Unless the argument\nnochdir is true (i.e. non false), it changes the current\nworking directory to the root ("/"). Unless the argument\nnoclose is true, daemon() will redirect standard input,\nstandard output and standard error to /dev/null.\nReturn zero on success, or raise one of Errno::*.\n
detach Process.detach(p1)\nSome operating systems retain the status of terminated child\nprocesses until the parent collects that status (normally using\nsome variant of `wait()`. If the parent never collects\nthis status, the child stays around as a <em>zombie</em> process.\n`Process::detach` prevents this by setting up a\nseparate Ruby thread whose sole job is to reap the status of the\nprocess _pid_ when it terminates. Use `detach`\nonly when you do not intent to explicitly wait for the child to\nterminate.\n\nThe waiting thread returns the exit status of the detached process\nwhen it terminates, so you can use `Thread#join` to\nknow the result.  If specified _pid_ is not a valid child process\nID, the thread returns +nil+ immediately.\n\nThe waiting thread has `pid` method which returns the pid.\n\nIn this first example, we don't reap the first child process, so\nit appears as a zombie in the process status display.\n\n   p1 = fork { sleep 0.1 }\n   p2 = fork { sleep 0.2 }\n   Process.waitpid(p2)\n   sleep 2\n   system("ps -ho pid,state -p #{p1}")\n\n<em>produces:</em>\n\n   27389 Z\n\nIn the next example, `Process::detach` is used to reap\nthe child automatically.\n\n   p1 = fork { sleep 0.1 }\n   p2 = fork { sleep 0.2 }\n   Process.detach(p1)\n   Process.waitpid(p2)\n   sleep 2\n   system("ps -ho pid,state -p #{p1}")\n\n<em>(produces no output)</em>\n
egid Process.egid()\nReturns the effective group ID for this process. Not available on\nall platforms.\n\n   Process.egid   #=> 500\n
egid= Process.egid=(p1)\nSets the effective group ID for this process. Not available on all\nplatforms.\n
euid Process.euid()\nReturns the effective user ID for this process.\n\n   Process.euid   #=> 501\n
euid= Process.euid=(p1)\nSets the effective user ID for this process. Not available on all\nplatforms.\n
exec Process.exec(...)\nReplaces the current process by running the given external _command_.\n_command..._ is one of following forms.\n\n  commandline                 : command line string which is passed to the\n  standard shell\n  cmdname, arg1, ...          : command name and one or more arguments\n  (no shell)\n  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more\n  arguments (no shell)\n\nIf single string is given as the command,\nit is taken as a command line that is subject to shell expansion before\nbeing executed.\n\nThe standard shell means always `"/bin/sh"` on Unix-like systems,\n`ENV["RUBYSHELL"]` or `ENV["COMSPEC"]` on Windows NT series, and\nsimilar.\n\nIf two or more +string+ given,\nthe first is taken as a command name and\nthe rest are passed as parameters to command with no shell expansion.\n\nIf a two-element array at the beginning of the command,\nthe first element is the command to be executed,\nand the second argument is used as the `argv[0]` value,\nwhich may show up in process listings.\n\nIn order to execute the command, one of the `exec(2)`\nsystem calls is used, so the running command may inherit some of the\nenvironment\nof the original program (including open file descriptors).\nThis behavior is modified by env and options.\nSee `spawn` for details.\n\nRaises SystemCallError if the command couldn't execute (typically\n`Errno::ENOENT` when it was not found).\n\n   exec "echo *"       # echoes list of files in current directory\n never get here\n\n\n   exec "echo", "*"    # echoes an asterisk\n never get here\n
exit Process.exit(...)\nInitiates the termination of the Ruby script by raising the\n`SystemExit` exception. This exception may be caught. The\noptional parameter is used to return a status code to the invoking\nenvironment.\n+true+ and +FALSE+ of _status_ means success and failure\nrespectively.  The interpretation of other integer values are\nsystem dependent.\n\n   begin\n     exit\n     puts "never get here"\n   rescue SystemExit\n     puts "rescued a SystemExit exception"\n   end\n   puts "after begin block"\n\n<em>produces:</em>\n\n   rescued a SystemExit exception\n   after begin block\n\nJust prior to termination, Ruby executes any `at_exit` functions\n(see Kernel::at_exit) and runs any object finalizers (see\nObjectSpace::define_finalizer).\n\n   at_exit { puts "at_exit function" }\n   ObjectSpace.define_finalizer("string",  proc { puts "in finalizer" })\n   exit\n\n<em>produces:</em>\n\n   at_exit function\n   in finalizer\n
exit! Process.exit!(...)\nExits the process immediately. No exit handlers are\nrun. <em>status</em> is returned to the underlying system as the\nexit status.\n\n   Process.exit!(true)\n
fork Process.fork()\nCreates a subprocess. If a block is specified, that block is run\nin the subprocess, and the subprocess terminates with a status of\nzero. Otherwise, the +fork+ call returns twice, once in\nthe parent, returning the process ID of the child, and once in\nthe child, returning _nil_. The child process can exit using\n`Kernel.exit!` to avoid running any\n`at_exit` functions. The parent process should\nuse `Process.wait` to collect the termination statuses\nof its children or use `Process.detach` to register\ndisinterest in their status; otherwise, the operating system\nmay accumulate zombie processes.\n\nThe thread calling fork is the only thread in the created child process.\nfork doesn't copy other threads.\n\nIf fork is not usable, Process.respond_to?(:fork) returns false.\n
getpgid Process.getpgid(p1)\nReturns the process group ID for the given process id. Not\navailable on all platforms.\n\n   Process.getpgid(Process.ppid())   #=> 25527\n
getpgrp Process.getpgrp()\nReturns the process group ID for this process. Not available on\nall platforms.\n\n   Process.getpgid(0)   #=> 25527\n   Process.getpgrp      #=> 25527\n
getpriority Process.getpriority(p1, p2)\nGets the scheduling priority for specified process, process group,\nor user. <em>kind</em> indicates the kind of entity to find: one\nof `Process::PRIO_PGRP`,\n`Process::PRIO_USER`, or\n`Process::PRIO_PROCESS`. _integer_ is an id\nindicating the particular process, process group, or user (an id\nof 0 means _current_). Lower priorities are more favorable\nfor scheduling. Not available on all platforms.\n\n   Process.getpriority(Process::PRIO_USER, 0)      #=> 19\n   Process.getpriority(Process::PRIO_PROCESS, 0)   #=> 19\n
getrlimit Process.getrlimit(p1)\nGets the resource limit of the process.\n_cur_limit_ means current (soft) limit and\n_max_limit_ means maximum (hard) limit.\n\n_resource_ indicates the kind of resource to limit.\nIt is specified as a symbol such as `:CORE`,\na string such as `"CORE"` or\na constant such as `Process::RLIMIT_CORE`.\nSee Process.setrlimit for details.\n\n_cur_limit_ and _max_limit_ may be `Process::RLIM_INFINITY`,\n`Process::RLIM_SAVED_MAX` or\n`Process::RLIM_SAVED_CUR`.\nSee Process.setrlimit and the system getrlimit(2) manual for details.\n
gid Process.gid()\nReturns the (real) group ID for this process.\n\n   Process.gid   #=> 500\n
gid= Process.gid=(p1)\nSets the group ID for this process.\n
groups Process.groups()\nGet an `Array` of the gids of groups in the\nsupplemental group access list for this process.\n\n   Process.groups   #=> [27, 6, 10, 11]\n
groups= Process.groups=(p1)\nSet the supplemental group access list to the given\n`Array` of group IDs.\n\n   Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]\n   Process.groups = [27, 6, 10, 11]   #=> [27, 6, 10, 11]\n   Process.groups   #=> [27, 6, 10, 11]\n
initgroups Process.initgroups(p1, p2)\nInitializes the supplemental group access list by reading the\nsystem group database and using all groups of which the given user\nis a member. The group with the specified <em>gid</em> is also\nadded to the list. Returns the resulting `Array` of the\ngids of all the groups in the supplementary group access list. Not\navailable on all platforms.\n\n   Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]\n   Process.initgroups( "mgranger", 30 )   #=> [30, 6, 10, 11]\n   Process.groups   #=> [30, 6, 10, 11]\n
kill Process.kill(...)\nSends the given signal to the specified process id(s), or to the\ncurrent process if _pid_ is zero. _signal_ may be an\ninteger signal number or a POSIX signal name (either with or without\na +SIG+ prefix). If _signal_ is negative (or starts\nwith a minus sign), kills process groups instead of\nprocesses. Not all signals are available on all platforms.\n\n   pid = fork do\n      Signal.trap("HUP") { puts "Ouch!"; exit }\n ... do some work ...\n   end\n ...\n   Process.kill("HUP", pid)\n   Process.wait\n\n<em>produces:</em>\n\n   Ouch!\n\nIf _signal_ is an integer but wrong for signal,\n`Errno::EINVAL` or +RangeError+ will be raised.\nOtherwise unless _signal_ is a +String+ or a +Symbol+, and a known\nsignal name, +ArgumentError+ will be raised.\n\nAlso, `Errno::ESRCH` or +RangeError+ for invalid _pid_,\n`Errno::EPERM` when failed because of no privilege,\nwill be raised.  In these cases, signals may have been sent to\npreceding processes.\n
maxgroups Process.maxgroups()\nReturns the maximum number of gids allowed in the supplemental\ngroup access list.\n\n   Process.maxgroups   #=> 32\n
maxgroups= Process.maxgroups=(p1)\nSets the maximum number of gids allowed in the supplemental group\naccess list.\n
pid Process.pid()\nReturns the process id of this process. Not available on all\nplatforms.\n\n   Process.pid   #=> 27415\n
ppid Process.ppid()\nReturns the process id of the parent of this process. Returns\nuntrustworthy value on Win32/64. Not available on all platforms.\n\n   puts "I am #{Process.pid}"\n   Process.fork { puts "Dad is #{Process.ppid}" }\n\n<em>produces:</em>\n\n   I am 27417\n   Dad is 27417\n
setpgid Process.setpgid(p1, p2)\nSets the process group ID of _pid_ (0 indicates this\nprocess) to <em>integer</em>. Not available on all platforms.\n
setpgrp Process.setpgrp()\nEquivalent to `setpgid(0,0)`. Not available on all\nplatforms.\n
setpriority Process.setpriority(p1, p2, p3)\nSee `Process#getpriority`.\n\n   Process.setpriority(Process::PRIO_USER, 0, 19)      #=> 0\n   Process.setpriority(Process::PRIO_PROCESS, 0, 19)   #=> 0\n   Process.getpriority(Process::PRIO_USER, 0)          #=> 19\n   Process.getpriority(Process::PRIO_PROCESS, 0)       #=> 19\n
setrlimit Process.setrlimit(...)\nSets the resource limit of the process.\n_cur_limit_ means current (soft) limit and\n_max_limit_ means maximum (hard) limit.\n\nIf _max_limit_ is not given, _cur_limit_ is used.\n\n_resource_ indicates the kind of resource to limit.\nIt should be a symbol such as `:CORE`,\na string such as `"CORE"` or\na constant such as `Process::RLIMIT_CORE`.\nThe available resources are OS dependent.\nRuby may support following resources.\n\n[CORE] core size (bytes) (SUSv3)\n[CPU] CPU time (seconds) (SUSv3)\n[DATA] data segment (bytes) (SUSv3)\n[FSIZE] file size (bytes) (SUSv3)\n[NOFILE] file descriptors (number) (SUSv3)\n[STACK] stack size (bytes) (SUSv3)\n[AS] total available memory (bytes) (SUSv3, NetBSD, FreeBSD, OpenBSD but\n4.4BSD-Lite)\n[MEMLOCK] total size for mlock(2) (bytes) (4.4BSD, GNU/Linux)\n[NPROC] number of processes for the user (number) (4.4BSD, GNU/Linux)\n[RSS] resident memory size (bytes) (4.2BSD, GNU/Linux)\n[SBSIZE] all socket buffers (bytes) (NetBSD, FreeBSD)\n\n_cur_limit_ and _max_limit_ may be\n`:INFINITY`, `"INFINITY"` or\n`Process::RLIM_INFINITY`,\nwhich means that the resource is not limited.\nThey may be `Process::RLIM_SAVED_MAX`,\n`Process::RLIM_SAVED_CUR` and\ncorresponding symbols and strings too.\nSee system setrlimit(2) manual for details.\n\nThe following example raise the soft limit of core size to\nthe hard limit to try to make core dump possible.\n\n  Process.setrlimit(:CORE, Process.getrlimit(:CORE)[1])\n
setsid Process.setsid()\nEstablishes this process as a new session and process group\nleader, with no controlling tty. Returns the session id. Not\navailable on all platforms.\n\n   Process.setsid   #=> 27422\n
spawn Process.spawn(...)\nspawn executes specified command and return its pid.\n\nThis method doesn't wait for end of the command.\nThe parent process should\nuse `Process.wait` to collect\nthe termination status of its child or\nuse `Process.detach` to register\ndisinterest in their status;\notherwise, the operating system may accumulate zombie processes.\n\nspawn has bunch of options to specify process attributes:\n\n  env: hash\n    name => val : set the environment variable\n    name => nil : unset the environment variable\n  command...:\n    commandline                 : command line string which is passed to\n    the standard shell\n    cmdname, arg1, ...          : command name and one or more arguments\n    (no shell)\n    [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more\n    arguments (no shell)\n  options: hash\n    clearing environment variables:\n      :unsetenv_others => true   : clear environment variables except\n      specified by env\n      :unsetenv_others => false  : don't clear (default)\n    process group:\n      :pgroup => true or 0 : make a new process group\n      :pgroup => pgid      : join to specified process group\n      :pgroup => nil       : don't change the process group (default)\n    resource limit: resourcename is core, cpu, data, etc.  See\n    Process.setrlimit.\n      :rlimit_resourcename => limit\n      :rlimit_resourcename => [cur_limit, max_limit]\n    current directory:\n      :chdir => str\n    umask:\n      :umask => int\n    redirection:\n      key:\n        FD              : single file descriptor in child process\n        [FD, FD, ...]   : multiple file descriptor in child process\n      value:\n        FD                        : redirect to the file descriptor in\n        parent process\n        string                    : redirect to file with open(string,\n        "r" or "w")\n        [string]                  : redirect to file with open(string,\n        File::RDONLY)\n        [string, open_mode]       : redirect to file with open(string,\n        open_mode, 0644)\n        [string, open_mode, perm] : redirect to file with open(string,\n        open_mode, perm)\n        [:child, FD]              : redirect to the redirected file descriptor\n        :close                    : close the file descriptor in child process\n      FD is one of follows\n        :in     : the file descriptor 0 which is the standard input\n        :out    : the file descriptor 1 which is the standard output\n        :err    : the file descriptor 2 which is the standard error\n        integer : the file descriptor of specified the integer\n        io      : the file descriptor specified as io.fileno\n    file descriptor inheritance: close non-redirected non-standard fds (3,\n    4, 5, ...) or not\n      :close_others => false : inherit fds (default for system and exec)\n      :close_others => true  : don't inherit (default for spawn and IO.popen)\n\nIf a hash is given as +env+, the environment is\nupdated by +env+ before `exec(2)` in the child process.\nIf a pair in +env+ has nil as the value, the variable is deleted.\n set FOO as BAR and unset BAZ.\n  pid = spawn({"FOO"=>"BAR", "BAZ"=>nil}, command)\n\nIf a hash is given as +options+,\nit specifies\nprocess group,\nresource limit,\ncurrent directory,\numask and\nredirects for the child process.\nAlso, it can be specified to clear environment variables.\n\nThe `:unsetenv_others` key in +options+ specifies\nto clear environment variables, other than specified by +env+.\n\n  pid = spawn(command, :unsetenv_others=>true) # no environment variable\n  pid = spawn({"FOO"=>"BAR"}, command, :unsetenv_others=>true) # FOO only\n\nThe `:pgroup` key in +options+ specifies a process group.\nThe corresponding value should be true, zero or positive integer.\ntrue and zero means the process should be a process leader of a new\nprocess group.\nOther values specifies a process group to be belongs.\n\n  pid = spawn(command, :pgroup=>true) # process leader\n  pid = spawn(command, :pgroup=>10) # belongs to the process group 10\n\nThe `:rlimit_`<em>foo</em> key specifies a resource limit.\n<em>foo</em> should be one of resource types such as `core`.\nThe corresponding value should be an integer or an array which have one or\ntwo integers: same as cur_limit and max_limit arguments for\nProcess.setrlimit.\n\n  cur, max = Process.getrlimit(:CORE)\n  pid = spawn(command, :rlimit_core=>[0,max]) # disable core temporary.\n  pid = spawn(command, :rlimit_core=>max) # enable core dump\n  pid = spawn(command, :rlimit_core=>0) # never dump core.\n\nThe `:chdir` key in +options+ specifies the current directory.\n\n  pid = spawn(command, :chdir=>"/var/tmp")\n\nThe `:umask` key in +options+ specifies the umask.\n\n  pid = spawn(command, :umask=>077)\n\nThe :in, :out, :err, a fixnum, an IO and an array key specifies a redirection.\nThe redirection maps a file descriptor in the child process.\n\nFor example, stderr can be merged into stdout as follows:\n\n  pid = spawn(command, :err=>:out)\n  pid = spawn(command, 2=>1)\n  pid = spawn(command, STDERR=>:out)\n  pid = spawn(command, STDERR=>STDOUT)\n\nThe hash keys specifies a file descriptor\nin the child process started by `spawn`.\n:err, 2 and STDERR specifies the standard error stream (stderr).\n\nThe hash values specifies a file descriptor\nin the parent process which invokes `spawn`.\n:out, 1 and STDOUT specifies the standard output stream (stdout).\n\nIn the above example,\nthe standard output in the child process is not specified.\nSo it is inherited from the parent process.\n\nThe standard input stream (stdin) can be specified by :in, 0 and STDIN.\n\nA filename can be specified as a hash value.\n\n  pid = spawn(command, :in=>"/dev/null") # read mode\n  pid = spawn(command, :out=>"/dev/null") # write mode\n  pid = spawn(command, :err=>"log") # write mode\n  pid = spawn(command, 3=>"/dev/null") # read mode\n\nFor stdout and stderr,\nit is opened in write mode.\nOtherwise read mode is used.\n\nFor specifying flags and permission of file creation explicitly,\nan array is used instead.\n\n  pid = spawn(command, :in=>["file"]) # read mode is assumed\n  pid = spawn(command, :in=>["file", "r"])\n  pid = spawn(command, :out=>["log", "w"]) # 0644 assumed\n  pid = spawn(command, :out=>["log", "w", 0600])\n  pid = spawn(command, :out=>["log", File::WRONLY|File::EXCL|File::CREAT,\n  0600])\n\nThe array specifies a filename, flags and permission.\nThe flags can be a string or an integer.\nIf the flags is omitted or nil, File::RDONLY is assumed.\nThe permission should be an integer.\nIf the permission is omitted or nil, 0644 is assumed.\n\nIf an array of IOs and integers are specified as a hash key,\nall the elements are redirected.\n stdout and stderr is redirected to log file.\n The file "log" is opened just once.\n  pid = spawn(command, [:out, :err]=>["log", "w"])\n\nAnother way to merge multiple file descriptors is [:child, fd].\n\[:child, fd] means the file descriptor in the child process.\nThis is different from fd.\nFor example, :err=>:out means redirecting child stderr to parent stdout.\nBut :err=>[:child, :out] means redirecting child stderr to child stdout.\nThey differs if stdout is redirected in the child process as follows.\n stdout and stderr is redirected to log file.\n The file "log" is opened just once.\n  pid = spawn(command, :out=>["log", "w"], :err=>[:child, :out])\n\n\[:child, :out] can be used to merge stderr into stdout in IO.popen.\nIn this case, IO.popen redirects stdout to a pipe in the child process\nand [:child, :out] refers the redirected stdout.\n\n  io = IO.popen(["sh", "-c", "echo out; echo err >&2", :err=>[:child, :out]])\n  p io.read #=> "out\\nerr\\n"\n\nspawn closes all non-standard unspecified descriptors by default.\nThe "standard" descriptors are 0, 1 and 2.\nThis behavior is specified by :close_others option.\n:close_others doesn't affect the standard descriptors which are\nclosed only if :close is specified explicitly.\n\n  pid = spawn(command, :close_others=>true)  # close 3,4,5,... (default)\n  pid = spawn(command, :close_others=>false) # don't close 3,4,5,...\n\n:close_others is true by default for spawn and IO.popen.\n\nSo IO.pipe and spawn can be used as IO.popen.\n similar to r = IO.popen(command)\n  r, w = IO.pipe\n  pid = spawn(command, :out=>w)   # r, w is closed in the child process.\n  w.close\n\n:close is specified as a hash value to close a fd individually.\n\n  f = open(foo)\n  system(command, f=>:close)        # don't inherit f.\n\nIf a file descriptor need to be inherited,\nio=>io can be used.\n valgrind has --log-fd option for log destination.\n log_w=>log_w indicates log_w.fileno inherits to child process.\n  log_r, log_w = IO.pipe\n  pid = spawn("valgrind", "--log-fd=#{log_w.fileno}", "echo", "a",\n  log_w=>log_w)\n  log_w.close\n  p log_r.read\n\nIt is also possible to exchange file descriptors.\n\n  pid = spawn(command, :out=>:err, :err=>:out)\n\nThe hash keys specify file descriptors in the child process.\nThe hash values specifies file descriptors in the parent process.\nSo the above specifies exchanging stdout and stderr.\nInternally, +spawn+ uses an extra file descriptor to resolve such cyclic\nfile descriptor mapping.\n\nSee `Kernel.exec` for the standard shell.\n
times Process.times()\nReturns a `Tms` structure (see `Struct::Tms`\non page 388) that contains user and system CPU times for this\nprocess.\n\n   t = Process.times\n   [ t.utime, t.stime ]   #=> [0.0, 0.02]\n
uid Process.uid()\nReturns the (real) user ID of this process.\n\n   Process.uid   #=> 501\n
uid= Process.uid=(p1)\nSets the (integer) user ID for this process. Not available on all\nplatforms.\n
wait Process.wait(...)\nWaits for a child process to exit, returns its process id, and\nsets `$?` to a `Process::Status` object\ncontaining information on that process. Which child it waits on\ndepends on the value of _pid_:\n\n> 0::   Waits for the child whose process ID equals _pid_.\n\n0::     Waits for any child whose process group ID equals that of the\n        calling process.\n\n-1::    Waits for any child process (the default if no _pid_ is\n        given).\n\n< -1::  Waits for any child whose process group ID equals the absolute\n        value of _pid_.\n\nThe _flags_ argument may be a logical or of the flag values\n`Process::WNOHANG` (do not block if no child available)\nor `Process::WUNTRACED` (return stopped children that\nhaven't been reported). Not all flags are available on all\nplatforms, but a flag value of zero will work on all platforms.\n\nCalling this method raises a `SystemError` if there are\nno child processes. Not available on all platforms.\n\n   include Process\n   fork { exit 99 }                 #=> 27429\n   wait                             #=> 27429\n   $?.exitstatus                    #=> 99\n\n   pid = fork { sleep 3 }           #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, Process::WNOHANG)   #=> nil\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, 0)                  #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:19 +0900\n
wait2 Process.wait2(...)\nWaits for a child process to exit (see Process::waitpid for exact\nsemantics) and returns an array containing the process id and the\nexit status (a `Process::Status` object) of that\nchild. Raises a `SystemError` if there are no child\nprocesses.\n\n   Process.fork { exit 99 }   #=> 27437\n   pid, status = Process.wait2\n   pid                        #=> 27437\n   status.exitstatus          #=> 99\n
waitall Process.waitall()\nWaits for all children, returning an array of\n_pid_/_status_ pairs (where _status_ is a\n`Process::Status` object).\n\n   fork { sleep 0.2; exit 2 }   #=> 27432\n   fork { sleep 0.1; exit 1 }   #=> 27433\n   fork {            exit 0 }   #=> 27434\n   p Process.waitall\n\n<em>produces</em>:\n\n   [[27434, #<Process::Status: pid=27434,exited(0)>],\n    [27433, #<Process::Status: pid=27433,exited(1)>],\n    [27432, #<Process::Status: pid=27432,exited(2)>]]\n
waitpid Process.waitpid(...)\nWaits for a child process to exit, returns its process id, and\nsets `$?` to a `Process::Status` object\ncontaining information on that process. Which child it waits on\ndepends on the value of _pid_:\n\n> 0::   Waits for the child whose process ID equals _pid_.\n\n0::     Waits for any child whose process group ID equals that of the\n        calling process.\n\n-1::    Waits for any child process (the default if no _pid_ is\n        given).\n\n< -1::  Waits for any child whose process group ID equals the absolute\n        value of _pid_.\n\nThe _flags_ argument may be a logical or of the flag values\n`Process::WNOHANG` (do not block if no child available)\nor `Process::WUNTRACED` (return stopped children that\nhaven't been reported). Not all flags are available on all\nplatforms, but a flag value of zero will work on all platforms.\n\nCalling this method raises a `SystemError` if there are\nno child processes. Not available on all platforms.\n\n   include Process\n   fork { exit 99 }                 #=> 27429\n   wait                             #=> 27429\n   $?.exitstatus                    #=> 99\n\n   pid = fork { sleep 3 }           #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, Process::WNOHANG)   #=> nil\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, 0)                  #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:19 +0900\n
waitpid2 Process.waitpid2(...)\nWaits for a child process to exit (see Process::waitpid for exact\nsemantics) and returns an array containing the process id and the\nexit status (a `Process::Status` object) of that\nchild. Raises a `SystemError` if there are no child\nprocesses.\n\n   Process.fork { exit 99 }   #=> 27437\n   pid, status = Process.wait2\n   pid                        #=> 27437\n   status.exitstatus          #=> 99\n
change_privilege Process::GID.change_privilege(p1)\nChange the current process's real and effective group ID to that\nspecified by _integer_. Returns the new group ID. Not\navailable on all platforms.\n\n   [Process.gid, Process.egid]          #=> [0, 0]\n   Process::GID.change_privilege(33)    #=> 33\n   [Process.gid, Process.egid]          #=> [33, 33]\n
eid Process::GID.eid()\nReturns the effective group ID for this process. Not available on\nall platforms.\n\n   Process.egid   #=> 500\n
grant_privilege Process::GID.grant_privilege(p1)\nSet the effective group ID, and if possible, the saved group ID of\nthe process to the given _integer_. Returns the new\neffective group ID. Not available on all platforms.\n\n   [Process.gid, Process.egid]          #=> [0, 0]\n   Process::GID.grant_privilege(31)     #=> 33\n   [Process.gid, Process.egid]          #=> [0, 33]\n
re_exchange Process::GID.re_exchange()\nExchange real and effective group IDs and return the new effective\ngroup ID. Not available on all platforms.\n\n   [Process.gid, Process.egid]   #=> [0, 33]\n   Process::GID.re_exchange      #=> 0\n   [Process.gid, Process.egid]   #=> [33, 0]\n
re_exchangeable? Process::GID.re_exchangeable?()\nReturns +true+ if the real and effective group IDs of a\nprocess may be exchanged on the current platform.\n
rid Process::GID.rid()\nReturns the (real) group ID for this process.\n\n   Process.gid   #=> 500\n
sid_available? Process::GID.sid_available?()\nReturns +true+ if the current platform has saved group\nID functionality.\n
switch Process::GID.switch()\nSwitch the effective and real group IDs of the current process. If\na <em>block</em> is given, the group IDs will be switched back\nafter the block is executed. Returns the new effective group ID if\ncalled without a block, and the return value of the block if one\nis given.\n
coredump? Process::Status.coredump?()\nReturns +true+ if _stat_ generated a coredump\nwhen it terminated. Not available on all platforms.\n
exited? Process::Status.exited?()\nReturns +true+ if _stat_ exited normally (for\nexample using an `exit()` call or finishing the\nprogram).\n
exitstatus Process::Status.exitstatus()\nReturns the least significant eight bits of the return code of\n_stat_. Only available if `exited?` is\n+true+.\n\n   fork { }           #=> 26572\n   Process.wait       #=> 26572\n   $?.exited?         #=> true\n   $?.exitstatus      #=> 0\n\n   fork { exit 99 }   #=> 26573\n   Process.wait       #=> 26573\n   $?.exited?         #=> true\n   $?.exitstatus      #=> 99\n
inspect Process::Status.inspect()\nOverride the inspection method.\n
pid Process::Status.pid()\nReturns the process ID that this status object represents.\n\n   fork { exit }   #=> 26569\n   Process.wait    #=> 26569\n   $?.pid          #=> 26569\n
signaled? Process::Status.signaled?()\nReturns +true+ if _stat_ terminated because of\nan uncaught signal.\n
stopped? Process::Status.stopped?()\nReturns +true+ if this process is stopped. This is only\nreturned if the corresponding `wait` call had the\n`WUNTRACED` flag set.\n
stopsig Process::Status.stopsig()\nReturns the number of the signal that caused _stat_ to stop\n(or +nil+ if self is not stopped).\n
success? Process::Status.success?()\nReturns +true+ if _stat_ is successful, +false+ if not.\nReturns +nil+ if `exited?` is not +true+.\n
termsig Process::Status.termsig()\nReturns the number of the signal that caused _stat_ to\nterminate (or +nil+ if self was not terminated by an\nuncaught signal).\n
to_i Process::Status.to_i()\nReturns the bits in _stat_ as a `Fixnum`. Poking\naround in these bits is platform dependent.\n\n   fork { exit 0xab }         #=> 26566\n   Process.wait               #=> 26566\n   sprintf('%04x', $?.to_i)   #=> "ab00"\n
to_s Process::Status.to_s()\nShow pid and exit status as a string.\n
getegid Process::Sys.getegid()\nReturns the effective group ID for this process. Not available on\nall platforms.\n\n   Process.egid   #=> 500\n
geteuid Process::Sys.geteuid()\nReturns the effective user ID for this process.\n\n   Process.euid   #=> 501\n
getgid Process::Sys.getgid()\nReturns the (real) group ID for this process.\n\n   Process.gid   #=> 500\n
getuid Process::Sys.getuid()\nReturns the (real) user ID of this process.\n\n   Process.uid   #=> 501\n
issetugid Process::Sys.issetugid()\nReturns +true+ if the process was created as a result\nof an execve(2) system call which had either of the setuid or\nsetgid bits set (and extra privileges were given as a result) or\nif it has changed any of its real, effective or saved user or\ngroup IDs since it began execution.\n
setegid Process::Sys.setegid(p1)\nSet the effective group ID of the calling process to\n_integer_.  Not available on all platforms.\n
seteuid Process::Sys.seteuid(p1)\nSet the effective user ID of the calling process to\n_integer_.  Not available on all platforms.\n
setgid Process::Sys.setgid(p1)\nSet the group ID of the current process to _integer_. Not\navailable on all platforms.\n
setregid Process::Sys.setregid(p1, p2)\nSets the (integer) real and/or effective group IDs of the current\nprocess to <em>rid</em> and <em>eid</em>, respectively. A value of\n`-1` for either means to leave that ID unchanged. Not\navailable on all platforms.\n
setresgid Process::Sys.setresgid(p1, p2, p3)\nSets the (integer) real, effective, and saved user IDs of the\ncurrent process to <em>rid</em>, <em>eid</em>, and <em>sid</em>\nrespectively. A value of `-1` for any value means to\nleave that ID unchanged. Not available on all platforms.\n
setresuid Process::Sys.setresuid(p1, p2, p3)\nSets the (integer) real, effective, and saved user IDs of the\ncurrent process to _rid_, _eid_, and _sid_ respectively. A\nvalue of `-1` for any value means to\nleave that ID unchanged. Not available on all platforms.\n
setreuid Process::Sys.setreuid(p1, p2)\nSets the (integer) real and/or effective user IDs of the current\nprocess to _rid_ and _eid_, respectively. A value of\n`-1` for either means to leave that ID unchanged. Not\navailable on all platforms.\n
setrgid Process::Sys.setrgid(p1)\nSet the real group ID of the calling process to _integer_.\nNot available on all platforms.\n
setruid Process::Sys.setruid(p1)\nSet the real user ID of the calling process to _integer_.\nNot available on all platforms.\n
setuid Process::Sys.setuid(p1)\nSet the user ID of the current process to _integer_. Not\navailable on all platforms.\n
change_privilege Process::UID.change_privilege(p1)\nChange the current process's real and effective user ID to that\nspecified by _integer_. Returns the new user ID. Not\navailable on all platforms.\n\n   [Process.uid, Process.euid]          #=> [0, 0]\n   Process::UID.change_privilege(31)    #=> 31\n   [Process.uid, Process.euid]          #=> [31, 31]\n
eid Process::UID.eid()\nReturns the effective user ID for this process.\n\n   Process.euid   #=> 501\n
grant_privilege Process::UID.grant_privilege(p1)\nSet the effective user ID, and if possible, the saved user ID of\nthe process to the given _integer_. Returns the new\neffective user ID. Not available on all platforms.\n\n   [Process.uid, Process.euid]          #=> [0, 0]\n   Process::UID.grant_privilege(31)     #=> 31\n   [Process.uid, Process.euid]          #=> [0, 31]\n
re_exchange Process::UID.re_exchange()\nExchange real and effective user IDs and return the new effective\nuser ID. Not available on all platforms.\n\n   [Process.uid, Process.euid]   #=> [0, 31]\n   Process::UID.re_exchange      #=> 0\n   [Process.uid, Process.euid]   #=> [31, 0]\n
re_exchangeable? Process::UID.re_exchangeable?()\nReturns +true+ if the real and effective user IDs of a\nprocess may be exchanged on the current platform.\n
rid Process::UID.rid()\nReturns the (real) user ID of this process.\n\n   Process.uid   #=> 501\n
sid_available? Process::UID.sid_available?()\nReturns +true+ if the current platform has saved user\nID functionality.\n
switch Process::UID.switch()\nSwitch the effective and real user IDs of the current process. If\na <em>block</em> is given, the user IDs will be switched back\nafter the block is executed. Returns the new effective user ID if\ncalled without a block, and the return value of the block if one\nis given.\n
change_privilege Process::UID.change_privilege(p1)\nChange the current process's real and effective user ID to that\nspecified by _integer_. Returns the new user ID. Not\navailable on all platforms.\n\n   [Process.uid, Process.euid]          #=> [0, 0]\n   Process::UID.change_privilege(31)    #=> 31\n   [Process.uid, Process.euid]          #=> [31, 31]\n
eid Process::UID.eid()\nReturns the effective user ID for this process.\n\n   Process.euid   #=> 501\n
grant_privilege Process::UID.grant_privilege(p1)\nSet the effective user ID, and if possible, the saved user ID of\nthe process to the given _integer_. Returns the new\neffective user ID. Not available on all platforms.\n\n   [Process.uid, Process.euid]          #=> [0, 0]\n   Process::UID.grant_privilege(31)     #=> 31\n   [Process.uid, Process.euid]          #=> [0, 31]\n
re_exchange Process::UID.re_exchange()\nExchange real and effective user IDs and return the new effective\nuser ID. Not available on all platforms.\n\n   [Process.uid, Process.euid]   #=> [0, 31]\n   Process::UID.re_exchange      #=> 0\n   [Process.uid, Process.euid]   #=> [31, 0]\n
re_exchangeable? Process::UID.re_exchangeable?()\nReturns +true+ if the real and effective user IDs of a\nprocess may be exchanged on the current platform.\n
rid Process::UID.rid()\nReturns the (real) user ID of this process.\n\n   Process.uid   #=> 501\n
sid_available? Process::UID.sid_available?()\nReturns +true+ if the current platform has saved user\nID functionality.\n
switch Process::UID.switch()\nSwitch the effective and real user IDs of the current process. If\na <em>block</em> is given, the user IDs will be switched back\nafter the block is executed. Returns the new effective user ID if\ncalled without a block, and the return value of the block if one\nis given.\n
change_privilege Process::GID.change_privilege(p1)\nChange the current process's real and effective group ID to that\nspecified by _integer_. Returns the new group ID. Not\navailable on all platforms.\n\n   [Process.gid, Process.egid]          #=> [0, 0]\n   Process::GID.change_privilege(33)    #=> 33\n   [Process.gid, Process.egid]          #=> [33, 33]\n
eid Process::GID.eid()\nReturns the effective group ID for this process. Not available on\nall platforms.\n\n   Process.egid   #=> 500\n
grant_privilege Process::GID.grant_privilege(p1)\nSet the effective group ID, and if possible, the saved group ID of\nthe process to the given _integer_. Returns the new\neffective group ID. Not available on all platforms.\n\n   [Process.gid, Process.egid]          #=> [0, 0]\n   Process::GID.grant_privilege(31)     #=> 33\n   [Process.gid, Process.egid]          #=> [0, 33]\n
re_exchange Process::GID.re_exchange()\nExchange real and effective group IDs and return the new effective\ngroup ID. Not available on all platforms.\n\n   [Process.gid, Process.egid]   #=> [0, 33]\n   Process::GID.re_exchange      #=> 0\n   [Process.gid, Process.egid]   #=> [33, 0]\n
re_exchangeable? Process::GID.re_exchangeable?()\nReturns +true+ if the real and effective group IDs of a\nprocess may be exchanged on the current platform.\n
rid Process::GID.rid()\nReturns the (real) group ID for this process.\n\n   Process.gid   #=> 500\n
sid_available? Process::GID.sid_available?()\nReturns +true+ if the current platform has saved group\nID functionality.\n
switch Process::GID.switch()\nSwitch the effective and real group IDs of the current process. If\na <em>block</em> is given, the group IDs will be switched back\nafter the block is executed. Returns the new effective group ID if\ncalled without a block, and the return value of the block if one\nis given.\n
getegid Process::Sys.getegid()\nReturns the effective group ID for this process. Not available on\nall platforms.\n\n   Process.egid   #=> 500\n
geteuid Process::Sys.geteuid()\nReturns the effective user ID for this process.\n\n   Process.euid   #=> 501\n
getgid Process::Sys.getgid()\nReturns the (real) group ID for this process.\n\n   Process.gid   #=> 500\n
getuid Process::Sys.getuid()\nReturns the (real) user ID of this process.\n\n   Process.uid   #=> 501\n
issetugid Process::Sys.issetugid()\nReturns +true+ if the process was created as a result\nof an execve(2) system call which had either of the setuid or\nsetgid bits set (and extra privileges were given as a result) or\nif it has changed any of its real, effective or saved user or\ngroup IDs since it began execution.\n
setegid Process::Sys.setegid(p1)\nSet the effective group ID of the calling process to\n_integer_.  Not available on all platforms.\n
seteuid Process::Sys.seteuid(p1)\nSet the effective user ID of the calling process to\n_integer_.  Not available on all platforms.\n
setgid Process::Sys.setgid(p1)\nSet the group ID of the current process to _integer_. Not\navailable on all platforms.\n
setregid Process::Sys.setregid(p1, p2)\nSets the (integer) real and/or effective group IDs of the current\nprocess to <em>rid</em> and <em>eid</em>, respectively. A value of\n`-1` for either means to leave that ID unchanged. Not\navailable on all platforms.\n
setresgid Process::Sys.setresgid(p1, p2, p3)\nSets the (integer) real, effective, and saved user IDs of the\ncurrent process to <em>rid</em>, <em>eid</em>, and <em>sid</em>\nrespectively. A value of `-1` for any value means to\nleave that ID unchanged. Not available on all platforms.\n
setresuid Process::Sys.setresuid(p1, p2, p3)\nSets the (integer) real, effective, and saved user IDs of the\ncurrent process to _rid_, _eid_, and _sid_ respectively. A\nvalue of `-1` for any value means to\nleave that ID unchanged. Not available on all platforms.\n
setreuid Process::Sys.setreuid(p1, p2)\nSets the (integer) real and/or effective user IDs of the current\nprocess to _rid_ and _eid_, respectively. A value of\n`-1` for either means to leave that ID unchanged. Not\navailable on all platforms.\n
setrgid Process::Sys.setrgid(p1)\nSet the real group ID of the calling process to _integer_.\nNot available on all platforms.\n
setruid Process::Sys.setruid(p1)\nSet the real user ID of the calling process to _integer_.\nNot available on all platforms.\n
setuid Process::Sys.setuid(p1)\nSet the user ID of the current process to _integer_. Not\navailable on all platforms.\n
